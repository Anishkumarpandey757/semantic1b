[
  {
    "idx": 1,
    "query_type": "simple_select",
    "question": "List the name of clubs in ascending alphabetical order.",
    "db_schema": "/* Schema not available */",
    "ground_truth": "SELECT Name FROM club ORDER BY Name ASC",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "Simple SELECT",
    "difficulty": "Easy"
  },
  {
    "idx": 2,
    "query_type": "simple_select",
    "question": "List the addresses of buildings in descending order of building completion year.",
    "db_schema": "/* Schema not available */",
    "ground_truth": "SELECT Address FROM building ORDER BY Completed_Year DESC",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "Simple SELECT",
    "difficulty": "Easy"
  },
  {
    "idx": 3,
    "query_type": "simple_select",
    "question": "What are the titles of books with the highest purchase price across all books ?",
    "db_schema": "/* Schema not available */",
    "ground_truth": "select title from book order by purchaseprice  desc limit 1",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "Simple SELECT",
    "difficulty": "Easy"
  },
  {
    "idx": 4,
    "query_type": "simple_select",
    "question": "What are the model, class, and construction of the cheapest headphone?",
    "db_schema": "/* Schema not available */",
    "ground_truth": "SELECT model ,  CLASS ,  construction FROM headphone ORDER BY price LIMIT 1",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "Simple SELECT",
    "difficulty": "Easy"
  },
  {
    "idx": 5,
    "query_type": "simple_select",
    "question": "List the names of all distinct paintings in alphabetical order.",
    "db_schema": "/* Schema not available */",
    "ground_truth": "SELECT DISTINCT title FROM paintings ORDER BY title",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "Simple SELECT",
    "difficulty": "Easy"
  },
  {
    "idx": 6,
    "query_type": "simple_select",
    "question": "Return the stadiums of institutions, ordered by capacity descending.",
    "db_schema": "/* Schema not available */",
    "ground_truth": "SELECT Stadium FROM institution ORDER BY Capacity DESC",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "Simple SELECT",
    "difficulty": "Easy"
  },
  {
    "idx": 7,
    "query_type": "simple_select",
    "question": "list all the names of press in descending order of the profit of the year.",
    "db_schema": "/* Schema not available */",
    "ground_truth": "SELECT name FROM press ORDER BY Year_Profits_billion DESC",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "Simple SELECT",
    "difficulty": "Easy"
  },
  {
    "idx": 8,
    "query_type": "simple_select",
    "question": "What is the horsepower of the car with the greatest accelerate?",
    "db_schema": "continents(ContId number, Continent text; PRIMARY KEY(ContId))\ncountries(CountryId number, CountryName text, Continent number; PRIMARY KEY(CountryId); FK(Continent REFERENCES continents(ContId)))\ncar_makers(Id number, Maker text, FullName text, Country text; PRIMARY KEY(Id); FK(Country REFERENCES countries(CountryId)))\nmodel_list(ModelId number, Maker number, Model text; PRIMARY KEY(ModelId); FK(Maker REFERENCES car_makers(Id)))\ncar_names(MakeId number, Model text, Make text; PRIMARY KEY(MakeId); FK(Model REFERENCES model_list(Model)))\ncars_data(Id number, MPG text, Cylinders number, Edispl number, Horsepower text, Weight number, Accelerate number, Year number; PRIMARY KEY(Id); FK(Id REFERENCES car_names(MakeId)))",
    "ground_truth": "SELECT T1.horsepower FROM CARS_DATA AS T1 ORDER BY T1.accelerate DESC LIMIT 1;",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "Simple SELECT",
    "difficulty": "Medium"
  },
  {
    "idx": 9,
    "query_type": "simple_select",
    "question": "What is the first, middle, and last name of the earliest school graduate?",
    "db_schema": "Addresses(address_id number, line_1 text, line_2 text, line_3 text, city text, zip_postcode text, state_province_county text, country text, other_address_details text; PRIMARY KEY(address_id))\nCourses(course_id number, course_name text, course_description text, other_details text; PRIMARY KEY(course_id))\nDepartments(department_id number, department_name text, department_description text, other_details text; PRIMARY KEY(department_id))\nDegree_Programs(degree_program_id number, department_id number, degree_summary_name text, degree_summary_description text, other_details text; PRIMARY KEY(degree_program_id); FK(department_id REFERENCES Departments(department_id)))\nSections(section_id number, course_id number, section_name text, section_description text, other_details text; PRIMARY KEY(section_id); FK(course_id REFERENCES Courses(course_id)))\nSemesters(semester_id number, semester_name text, semester_description text, other_details text; PRIMARY KEY(semester_id))\nStudents(student_id number, current_address_id number, permanent_address_id number, first_name text, middle_name text, last_name text, cell_mobile_number text, email_address text, ssn text, date_first_registered time, date_left time, other_student_details text; PRIMARY KEY(student_id); FK(current_address_id REFERENCES Addresses(address_id)); FK(permanent_address_id REFERENCES Addresses(address_id)))\nStudent_Enrolment(student_enrolment_id number, degree_program_id number, semester_id number, student_id number, other_details text; PRIMARY KEY(student_enrolment_id); FK(degree_program_id REFERENCES Degree_Programs(degree_program_id)); FK(semester_id REFERENCES Semesters(semester_id)); FK(student_id REFERENCES Students(student_id)))\nStudent_Enrolment_Courses(student_course_id number, course_id number, student_enrolment_id number; PRIMARY KEY(student_course_id); FK(course_id REFERENCES Courses(course_id)); FK(student_enrolment_id REFERENCES Student_Enrolment(student_enrolment_id)))\nTranscripts(transcript_id number, transcript_date time, other_details text; PRIMARY KEY(transcript_id))\nTranscript_Contents(student_course_id number, transcript_id number; FK(student_course_id REFERENCES Student_Enrolment_Courses(student_course_id)); FK(transcript_id REFERENCES Transcripts(transcript_id)))",
    "ground_truth": "SELECT first_name ,  middle_name ,  last_name FROM Students ORDER BY date_left ASC LIMIT 1",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "Simple SELECT",
    "difficulty": "Medium"
  },
  {
    "idx": 10,
    "query_type": "simple_select",
    "question": "What is the name of the conductor who has worked the greatest number of years?",
    "db_schema": "conductor(Conductor_ID number, Name text, Age number, Nationality text, Year_of_Work number; PRIMARY KEY(Conductor_ID))\norchestra(Orchestra_ID number, Orchestra text, Conductor_ID number, Record_Company text, Year_of_Founded number, Major_Record_Format text; PRIMARY KEY(Orchestra_ID); FK(Conductor_ID REFERENCES conductor(Conductor_ID)))\nperformance(Performance_ID number, Orchestra_ID number, Type text, Date text, Official_ratings_(millions) number, Weekly_rank text, Share text; PRIMARY KEY(Performance_ID); FK(Orchestra_ID REFERENCES orchestra(Orchestra_ID)))\nshow(Show_ID number, Performance_ID number, If_first_show others, Result text, Attendance number; FK(Performance_ID REFERENCES performance(Performance_ID)))",
    "ground_truth": "SELECT Name FROM conductor ORDER BY Year_of_Work DESC LIMIT 1",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "Simple SELECT",
    "difficulty": "Medium"
  },
  {
    "idx": 11,
    "query_type": "single_table_where",
    "question": "List the name of clubs whose manufacturer is not \"Nike\"",
    "db_schema": "/* Schema not available */",
    "ground_truth": "SELECT Name FROM club WHERE Manufacturer != \"Nike\"",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "Single-table WHERE",
    "difficulty": "Easy"
  },
  {
    "idx": 12,
    "query_type": "single_table_where",
    "question": "Find the details of the customer who has never used any services .",
    "db_schema": "/* Schema not available */",
    "ground_truth": "select customer_details from customers where customer_id not in (select customer_id from customers_and_services)",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "Single-table WHERE",
    "difficulty": "Medium"
  },
  {
    "idx": 13,
    "query_type": "single_table_where",
    "question": "Which headphone models do not have any stock in any store?",
    "db_schema": "/* Schema not available */",
    "ground_truth": "SELECT model FROM headphone WHERE headphone_id NOT IN (SELECT headphone_id FROM stock)",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "Single-table WHERE",
    "difficulty": "Medium"
  },
  {
    "idx": 14,
    "query_type": "single_table_where",
    "question": "Find the locations that have paintings before 1885 and no work with medium on canvas?",
    "db_schema": "/* Schema not available */",
    "ground_truth": "SELECT DISTINCT LOCATION FROM paintings WHERE YEAR  <  1885 AND mediumOn != \"canvas\"",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "Single-table WHERE",
    "difficulty": "Easy"
  },
  {
    "idx": 15,
    "query_type": "single_table_where",
    "question": "Select contents of all boxes with a value larger than $150.",
    "db_schema": "/* Schema not available */",
    "ground_truth": "SELECT CONTENTS FROM boxes WHERE Value  >  150",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "Single-table WHERE",
    "difficulty": "Easy"
  },
  {
    "idx": 16,
    "query_type": "single_table_where",
    "question": "Which abbreviation corresponds to Jetblue Airways?",
    "db_schema": "airlines(uid number, Airline text, Abbreviation text, Country text; PRIMARY KEY(uid))\nairports(City text, AirportCode text, AirportName text, Country text, CountryAbbrev text; PRIMARY KEY(AirportCode))\nflights(Airline number, FlightNo number, SourceAirport text, DestAirport text; PRIMARY KEY(Airline); FK(SourceAirport REFERENCES airports(AirportCode)); FK(DestAirport REFERENCES airports(AirportCode)))",
    "ground_truth": "SELECT Abbreviation FROM AIRLINES WHERE Airline  =  \"JetBlue Airways\"",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "Single-table WHERE",
    "difficulty": "Easy"
  },
  {
    "idx": 17,
    "query_type": "single_table_where",
    "question": "What is the description of the department whose name has the substring the computer?",
    "db_schema": "Addresses(address_id number, line_1 text, line_2 text, line_3 text, city text, zip_postcode text, state_province_county text, country text, other_address_details text; PRIMARY KEY(address_id))\nCourses(course_id number, course_name text, course_description text, other_details text; PRIMARY KEY(course_id))\nDepartments(department_id number, department_name text, department_description text, other_details text; PRIMARY KEY(department_id))\nDegree_Programs(degree_program_id number, department_id number, degree_summary_name text, degree_summary_description text, other_details text; PRIMARY KEY(degree_program_id); FK(department_id REFERENCES Departments(department_id)))\nSections(section_id number, course_id number, section_name text, section_description text, other_details text; PRIMARY KEY(section_id); FK(course_id REFERENCES Courses(course_id)))\nSemesters(semester_id number, semester_name text, semester_description text, other_details text; PRIMARY KEY(semester_id))\nStudents(student_id number, current_address_id number, permanent_address_id number, first_name text, middle_name text, last_name text, cell_mobile_number text, email_address text, ssn text, date_first_registered time, date_left time, other_student_details text; PRIMARY KEY(student_id); FK(current_address_id REFERENCES Addresses(address_id)); FK(permanent_address_id REFERENCES Addresses(address_id)))\nStudent_Enrolment(student_enrolment_id number, degree_program_id number, semester_id number, student_id number, other_details text; PRIMARY KEY(student_enrolment_id); FK(degree_program_id REFERENCES Degree_Programs(degree_program_id)); FK(semester_id REFERENCES Semesters(semester_id)); FK(student_id REFERENCES Students(student_id)))\nStudent_Enrolment_Courses(student_course_id number, course_id number, student_enrolment_id number; PRIMARY KEY(student_course_id); FK(course_id REFERENCES Courses(course_id)); FK(student_enrolment_id REFERENCES Student_Enrolment(student_enrolment_id)))\nTranscripts(transcript_id number, transcript_date time, other_details text; PRIMARY KEY(transcript_id))\nTranscript_Contents(student_course_id number, transcript_id number; FK(student_course_id REFERENCES Student_Enrolment_Courses(student_course_id)); FK(transcript_id REFERENCES Transcripts(transcript_id)))",
    "ground_truth": "SELECT department_description FROM Departments WHERE department_name LIKE '%computer%'",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "Single-table WHERE",
    "difficulty": "Medium"
  },
  {
    "idx": 18,
    "query_type": "single_table_where",
    "question": "Show the names of all high schoolers in grade 10.",
    "db_schema": "Highschooler(ID number, name text, grade number; PRIMARY KEY(ID))\nFriend(student_id number, friend_id number; PRIMARY KEY(student_id); FK(student_id REFERENCES Highschooler(ID)); FK(friend_id REFERENCES Highschooler(ID)))\nLikes(student_id number, liked_id number; PRIMARY KEY(student_id); FK(student_id REFERENCES Highschooler(ID)); FK(liked_id REFERENCES Highschooler(ID)))",
    "ground_truth": "SELECT name FROM Highschooler WHERE grade  =  10",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "Single-table WHERE",
    "difficulty": "Easy"
  },
  {
    "idx": 19,
    "query_type": "single_table_where",
    "question": "What are the cards belong to duel deck a? List the ID.",
    "db_schema": "cards(id integer, artist text, asciiName text, availability text, borderColor text, cardKingdomFoilId text, cardKingdomId text, colorIdentity text, colorIndicator text, colors text, convertedManaCost real, duelDeck text, edhrecRank integer, faceConvertedManaCost real, faceName text, flavorName text, flavorText text, frameEffects text, frameVersion text, hand text, hasAlternativeDeckLimit integer, hasContentWarning integer, hasFoil integer, hasNonFoil integer, isAlternative integer, isFullArt integer, isOnlineOnly integer, isOversized integer, isPromo integer, isReprint integer, isReserved integer, isStarter integer, isStorySpotlight integer, isTextless integer, isTimeshifted integer, keywords text, layout text, leadershipSkills text, life text, loyalty text, manaCost text, mcmId text, mcmMetaId text, mtgArenaId text, mtgjsonV4Id text, mtgoFoilId text, mtgoId text, multiverseId text, name text, number text, originalReleaseDate text, originalText text, originalType text, otherFaceIds text, power text, printings text, promoTypes text, purchaseUrls text, rarity text, scryfallId text, scryfallIllustrationId text, scryfallOracleId text, setCode text, side text, subtypes text, supertypes text, tcgplayerProductId text, text text, toughness text, type text, types text, uuid text, variations text, watermark text; PRIMARY KEY(id))\nforeign_data(id integer, flavorText text, language text, multiverseid integer, name text, text text, type text, uuid text; PRIMARY KEY(id); FK(uuid REFERENCES cards(uuid)))\nlegalities(id integer, format text, status text, uuid text; PRIMARY KEY(id); FK(uuid REFERENCES cards(uuid)))\nsets(id integer, baseSetSize integer, block text, booster text, code text, isFoilOnly integer, isForeignOnly integer, isNonFoilOnly integer, isOnlineOnly integer, isPartialPreview integer, keyruneCode text, mcmId integer, mcmIdExtras integer, mcmName text, mtgoCode text, name text, parentCode text, releaseDate date, tcgplayerGroupId integer, totalSetSize integer, type text; PRIMARY KEY(id))\nset_translations(id integer, language text, setCode text, translation text; PRIMARY KEY(id); FK(setCode REFERENCES sets(code)))\nrulings(id integer, date date, text text, uuid text; PRIMARY KEY(id); FK(uuid REFERENCES cards(uuid)))",
    "ground_truth": "SELECT id FROM cards WHERE duelDeck = 'a'",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "Single-table WHERE",
    "difficulty": "Medium"
  },
  {
    "idx": 20,
    "query_type": "single_table_where",
    "question": "What is the power ID of cryokinesis?",
    "db_schema": "alignment(id integer, alignment text; PRIMARY KEY(id))\nattribute(id integer, attribute_name text; PRIMARY KEY(id))\ncolour(id integer, colour text; PRIMARY KEY(id))\ngender(id integer, gender text; PRIMARY KEY(id))\npublisher(id integer, publisher_name text; PRIMARY KEY(id))\nrace(id integer, race text; PRIMARY KEY(id))\nsuperhero(id integer, superhero_name text, full_name text, gender_id integer, eye_colour_id integer, hair_colour_id integer, skin_colour_id integer, race_id integer, publisher_id integer, alignment_id integer, height_cm integer, weight_kg integer; PRIMARY KEY(id); FK(gender_id REFERENCES gender(id)); FK(eye_colour_id REFERENCES colour(id)); FK(hair_colour_id REFERENCES colour(id)); FK(skin_colour_id REFERENCES colour(id)); FK(race_id REFERENCES race(id)); FK(publisher_id REFERENCES publisher(id)); FK(alignment_id REFERENCES alignment(id)))\nhero_attribute(hero_id integer, attribute_id integer, attribute_value integer; FK(hero_id REFERENCES superhero(id)); FK(attribute_id REFERENCES attribute(id)))\nsuperpower(id integer, power_name text; PRIMARY KEY(id))\nhero_power(hero_id integer, power_id integer; FK(hero_id REFERENCES superhero(id)); FK(power_id REFERENCES superpower(id)))",
    "ground_truth": "SELECT id FROM superpower WHERE power_name = 'Cryokinesis'",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "Single-table WHERE",
    "difficulty": "Medium"
  },
  {
    "idx": 21,
    "query_type": "join_aggregation",
    "question": "Show names of clubs in descending order of average earnings of players belonging.",
    "db_schema": "/* Schema not available */",
    "ground_truth": "SELECT T1.Name FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID GROUP BY T1.Club_ID ORDER BY avg(T2.Earnings) DESC",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "2-table JOIN + aggregation",
    "difficulty": "Medium"
  },
  {
    "idx": 22,
    "query_type": "join_aggregation",
    "question": "What is the name of the client with the most number of orders?",
    "db_schema": "/* Schema not available */",
    "ground_truth": "SELECT T2.name FROM Orders AS T1 JOIN Client AS T2 ON T1.idClient  =  T2.idClient GROUP BY T1.idClient ORDER BY count(*) DESC LIMIT 1",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "2-table JOIN + aggregation",
    "difficulty": "Medium"
  },
  {
    "idx": 23,
    "query_type": "join_aggregation",
    "question": "Find the total number of papers for each affiliation.",
    "db_schema": "/* Schema not available */",
    "ground_truth": "SELECT count(DISTINCT T2.paper_id) ,  T1.name FROM Affiliation AS T1 JOIN Author_list AS T2 ON T1.affiliation_id  =  T2.affiliation_id GROUP BY T1.affiliation_id",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "2-table JOIN + aggregation",
    "difficulty": "Medium"
  },
  {
    "idx": 24,
    "query_type": "join_aggregation",
    "question": "For each warehouse location, what is the value of the most expensive box?",
    "db_schema": "/* Schema not available */",
    "ground_truth": "SELECT max(T1.value) ,  T2.location FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code GROUP BY T2.location",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "2-table JOIN + aggregation",
    "difficulty": "Medium"
  },
  {
    "idx": 25,
    "query_type": "join_aggregation",
    "question": "What are the names of all European countries with at least 3 manufacturers?",
    "db_schema": "continents(ContId number, Continent text; PRIMARY KEY(ContId))\ncountries(CountryId number, CountryName text, Continent number; PRIMARY KEY(CountryId); FK(Continent REFERENCES continents(ContId)))\ncar_makers(Id number, Maker text, FullName text, Country text; PRIMARY KEY(Id); FK(Country REFERENCES countries(CountryId)))\nmodel_list(ModelId number, Maker number, Model text; PRIMARY KEY(ModelId); FK(Maker REFERENCES car_makers(Id)))\ncar_names(MakeId number, Model text, Make text; PRIMARY KEY(MakeId); FK(Model REFERENCES model_list(Model)))\ncars_data(Id number, MPG text, Cylinders number, Edispl number, Horsepower text, Weight number, Accelerate number, Year number; PRIMARY KEY(Id); FK(Id REFERENCES car_names(MakeId)))",
    "ground_truth": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "2-table JOIN + aggregation",
    "difficulty": "Hard"
  },
  {
    "idx": 26,
    "query_type": "join_aggregation",
    "question": "What are the contestant numbers and names of the contestants who had at least two votes?",
    "db_schema": "AREA_CODE_STATE(area_code number, state text; PRIMARY KEY(area_code))\nCONTESTANTS(contestant_number number, contestant_name text; PRIMARY KEY(contestant_number))\nVOTES(vote_id number, phone_number number, state text, contestant_number number, created time; PRIMARY KEY(vote_id); FK(state REFERENCES AREA_CODE_STATE(state)); FK(contestant_number REFERENCES CONTESTANTS(contestant_number)))",
    "ground_truth": "SELECT T1.contestant_number , T1.contestant_name FROM contestants AS T1 JOIN votes AS T2 ON T1.contestant_number  =  T2.contestant_number GROUP BY T1.contestant_number HAVING count(*)  >=  2",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "2-table JOIN + aggregation",
    "difficulty": "Hard"
  },
  {
    "idx": 27,
    "query_type": "join_aggregation",
    "question": "Calculate the percentage of account from 'Decin' district for all accounts are opened in 1993.",
    "db_schema": "account(account_id integer, district_id integer, frequency text, date date; PRIMARY KEY(account_id); FK(district_id REFERENCES district(district_id)))\ncard(card_id integer, disp_id integer, type text, issued date; PRIMARY KEY(card_id); FK(disp_id REFERENCES disp(disp_id)))\nclient(client_id integer, gender text, birth_date date, district_id integer; PRIMARY KEY(client_id); FK(district_id REFERENCES district(district_id)))\ndisp(disp_id integer, client_id integer, account_id integer, type text; PRIMARY KEY(disp_id); FK(client_id REFERENCES client(client_id)); FK(account_id REFERENCES account(account_id)))\ndistrict(district_id integer, A2 text, A3 text, A4 text, A5 text, A6 text, A7 text, A8 integer, A9 integer, A10 real, A11 integer, A12 real, A13 real, A14 integer, A15 integer, A16 integer; PRIMARY KEY(district_id))\nloan(loan_id integer, account_id integer, date date, amount integer, duration integer, payments real, status text; PRIMARY KEY(loan_id); FK(account_id REFERENCES account(account_id)))\norder(order_id integer, account_id integer, bank_to text, account_to integer, amount real, k_symbol text; PRIMARY KEY(order_id); FK(account_id REFERENCES account(account_id)))\ntrans(trans_id integer, account_id integer, date date, type text, operation text, amount integer, balance integer, k_symbol text, bank text, account integer; PRIMARY KEY(trans_id); FK(account_id REFERENCES account(account_id)))",
    "ground_truth": "SELECT CAST(SUM(T1.A2 = 'Decin') AS REAL) * 100 / COUNT(account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T2.date) = '1993'",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "2-table JOIN + aggregation",
    "difficulty": "Hard"
  },
  {
    "idx": 28,
    "query_type": "join_aggregation",
    "question": "What is the annual average number of sets that were released between 1/1/2012 to 12/31/2015? Indicate the common langugage of the card.",
    "db_schema": "cards(id integer, artist text, asciiName text, availability text, borderColor text, cardKingdomFoilId text, cardKingdomId text, colorIdentity text, colorIndicator text, colors text, convertedManaCost real, duelDeck text, edhrecRank integer, faceConvertedManaCost real, faceName text, flavorName text, flavorText text, frameEffects text, frameVersion text, hand text, hasAlternativeDeckLimit integer, hasContentWarning integer, hasFoil integer, hasNonFoil integer, isAlternative integer, isFullArt integer, isOnlineOnly integer, isOversized integer, isPromo integer, isReprint integer, isReserved integer, isStarter integer, isStorySpotlight integer, isTextless integer, isTimeshifted integer, keywords text, layout text, leadershipSkills text, life text, loyalty text, manaCost text, mcmId text, mcmMetaId text, mtgArenaId text, mtgjsonV4Id text, mtgoFoilId text, mtgoId text, multiverseId text, name text, number text, originalReleaseDate text, originalText text, originalType text, otherFaceIds text, power text, printings text, promoTypes text, purchaseUrls text, rarity text, scryfallId text, scryfallIllustrationId text, scryfallOracleId text, setCode text, side text, subtypes text, supertypes text, tcgplayerProductId text, text text, toughness text, type text, types text, uuid text, variations text, watermark text; PRIMARY KEY(id))\nforeign_data(id integer, flavorText text, language text, multiverseid integer, name text, text text, type text, uuid text; PRIMARY KEY(id); FK(uuid REFERENCES cards(uuid)))\nlegalities(id integer, format text, status text, uuid text; PRIMARY KEY(id); FK(uuid REFERENCES cards(uuid)))\nsets(id integer, baseSetSize integer, block text, booster text, code text, isFoilOnly integer, isForeignOnly integer, isNonFoilOnly integer, isOnlineOnly integer, isPartialPreview integer, keyruneCode text, mcmId integer, mcmIdExtras integer, mcmName text, mtgoCode text, name text, parentCode text, releaseDate date, tcgplayerGroupId integer, totalSetSize integer, type text; PRIMARY KEY(id))\nset_translations(id integer, language text, setCode text, translation text; PRIMARY KEY(id); FK(setCode REFERENCES sets(code)))\nrulings(id integer, date date, text text, uuid text; PRIMARY KEY(id); FK(uuid REFERENCES cards(uuid)))",
    "ground_truth": "SELECT (CAST(SUM(T1.id) AS REAL) / COUNT(T1.id)) / 4, T2.language FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.id = T2.id WHERE T1.releaseDate BETWEEN '2012-01-01' AND '2015-12-31' GROUP BY T1.releaseDate ORDER BY COUNT(T2.language) DESC LIMIT 1",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "2-table JOIN + aggregation",
    "difficulty": "Hard"
  },
  {
    "idx": 29,
    "query_type": "join_aggregation",
    "question": "List circuits which host 4 f1 races from year 1990 to 2000.",
    "db_schema": "circuits(circuitId integer, circuitRef text, name text, location text, country text, lat real, lng real, alt integer, url text; PRIMARY KEY(circuitId))\nconstructors(constructorId integer, constructorRef text, name text, nationality text, url text; PRIMARY KEY(constructorId))\ndrivers(driverId integer, driverRef text, number integer, code text, forename text, surname text, dob date, nationality text, url text; PRIMARY KEY(driverId))\nseasons(year integer, url text; PRIMARY KEY(year))\nraces(raceId integer, year integer, round integer, circuitId integer, name text, date date, time text, url text; PRIMARY KEY(raceId); FK(year REFERENCES seasons(year)); FK(circuitId REFERENCES circuits(circuitId)))\nconstructorResults(constructorResultsId integer, raceId integer, constructorId integer, points real, status text; PRIMARY KEY(constructorResultsId); FK(raceId REFERENCES races(raceId)); FK(constructorId REFERENCES constructors(constructorId)))\nconstructorStandings(constructorStandingsId integer, raceId integer, constructorId integer, points real, position integer, positionText text, wins integer; PRIMARY KEY(constructorStandingsId); FK(raceId REFERENCES races(raceId)); FK(constructorId REFERENCES constructors(constructorId)))\ndriverStandings(driverStandingsId integer, raceId integer, driverId integer, points real, position integer, positionText text, wins integer; PRIMARY KEY(driverStandingsId); FK(raceId REFERENCES races(raceId)); FK(driverId REFERENCES drivers(driverId)))\nlapTimes(raceId integer, driverId integer, lap integer, position integer, time text, milliseconds integer; FK(raceId REFERENCES races(raceId)); FK(driverId REFERENCES drivers(driverId)))\npitStops(raceId integer, driverId integer, stop integer, lap integer, time text, duration text, milliseconds integer; FK(raceId REFERENCES races(raceId)); FK(driverId REFERENCES drivers(driverId)))\nqualifying(qualifyId integer, raceId integer, driverId integer, constructorId integer, number integer, position integer, q1 text, q2 text, q3 text; PRIMARY KEY(qualifyId); FK(raceId REFERENCES races(raceId)); FK(driverId REFERENCES drivers(driverId)); FK(constructorId REFERENCES constructors(constructorId)))\nstatus(statusId integer, status text; PRIMARY KEY(statusId))\nresults(resultId integer, raceId integer, driverId integer, constructorId integer, number integer, grid integer, position integer, positionText text, positionOrder integer, points real, laps integer, time text, milliseconds integer, fastestLap integer, rank integer, fastestLapTime text, fastestLapSpeed text, statusId integer; PRIMARY KEY(resultId); FK(raceId REFERENCES races(raceId)); FK(driverId REFERENCES drivers(driverId)); FK(constructorId REFERENCES constructors(constructorId)); FK(statusId REFERENCES status(statusId)))",
    "ground_truth": "SELECT DISTINCT T1.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE STRFTIME('%Y', T2.date) BETWEEN '1990' AND '2000' GROUP BY T1.name HAVING COUNT(T2.raceId) = 4",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "2-table JOIN + aggregation",
    "difficulty": "Hard"
  },
  {
    "idx": 30,
    "query_type": "join_aggregation",
    "question": "For the examinations done after 1997/1/1, how many of them have the result of an inactivated partial prothrom bin time?",
    "db_schema": "Examination(ID integer, Examination Date date, aCL IgG real, aCL IgM real, ANA integer, ANA Pattern text, aCL IgA integer, Diagnosis text, KCT text, RVVT text, LAC text, Symptoms text, Thrombosis integer; FK(ID REFERENCES Patient(ID)))\nPatient(ID integer, SEX text, Birthday date, Description date, First Date date, Admission text, Diagnosis text; PRIMARY KEY(ID))\nLaboratory(ID integer, Date date, GOT integer, GPT integer, LDH integer, ALP integer, TP real, ALB real, UA real, UN integer, CRE real, T-BIL real, T-CHO integer, TG integer, CPK integer, GLU integer, WBC real, RBC real, HGB real, HCT real, PLT integer, PT real, APTT integer, FG real, PIC integer, TAT integer, TAT2 integer, U-PRO text, IGG integer, IGA integer, IGM integer, CRP text, RA text, RF text, C3 integer, C4 integer, RNP text, SM text, SC170 text, SSA text, SSB text, CENTROMEA text, DNA text, DNA-II integer; FK(ID REFERENCES Patient(ID)))",
    "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.Date > '1997-01-01' AND T2.APTT >= 45",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "2-table JOIN + aggregation",
    "difficulty": "Medium"
  },
  {
    "idx": 31,
    "query_type": "multi_join",
    "question": "List the id, first name and last name of the customers who both have placed more than 2 orders and have bought at least 3 items.",
    "db_schema": "/* Schema not available */",
    "ground_truth": "SELECT T1.customer_id ,  T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Orders AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id HAVING count(*)  >  2 INTERSECT SELECT T1.customer_id ,  T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Orders AS T2 ON T1.customer_id  =  T2.customer_id JOIN Order_items AS T3 ON T2.order_id  =  T3.order_id GROUP BY T1.customer_id HAVING count(*)  >= 3",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "3+ table JOINs",
    "difficulty": "Hard"
  },
  {
    "idx": 32,
    "query_type": "multi_join",
    "question": "What are the vehicle ids and models which have been driven by more than 2 drivers or been driven by the driver named 'Jeff Gordon'?",
    "db_schema": "/* Schema not available */",
    "ground_truth": "SELECT T1.vehicle_id ,  T1.model FROM vehicle AS T1 JOIN vehicle_driver AS T2 ON T1.vehicle_id  =  T2.vehicle_id JOIN driver AS T3 ON T2.driver_id  =  T3.driver_id WHERE T3.name  =  'Jeff Gordon' UNION SELECT T1.vehicle_id ,  T1.model FROM vehicle AS T1 JOIN vehicle_driver AS T2 ON T1.vehicle_id  =  T2.vehicle_id GROUP BY T2.vehicle_id HAVING count(*)  >  2",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "3+ table JOINs",
    "difficulty": "Hard"
  },
  {
    "idx": 33,
    "query_type": "multi_join",
    "question": "What are the names of clients who have ordered Pride and Prejudice?",
    "db_schema": "/* Schema not available */",
    "ground_truth": "SELECT T3.name FROM Orders AS T1 JOIN Books_Order AS T2 ON T1.idOrder  =  T2.idOrder JOIN Client AS T3 ON T1.idClient  =  T3.idClient JOIN Book AS T4 ON T4.isbn  =  T2.isbn WHERE T4.title  =  \"Pride and Prejudice\"",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "3+ table JOINs",
    "difficulty": "Medium"
  },
  {
    "idx": 34,
    "query_type": "multi_join",
    "question": "Find all papers with titles and paper IDs collaborated by Stanford University and Columbia University.",
    "db_schema": "/* Schema not available */",
    "ground_truth": "SELECT T1.title ,  T1.paper_id FROM Paper AS T1 JOIN Author_list AS T2 ON T1.paper_id  =  T2.paper_id JOIN Affiliation AS T3 ON T2.affiliation_id  =  T3.affiliation_id WHERE T3.name LIKE \"Stanford University\" INTERSECT SELECT T1.title ,  T1.paper_id FROM Paper AS T1 JOIN Author_list AS T2 ON T1.paper_id  =  T2.paper_id JOIN Affiliation AS T3 ON T2.affiliation_id  =  T3.affiliation_id WHERE T3.name LIKE \"Columbia University\"",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "3+ table JOINs",
    "difficulty": "Hard"
  },
  {
    "idx": 35,
    "query_type": "multi_join",
    "question": "Show the names of languages that are the official language for both countries with overall score greater than 95 and countries with overall score less than than 90.",
    "db_schema": "/* Schema not available */",
    "ground_truth": "SELECT T3.name FROM countries AS T1 JOIN official_languages AS T2 ON T1.id  =  T2.country_id JOIN languages AS T3 ON T2.language_id  =  T3.id WHERE T1.overall_score  >  95 INTERSECT SELECT T3.name FROM countries AS T1 JOIN official_languages AS T2 ON T1.id  =  T2.country_id JOIN languages AS T3 ON T2.language_id  =  T3.id WHERE T1.overall_score  <  90",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "3+ table JOINs",
    "difficulty": "Hard"
  },
  {
    "idx": 36,
    "query_type": "multi_join",
    "question": "List package number of package shipped in planet Omicron Persei 8 and sent by Zapp Brannigan.",
    "db_schema": "/* Schema not available */",
    "ground_truth": "SELECT T1.PackageNumber FROM PACKAGE AS T1 JOIN Client AS T2 ON  T1.Sender = T2.AccountNumber JOIN Shipment AS T3 ON T1.Shipment = T3.ShipmentID JOIN Planet AS T4 ON T3.Planet = T4.PlanetID WHERE T2.Name = \"Zapp Brannigan\" AND T4.Name = \"Omicron Persei 8\";",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "3+ table JOINs",
    "difficulty": "Medium"
  },
  {
    "idx": 37,
    "query_type": "multi_join",
    "question": "What is the first name of every student who has a dog but does not have a cat?",
    "db_schema": "Student(StuID number, LName text, Fname text, Age number, Sex text, Major number, Advisor number, city_code text; PRIMARY KEY(StuID))\nHas_Pet(StuID number, PetID number; FK(StuID REFERENCES Student(StuID)); FK(PetID REFERENCES Pets(PetID)))\nPets(PetID number, PetType text, pet_age number, weight number; PRIMARY KEY(PetID))",
    "ground_truth": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'dog' AND T1.stuid NOT IN (SELECT T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat')",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "3+ table JOINs",
    "difficulty": "Hard"
  },
  {
    "idx": 38,
    "query_type": "multi_join",
    "question": "What is the name of the visitor who visited both a museum opened before 2009 and a museum opened after 2011?",
    "db_schema": "museum(Museum_ID number, Name text, Num_of_Staff number, Open_Year text; PRIMARY KEY(Museum_ID))\nvisitor(ID number, Name text, Level_of_membership number, Age number; PRIMARY KEY(ID))\nvisit(Museum_ID number, visitor_ID text, Num_of_Ticket number, Total_spent number; PRIMARY KEY(Museum_ID); FK(Museum_ID REFERENCES museum(Museum_ID)); FK(visitor_ID REFERENCES visitor(ID)))",
    "ground_truth": "SELECT t1.name FROM visitor AS t1 JOIN visit AS t2 ON t1.id  =  t2.visitor_id JOIN museum AS t3 ON t3.Museum_ID  =  t2.Museum_ID WHERE t3.open_year  <  2009 INTERSECT SELECT t1.name FROM visitor AS t1 JOIN visit AS t2 ON t1.id  =  t2.visitor_id JOIN museum AS t3 ON t3.Museum_ID  =  t2.Museum_ID WHERE t3.open_year  >  2011",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "3+ table JOINs",
    "difficulty": "Hard"
  },
  {
    "idx": 39,
    "query_type": "multi_join",
    "question": "What was the growth rate of the total amount of loans across all accounts for a male client between 1996 and 1997?",
    "db_schema": "account(account_id integer, district_id integer, frequency text, date date; PRIMARY KEY(account_id); FK(district_id REFERENCES district(district_id)))\ncard(card_id integer, disp_id integer, type text, issued date; PRIMARY KEY(card_id); FK(disp_id REFERENCES disp(disp_id)))\nclient(client_id integer, gender text, birth_date date, district_id integer; PRIMARY KEY(client_id); FK(district_id REFERENCES district(district_id)))\ndisp(disp_id integer, client_id integer, account_id integer, type text; PRIMARY KEY(disp_id); FK(client_id REFERENCES client(client_id)); FK(account_id REFERENCES account(account_id)))\ndistrict(district_id integer, A2 text, A3 text, A4 text, A5 text, A6 text, A7 text, A8 integer, A9 integer, A10 real, A11 integer, A12 real, A13 real, A14 integer, A15 integer, A16 integer; PRIMARY KEY(district_id))\nloan(loan_id integer, account_id integer, date date, amount integer, duration integer, payments real, status text; PRIMARY KEY(loan_id); FK(account_id REFERENCES account(account_id)))\norder(order_id integer, account_id integer, bank_to text, account_to integer, amount real, k_symbol text; PRIMARY KEY(order_id); FK(account_id REFERENCES account(account_id)))\ntrans(trans_id integer, account_id integer, date date, type text, operation text, amount integer, balance integer, k_symbol text, bank text, account integer; PRIMARY KEY(trans_id); FK(account_id REFERENCES account(account_id)))",
    "ground_truth": "SELECT CAST((SUM(CASE WHEN STRFTIME('%Y', T1.date) = '1997' THEN T1.amount ELSE 0 END) - SUM(CASE WHEN STRFTIME('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END)) AS REAL) * 100 / SUM(CASE WHEN STRFTIME('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END) FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN disp AS T3 ON T3.account_id = T2.account_id INNER JOIN client AS T4 ON T4.client_id = T3.client_id WHERE T4.gender = 'M' AND T3.type = 'OWNER'",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "3+ table JOINs",
    "difficulty": "Hard"
  },
  {
    "idx": 40,
    "query_type": "multi_join",
    "question": "Which publisher published the slowest superhero?",
    "db_schema": "alignment(id integer, alignment text; PRIMARY KEY(id))\nattribute(id integer, attribute_name text; PRIMARY KEY(id))\ncolour(id integer, colour text; PRIMARY KEY(id))\ngender(id integer, gender text; PRIMARY KEY(id))\npublisher(id integer, publisher_name text; PRIMARY KEY(id))\nrace(id integer, race text; PRIMARY KEY(id))\nsuperhero(id integer, superhero_name text, full_name text, gender_id integer, eye_colour_id integer, hair_colour_id integer, skin_colour_id integer, race_id integer, publisher_id integer, alignment_id integer, height_cm integer, weight_kg integer; PRIMARY KEY(id); FK(gender_id REFERENCES gender(id)); FK(eye_colour_id REFERENCES colour(id)); FK(hair_colour_id REFERENCES colour(id)); FK(skin_colour_id REFERENCES colour(id)); FK(race_id REFERENCES race(id)); FK(publisher_id REFERENCES publisher(id)); FK(alignment_id REFERENCES alignment(id)))\nhero_attribute(hero_id integer, attribute_id integer, attribute_value integer; FK(hero_id REFERENCES superhero(id)); FK(attribute_id REFERENCES attribute(id)))\nsuperpower(id integer, power_name text; PRIMARY KEY(id))\nhero_power(hero_id integer, power_id integer; FK(hero_id REFERENCES superhero(id)); FK(power_id REFERENCES superpower(id)))",
    "ground_truth": "SELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN hero_attribute AS T3 ON T1.id = T3.hero_id INNER JOIN attribute AS T4 ON T3.attribute_id = T4.id WHERE T4.attribute_name = 'Speed' ORDER BY T3.attribute_value LIMIT 1",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "3+ table JOINs",
    "difficulty": "Hard"
  },
  {
    "idx": 41,
    "query_type": "anti_join",
    "question": "List the name of clubs that do not have players.",
    "db_schema": "/* Schema not available */",
    "ground_truth": "SELECT Name FROM club WHERE Club_ID NOT IN (SELECT Club_ID FROM player)",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "Anti-join (NOT EXISTS/NOT IN)",
    "difficulty": "Medium"
  },
  {
    "idx": 42,
    "query_type": "anti_join",
    "question": "Show all customer ids without an order.",
    "db_schema": "/* Schema not available */",
    "ground_truth": "SELECT customer_id FROM Customers EXCEPT SELECT customer_id FROM Customer_orders",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "Anti-join (NOT EXISTS/NOT IN)",
    "difficulty": "Medium"
  },
  {
    "idx": 43,
    "query_type": "anti_join",
    "question": "What are the names of clients who have never made an order?",
    "db_schema": "/* Schema not available */",
    "ground_truth": "SELECT name FROM Client EXCEPT SELECT T1.name FROM Client AS T1 JOIN Orders AS T2 ON T1.idClient  =  T2.idClient",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "Anti-join (NOT EXISTS/NOT IN)",
    "difficulty": "Medium"
  },
  {
    "idx": 44,
    "query_type": "anti_join",
    "question": "Which earpads never use plastic construction?",
    "db_schema": "/* Schema not available */",
    "ground_truth": "SELECT earpads FROM headphone EXCEPT SELECT earpads FROM headphone WHERE construction  =  'Plastic'",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "Anti-join (NOT EXISTS/NOT IN)",
    "difficulty": "Medium"
  },
  {
    "idx": 45,
    "query_type": "anti_join",
    "question": "What are the names of pilots who have flown Piper Cub but not the B-52 Bomber?",
    "db_schema": "/* Schema not available */",
    "ground_truth": "SELECT pilot_name FROM pilotskills WHERE plane_name  =  'Piper Cub' EXCEPT SELECT pilot_name FROM pilotskills WHERE plane_name  =  'B-52 Bomber'",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "Anti-join (NOT EXISTS/NOT IN)",
    "difficulty": "Medium"
  },
  {
    "idx": 46,
    "query_type": "anti_join",
    "question": "Find the countries where no driver come from.",
    "db_schema": "/* Schema not available */",
    "ground_truth": "SELECT country FROM country WHERE country_id NOT IN (SELECT country FROM driver)",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "Anti-join (NOT EXISTS/NOT IN)",
    "difficulty": "Medium"
  },
  {
    "idx": 47,
    "query_type": "anti_join",
    "question": "Which authors have never published under the \"Accor\" press? Give me their names.",
    "db_schema": "/* Schema not available */",
    "ground_truth": "SELECT name FROM author EXCEPT SELECT t1.name FROM author AS t1 JOIN book AS t2 ON t1.author_id  =  t2.author_id JOIN press AS t3 ON t2.press_id  =  t3.press_id WHERE t3.name  =  'Accor'",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "Anti-join (NOT EXISTS/NOT IN)",
    "difficulty": "Medium"
  },
  {
    "idx": 48,
    "query_type": "anti_join",
    "question": "Find all airlines that have flights from airport 'CVO' but not from 'APG'.",
    "db_schema": "airlines(uid number, Airline text, Abbreviation text, Country text; PRIMARY KEY(uid))\nairports(City text, AirportCode text, AirportName text, Country text, CountryAbbrev text; PRIMARY KEY(AirportCode))\nflights(Airline number, FlightNo number, SourceAirport text, DestAirport text; PRIMARY KEY(Airline); FK(SourceAirport REFERENCES airports(AirportCode)); FK(DestAirport REFERENCES airports(AirportCode)))",
    "ground_truth": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"CVO\" EXCEPT SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"APG\"",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "Anti-join (NOT EXISTS/NOT IN)",
    "difficulty": "Hard"
  },
  {
    "idx": 49,
    "query_type": "anti_join",
    "question": "What are the countries that are not playing cartoons written by Todd Casey?",
    "db_schema": "TV_Channel(id text, series_name text, Country text, Language text, Content text, Pixel_aspect_ratio_PAR text, Hight_definition_TV text, Pay_per_view_PPV text, Package_Option text; PRIMARY KEY(id))\nTV_series(id number, Episode text, Air_Date text, Rating text, Share number, 18_49_Rating_Share text, Viewers_m text, Weekly_Rank number, Channel text; PRIMARY KEY(id); FK(Channel REFERENCES TV_Channel(id)))\nCartoon(id number, Title text, Directed_by text, Written_by text, Original_air_date text, Production_code number, Channel text; PRIMARY KEY(id); FK(Channel REFERENCES TV_Channel(id)))",
    "ground_truth": "SELECT country FROM TV_Channel EXCEPT SELECT T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.written_by  =  'Todd Casey'",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "Anti-join (NOT EXISTS/NOT IN)",
    "difficulty": "Hard"
  },
  {
    "idx": 50,
    "query_type": "anti_join",
    "question": "What are the names of students who have no friends?",
    "db_schema": "Highschooler(ID number, name text, grade number; PRIMARY KEY(ID))\nFriend(student_id number, friend_id number; PRIMARY KEY(student_id); FK(student_id REFERENCES Highschooler(ID)); FK(friend_id REFERENCES Highschooler(ID)))\nLikes(student_id number, liked_id number; PRIMARY KEY(student_id); FK(student_id REFERENCES Highschooler(ID)); FK(liked_id REFERENCES Highschooler(ID)))",
    "ground_truth": "SELECT name FROM Highschooler EXCEPT SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "Anti-join (NOT EXISTS/NOT IN)",
    "difficulty": "Medium"
  },
  {
    "idx": 51,
    "query_type": "date_time_aggregation",
    "question": "List the dates of the orders which were placed at the earliest time or have more than 1 items.",
    "db_schema": "/* Schema not available */",
    "ground_truth": "SELECT min(date_order_placed) FROM Orders UNION SELECT T1.date_order_placed FROM Orders AS T1 JOIN Order_items AS T2 ON T1.order_id  =  T2.order_id GROUP BY T1.order_id HAVING count(*)  >  1",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "Aggregation with dates/time",
    "difficulty": "Hard"
  },
  {
    "idx": 52,
    "query_type": "date_time_aggregation",
    "question": "Count the number of papers published by Columbia University in 2009.",
    "db_schema": "/* Schema not available */",
    "ground_truth": "SELECT count(DISTINCT T1.paper_id) FROM Paper AS T1 JOIN Author_list AS T2 ON T1.paper_id  =  T2.paper_id JOIN Affiliation AS T3 ON T2.affiliation_id  =  T3.affiliation_id WHERE T3.name LIKE \"Columbia University\" AND T1.year  =  2009",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "Aggregation with dates/time",
    "difficulty": "Medium"
  },
  {
    "idx": 53,
    "query_type": "date_time_aggregation",
    "question": "What are the maximum height and width of paintings for each year?",
    "db_schema": "/* Schema not available */",
    "ground_truth": "SELECT max(height_mm) ,  max(width_mm) ,  YEAR FROM paintings GROUP BY YEAR ORDER BY YEAR",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "Aggregation with dates/time",
    "difficulty": "Easy"
  },
  {
    "idx": 54,
    "query_type": "date_time_aggregation",
    "question": "Show the stadium name and capacity with most number of concerts in year 2014 or after.",
    "db_schema": "stadium(Stadium_ID number, Location text, Name text, Capacity number, Highest number, Lowest number, Average number; PRIMARY KEY(Stadium_ID))\nsinger(Singer_ID number, Name text, Country text, Song_Name text, Song_release_year text, Age number, Is_male others; PRIMARY KEY(Singer_ID))\nconcert(concert_ID number, concert_Name text, Theme text, Stadium_ID text, Year text; PRIMARY KEY(concert_ID); FK(Stadium_ID REFERENCES stadium(Stadium_ID)))\nsinger_in_concert(concert_ID number, Singer_ID text; PRIMARY KEY(concert_ID); FK(concert_ID REFERENCES concert(concert_ID)); FK(Singer_ID REFERENCES singer(Singer_ID)))",
    "ground_truth": "SELECT T2.name ,  T2.capacity FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id WHERE T1.year  >=  2014 GROUP BY T2.stadium_id ORDER BY count(*) DESC LIMIT 1",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "Aggregation with dates/time",
    "difficulty": "Medium"
  },
  {
    "idx": 55,
    "query_type": "date_time_aggregation",
    "question": "What is the date and id of the transcript with at least 2 courses listed?",
    "db_schema": "Addresses(address_id number, line_1 text, line_2 text, line_3 text, city text, zip_postcode text, state_province_county text, country text, other_address_details text; PRIMARY KEY(address_id))\nCourses(course_id number, course_name text, course_description text, other_details text; PRIMARY KEY(course_id))\nDepartments(department_id number, department_name text, department_description text, other_details text; PRIMARY KEY(department_id))\nDegree_Programs(degree_program_id number, department_id number, degree_summary_name text, degree_summary_description text, other_details text; PRIMARY KEY(degree_program_id); FK(department_id REFERENCES Departments(department_id)))\nSections(section_id number, course_id number, section_name text, section_description text, other_details text; PRIMARY KEY(section_id); FK(course_id REFERENCES Courses(course_id)))\nSemesters(semester_id number, semester_name text, semester_description text, other_details text; PRIMARY KEY(semester_id))\nStudents(student_id number, current_address_id number, permanent_address_id number, first_name text, middle_name text, last_name text, cell_mobile_number text, email_address text, ssn text, date_first_registered time, date_left time, other_student_details text; PRIMARY KEY(student_id); FK(current_address_id REFERENCES Addresses(address_id)); FK(permanent_address_id REFERENCES Addresses(address_id)))\nStudent_Enrolment(student_enrolment_id number, degree_program_id number, semester_id number, student_id number, other_details text; PRIMARY KEY(student_enrolment_id); FK(degree_program_id REFERENCES Degree_Programs(degree_program_id)); FK(semester_id REFERENCES Semesters(semester_id)); FK(student_id REFERENCES Students(student_id)))\nStudent_Enrolment_Courses(student_course_id number, course_id number, student_enrolment_id number; PRIMARY KEY(student_course_id); FK(course_id REFERENCES Courses(course_id)); FK(student_enrolment_id REFERENCES Student_Enrolment(student_enrolment_id)))\nTranscripts(transcript_id number, transcript_date time, other_details text; PRIMARY KEY(transcript_id))\nTranscript_Contents(student_course_id number, transcript_id number; FK(student_course_id REFERENCES Student_Enrolment_Courses(student_course_id)); FK(transcript_id REFERENCES Transcripts(transcript_id)))",
    "ground_truth": "SELECT T2.transcript_date ,  T1.transcript_id FROM Transcript_Contents AS T1 JOIN Transcripts AS T2 ON T1.transcript_id  =  T2.transcript_id GROUP BY T1.transcript_id HAVING count(*)  >=  2",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "Aggregation with dates/time",
    "difficulty": "Hard"
  },
  {
    "idx": 56,
    "query_type": "date_time_aggregation",
    "question": "How many credit card withdrawals were recorded after 1995?",
    "db_schema": "account(account_id integer, district_id integer, frequency text, date date; PRIMARY KEY(account_id); FK(district_id REFERENCES district(district_id)))\ncard(card_id integer, disp_id integer, type text, issued date; PRIMARY KEY(card_id); FK(disp_id REFERENCES disp(disp_id)))\nclient(client_id integer, gender text, birth_date date, district_id integer; PRIMARY KEY(client_id); FK(district_id REFERENCES district(district_id)))\ndisp(disp_id integer, client_id integer, account_id integer, type text; PRIMARY KEY(disp_id); FK(client_id REFERENCES client(client_id)); FK(account_id REFERENCES account(account_id)))\ndistrict(district_id integer, A2 text, A3 text, A4 text, A5 text, A6 text, A7 text, A8 integer, A9 integer, A10 real, A11 integer, A12 real, A13 real, A14 integer, A15 integer, A16 integer; PRIMARY KEY(district_id))\nloan(loan_id integer, account_id integer, date date, amount integer, duration integer, payments real, status text; PRIMARY KEY(loan_id); FK(account_id REFERENCES account(account_id)))\norder(order_id integer, account_id integer, bank_to text, account_to integer, amount real, k_symbol text; PRIMARY KEY(order_id); FK(account_id REFERENCES account(account_id)))\ntrans(trans_id integer, account_id integer, date date, type text, operation text, amount integer, balance integer, k_symbol text, bank text, account integer; PRIMARY KEY(trans_id); FK(account_id REFERENCES account(account_id)))",
    "ground_truth": "SELECT COUNT(account_id) FROM trans WHERE STRFTIME('%Y', date) > '1995' AND operation = 'VYBER KARTOU'",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "Aggregation with dates/time",
    "difficulty": "Medium"
  },
  {
    "idx": 57,
    "query_type": "date_time_aggregation",
    "question": "For the drivers who took part in the race in 1983/7/16, what's their race completion rate?",
    "db_schema": "circuits(circuitId integer, circuitRef text, name text, location text, country text, lat real, lng real, alt integer, url text; PRIMARY KEY(circuitId))\nconstructors(constructorId integer, constructorRef text, name text, nationality text, url text; PRIMARY KEY(constructorId))\ndrivers(driverId integer, driverRef text, number integer, code text, forename text, surname text, dob date, nationality text, url text; PRIMARY KEY(driverId))\nseasons(year integer, url text; PRIMARY KEY(year))\nraces(raceId integer, year integer, round integer, circuitId integer, name text, date date, time text, url text; PRIMARY KEY(raceId); FK(year REFERENCES seasons(year)); FK(circuitId REFERENCES circuits(circuitId)))\nconstructorResults(constructorResultsId integer, raceId integer, constructorId integer, points real, status text; PRIMARY KEY(constructorResultsId); FK(raceId REFERENCES races(raceId)); FK(constructorId REFERENCES constructors(constructorId)))\nconstructorStandings(constructorStandingsId integer, raceId integer, constructorId integer, points real, position integer, positionText text, wins integer; PRIMARY KEY(constructorStandingsId); FK(raceId REFERENCES races(raceId)); FK(constructorId REFERENCES constructors(constructorId)))\ndriverStandings(driverStandingsId integer, raceId integer, driverId integer, points real, position integer, positionText text, wins integer; PRIMARY KEY(driverStandingsId); FK(raceId REFERENCES races(raceId)); FK(driverId REFERENCES drivers(driverId)))\nlapTimes(raceId integer, driverId integer, lap integer, position integer, time text, milliseconds integer; FK(raceId REFERENCES races(raceId)); FK(driverId REFERENCES drivers(driverId)))\npitStops(raceId integer, driverId integer, stop integer, lap integer, time text, duration text, milliseconds integer; FK(raceId REFERENCES races(raceId)); FK(driverId REFERENCES drivers(driverId)))\nqualifying(qualifyId integer, raceId integer, driverId integer, constructorId integer, number integer, position integer, q1 text, q2 text, q3 text; PRIMARY KEY(qualifyId); FK(raceId REFERENCES races(raceId)); FK(driverId REFERENCES drivers(driverId)); FK(constructorId REFERENCES constructors(constructorId)))\nstatus(statusId integer, status text; PRIMARY KEY(statusId))\nresults(resultId integer, raceId integer, driverId integer, constructorId integer, number integer, grid integer, position integer, positionText text, positionOrder integer, points real, laps integer, time text, milliseconds integer, fastestLap integer, rank integer, fastestLapTime text, fastestLapSpeed text, statusId integer; PRIMARY KEY(resultId); FK(raceId REFERENCES races(raceId)); FK(driverId REFERENCES drivers(driverId)); FK(constructorId REFERENCES constructors(constructorId)); FK(statusId REFERENCES status(statusId)))",
    "ground_truth": "SELECT CAST(COUNT(CASE WHEN T2.time IS NOT NULL THEN T2.driverId END) AS REAL) * 100 / COUNT(T2.driverId) FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.date = '1983-07-16'",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "Aggregation with dates/time",
    "difficulty": "Hard"
  },
  {
    "idx": 58,
    "query_type": "date_time_aggregation",
    "question": "Please list the lap records for the circuits in Italy.",
    "db_schema": "circuits(circuitId integer, circuitRef text, name text, location text, country text, lat real, lng real, alt integer, url text; PRIMARY KEY(circuitId))\nconstructors(constructorId integer, constructorRef text, name text, nationality text, url text; PRIMARY KEY(constructorId))\ndrivers(driverId integer, driverRef text, number integer, code text, forename text, surname text, dob date, nationality text, url text; PRIMARY KEY(driverId))\nseasons(year integer, url text; PRIMARY KEY(year))\nraces(raceId integer, year integer, round integer, circuitId integer, name text, date date, time text, url text; PRIMARY KEY(raceId); FK(year REFERENCES seasons(year)); FK(circuitId REFERENCES circuits(circuitId)))\nconstructorResults(constructorResultsId integer, raceId integer, constructorId integer, points real, status text; PRIMARY KEY(constructorResultsId); FK(raceId REFERENCES races(raceId)); FK(constructorId REFERENCES constructors(constructorId)))\nconstructorStandings(constructorStandingsId integer, raceId integer, constructorId integer, points real, position integer, positionText text, wins integer; PRIMARY KEY(constructorStandingsId); FK(raceId REFERENCES races(raceId)); FK(constructorId REFERENCES constructors(constructorId)))\ndriverStandings(driverStandingsId integer, raceId integer, driverId integer, points real, position integer, positionText text, wins integer; PRIMARY KEY(driverStandingsId); FK(raceId REFERENCES races(raceId)); FK(driverId REFERENCES drivers(driverId)))\nlapTimes(raceId integer, driverId integer, lap integer, position integer, time text, milliseconds integer; FK(raceId REFERENCES races(raceId)); FK(driverId REFERENCES drivers(driverId)))\npitStops(raceId integer, driverId integer, stop integer, lap integer, time text, duration text, milliseconds integer; FK(raceId REFERENCES races(raceId)); FK(driverId REFERENCES drivers(driverId)))\nqualifying(qualifyId integer, raceId integer, driverId integer, constructorId integer, number integer, position integer, q1 text, q2 text, q3 text; PRIMARY KEY(qualifyId); FK(raceId REFERENCES races(raceId)); FK(driverId REFERENCES drivers(driverId)); FK(constructorId REFERENCES constructors(constructorId)))\nstatus(statusId integer, status text; PRIMARY KEY(statusId))\nresults(resultId integer, raceId integer, driverId integer, constructorId integer, number integer, grid integer, position integer, positionText text, positionOrder integer, points real, laps integer, time text, milliseconds integer, fastestLap integer, rank integer, fastestLapTime text, fastestLapSpeed text, statusId integer; PRIMARY KEY(resultId); FK(raceId REFERENCES races(raceId)); FK(driverId REFERENCES drivers(driverId)); FK(constructorId REFERENCES constructors(constructorId)); FK(statusId REFERENCES status(statusId)))",
    "ground_truth": "WITH fastest_lap_times AS (SELECT T1.raceId, T1.FastestLapTime, (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) as time_in_seconds FROM results AS T1 WHERE T1.FastestLapTime IS NOT NULL ) SELECT T1.FastestLapTime as lap_record FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId INNER JOIN (SELECT MIN(fastest_lap_times.time_in_seconds) as min_time_in_seconds FROM fastest_lap_times INNER JOIN races AS T2 on fastest_lap_times.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId WHERE T3.country = 'Italy' ) AS T4 ON (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) = T4.min_time_in_seconds LIMIT 1",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "Aggregation with dates/time",
    "difficulty": "Hard"
  },
  {
    "idx": 59,
    "query_type": "date_time_aggregation",
    "question": "What is the most common illness that doctors identified among the patients whose lab work was done between 1/1/1985, and 12/31/1995?",
    "db_schema": "Examination(ID integer, Examination Date date, aCL IgG real, aCL IgM real, ANA integer, ANA Pattern text, aCL IgA integer, Diagnosis text, KCT text, RVVT text, LAC text, Symptoms text, Thrombosis integer; FK(ID REFERENCES Patient(ID)))\nPatient(ID integer, SEX text, Birthday date, Description date, First Date date, Admission text, Diagnosis text; PRIMARY KEY(ID))\nLaboratory(ID integer, Date date, GOT integer, GPT integer, LDH integer, ALP integer, TP real, ALB real, UA real, UN integer, CRE real, T-BIL real, T-CHO integer, TG integer, CPK integer, GLU integer, WBC real, RBC real, HGB real, HCT real, PLT integer, PT real, APTT integer, FG real, PIC integer, TAT integer, TAT2 integer, U-PRO text, IGG integer, IGA integer, IGM integer, CRP text, RA text, RF text, C3 integer, C4 integer, RNP text, SM text, SC170 text, SSA text, SSB text, CENTROMEA text, DNA text, DNA-II integer; FK(ID REFERENCES Patient(ID)))",
    "ground_truth": "SELECT T2.Diagnosis FROM Examination AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T1.`Examination Date` BETWEEN '1985-01-01' AND '1995-12-31' GROUP BY T2.Diagnosis ORDER BY COUNT(T2.Diagnosis) DESC LIMIT 1",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "Aggregation with dates/time",
    "difficulty": "Medium"
  },
  {
    "idx": 60,
    "query_type": "date_time_aggregation",
    "question": "How many members did attend the event 'Community Theater' in 2019?",
    "db_schema": "event(event_id text, event_name text, event_date text, type text, notes text, location text, status text; PRIMARY KEY(event_id))\nmajor(major_id text, major_name text, department text, college text; PRIMARY KEY(major_id))\nzip_code(zip_code integer, type text, city text, county text, state text, short_state text; PRIMARY KEY(zip_code))\nattendance(link_to_event text, link_to_member text; FK(link_to_event REFERENCES event(event_id)); FK(link_to_member REFERENCES member(member_id)))\nbudget(budget_id text, category text, spent real, remaining real, amount integer, event_status text, link_to_event text; PRIMARY KEY(budget_id); FK(link_to_event REFERENCES event(event_id)))\nexpense(expense_id text, expense_description text, expense_date text, cost real, approved text, link_to_member text, link_to_budget text; PRIMARY KEY(expense_id); FK(link_to_member REFERENCES member(member_id)); FK(link_to_budget REFERENCES budget(budget_id)))\nincome(income_id text, date_received text, amount integer, source text, notes text, link_to_member text; PRIMARY KEY(income_id); FK(link_to_member REFERENCES member(member_id)))\nmember(member_id text, first_name text, last_name text, email text, position text, t_shirt_size text, phone text, zip integer, link_to_major text; PRIMARY KEY(member_id); FK(zip REFERENCES zip_code(zip_code)); FK(link_to_major REFERENCES major(major_id)))",
    "ground_truth": "SELECT COUNT(T2.link_to_member) FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'Community Theater' AND SUBSTR(T1.event_date, 1, 4) = '2019'",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "Aggregation with dates/time",
    "difficulty": "Medium"
  },
  {
    "idx": 61,
    "query_type": "projection_case",
    "question": "What is the ratio of merged Unified School District schools in Orange County to merged Elementary School District schools?",
    "db_schema": "frpm(CDSCode text, Academic Year text, County Code text, District Code integer, School Code text, County Name text, District Name text, School Name text, District Type text, School Type text, Educational Option Type text, NSLP Provision Status text, Charter School (Y/N) integer, Charter School Number text, Charter Funding Type text, IRC integer, Low Grade text, High Grade text, Enrollment (K-12) real, Free Meal Count (K-12) real, Percent (%) Eligible Free (K-12) real, FRPM Count (K-12) real, Percent (%) Eligible FRPM (K-12) real, Enrollment (Ages 5-17) real, Free Meal Count (Ages 5-17) real, Percent (%) Eligible Free (Ages 5-17) real, FRPM Count (Ages 5-17) real, Percent (%) Eligible FRPM (Ages 5-17) real, 2013-14 CALPADS Fall 1 Certification Status integer; PRIMARY KEY(CDSCode); FK(CDSCode REFERENCES schools(CDSCode)))\nsatscores(cds text, rtype text, sname text, dname text, cname text, enroll12 integer, NumTstTakr integer, AvgScrRead integer, AvgScrMath integer, AvgScrWrite integer, NumGE1500 integer; PRIMARY KEY(cds); FK(cds REFERENCES schools(CDSCode)))\nschools(CDSCode text, NCESDist text, NCESSchool text, StatusType text, County text, District text, School text, Street text, StreetAbr text, City text, Zip text, State text, MailStreet text, MailStrAbr text, MailCity text, MailZip text, MailState text, Phone text, Ext text, Website text, OpenDate date, ClosedDate date, Charter integer, CharterNum text, FundingType text, DOC text, DOCType text, SOC text, SOCType text, EdOpsCode text, EdOpsName text, EILCode text, EILName text, GSoffered text, GSserved text, Virtual text, Magnet integer, Latitude real, Longitude real, AdmFName1 text, AdmLName1 text, AdmEmail1 text, AdmFName2 text, AdmLName2 text, AdmEmail2 text, AdmFName3 text, AdmLName3 text, AdmEmail3 text, LastUpdate date; PRIMARY KEY(CDSCode))",
    "ground_truth": "SELECT CAST(SUM(CASE WHEN DOC = 54 THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN DOC = 52 THEN 1 ELSE 0 END) FROM schools WHERE StatusType = 'Merged' AND County = 'Orange'",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "projection_case",
    "difficulty": "Medium"
  },
  {
    "idx": 62,
    "query_type": "projection_case",
    "question": "What percentage of carcinogenic-type molecules does not contain fluorine?",
    "db_schema": "atom(atom_id text, molecule_id text, element text; PRIMARY KEY(atom_id); FK(molecule_id REFERENCES molecule(molecule_id)))\nbond(bond_id text, molecule_id text, bond_type text; PRIMARY KEY(bond_id); FK(molecule_id REFERENCES molecule(molecule_id)))\nconnected(atom_id text, atom_id2 text, bond_id text; FK(atom_id REFERENCES atom(atom_id)); FK(atom_id2 REFERENCES atom(atom_id)); FK(bond_id REFERENCES bond(bond_id)))\nmolecule(molecule_id text, label text; PRIMARY KEY(molecule_id))",
    "ground_truth": "SELECT CAST(COUNT(DISTINCT CASE WHEN T1.element <> 'f' THEN T2.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "projection_case",
    "difficulty": "Hard"
  },
  {
    "idx": 63,
    "query_type": "projection_case",
    "question": "What is the composition of element chlorine in percentage among the single bond molecules?",
    "db_schema": "atom(atom_id text, molecule_id text, element text; PRIMARY KEY(atom_id); FK(molecule_id REFERENCES molecule(molecule_id)))\nbond(bond_id text, molecule_id text, bond_type text; PRIMARY KEY(bond_id); FK(molecule_id REFERENCES molecule(molecule_id)))\nconnected(atom_id text, atom_id2 text, bond_id text; FK(atom_id REFERENCES atom(atom_id)); FK(atom_id2 REFERENCES atom(atom_id)); FK(bond_id REFERENCES bond(bond_id)))\nmolecule(molecule_id text, label text; PRIMARY KEY(molecule_id))",
    "ground_truth": "SELECT CAST(COUNT(CASE WHEN T.element = 'cl' THEN T.atom_id ELSE NULL END) AS REAL) * 100 / COUNT(T.atom_id) FROM ( SELECT T1.atom_id, T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '-' ) AS T",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "projection_case",
    "difficulty": "Hard"
  },
  {
    "idx": 64,
    "query_type": "projection_case",
    "question": "Calculate the percentage of carcinogenic molecules which contain the Chlorine element.",
    "db_schema": "atom(atom_id text, molecule_id text, element text; PRIMARY KEY(atom_id); FK(molecule_id REFERENCES molecule(molecule_id)))\nbond(bond_id text, molecule_id text, bond_type text; PRIMARY KEY(bond_id); FK(molecule_id REFERENCES molecule(molecule_id)))\nconnected(atom_id text, atom_id2 text, bond_id text; FK(atom_id REFERENCES atom(atom_id)); FK(atom_id2 REFERENCES atom(atom_id)); FK(bond_id REFERENCES bond(bond_id)))\nmolecule(molecule_id text, label text; PRIMARY KEY(molecule_id))",
    "ground_truth": "SELECT COUNT(CASE WHEN T2.label = '+' AND T1.element = 'cl' THEN T2.molecule_id ELSE NULL END) * 100 / COUNT(T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "projection_case",
    "difficulty": "Hard"
  },
  {
    "idx": 65,
    "query_type": "projection_case",
    "question": "What is the percentage of Story Spotlight cards that do not have a text box? List them by their ID.",
    "db_schema": "cards(id integer, artist text, asciiName text, availability text, borderColor text, cardKingdomFoilId text, cardKingdomId text, colorIdentity text, colorIndicator text, colors text, convertedManaCost real, duelDeck text, edhrecRank integer, faceConvertedManaCost real, faceName text, flavorName text, flavorText text, frameEffects text, frameVersion text, hand text, hasAlternativeDeckLimit integer, hasContentWarning integer, hasFoil integer, hasNonFoil integer, isAlternative integer, isFullArt integer, isOnlineOnly integer, isOversized integer, isPromo integer, isReprint integer, isReserved integer, isStarter integer, isStorySpotlight integer, isTextless integer, isTimeshifted integer, keywords text, layout text, leadershipSkills text, life text, loyalty text, manaCost text, mcmId text, mcmMetaId text, mtgArenaId text, mtgjsonV4Id text, mtgoFoilId text, mtgoId text, multiverseId text, name text, number text, originalReleaseDate text, originalText text, originalType text, otherFaceIds text, power text, printings text, promoTypes text, purchaseUrls text, rarity text, scryfallId text, scryfallIllustrationId text, scryfallOracleId text, setCode text, side text, subtypes text, supertypes text, tcgplayerProductId text, text text, toughness text, type text, types text, uuid text, variations text, watermark text; PRIMARY KEY(id))\nforeign_data(id integer, flavorText text, language text, multiverseid integer, name text, text text, type text, uuid text; PRIMARY KEY(id); FK(uuid REFERENCES cards(uuid)))\nlegalities(id integer, format text, status text, uuid text; PRIMARY KEY(id); FK(uuid REFERENCES cards(uuid)))\nsets(id integer, baseSetSize integer, block text, booster text, code text, isFoilOnly integer, isForeignOnly integer, isNonFoilOnly integer, isOnlineOnly integer, isPartialPreview integer, keyruneCode text, mcmId integer, mcmIdExtras integer, mcmName text, mtgoCode text, name text, parentCode text, releaseDate date, tcgplayerGroupId integer, totalSetSize integer, type text; PRIMARY KEY(id))\nset_translations(id integer, language text, setCode text, translation text; PRIMARY KEY(id); FK(setCode REFERENCES sets(code)))\nrulings(id integer, date date, text text, uuid text; PRIMARY KEY(id); FK(uuid REFERENCES cards(uuid)))",
    "ground_truth": "SELECT CAST(SUM(CASE WHEN isTextless = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM cards WHERE isStorySpotlight = 1",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "projection_case",
    "difficulty": "Hard"
  },
  {
    "idx": 66,
    "query_type": "projection_case",
    "question": "What is percentage of the cards with a converted Mana Cost of 10 in set of Abyssal Horror?",
    "db_schema": "cards(id integer, artist text, asciiName text, availability text, borderColor text, cardKingdomFoilId text, cardKingdomId text, colorIdentity text, colorIndicator text, colors text, convertedManaCost real, duelDeck text, edhrecRank integer, faceConvertedManaCost real, faceName text, flavorName text, flavorText text, frameEffects text, frameVersion text, hand text, hasAlternativeDeckLimit integer, hasContentWarning integer, hasFoil integer, hasNonFoil integer, isAlternative integer, isFullArt integer, isOnlineOnly integer, isOversized integer, isPromo integer, isReprint integer, isReserved integer, isStarter integer, isStorySpotlight integer, isTextless integer, isTimeshifted integer, keywords text, layout text, leadershipSkills text, life text, loyalty text, manaCost text, mcmId text, mcmMetaId text, mtgArenaId text, mtgjsonV4Id text, mtgoFoilId text, mtgoId text, multiverseId text, name text, number text, originalReleaseDate text, originalText text, originalType text, otherFaceIds text, power text, printings text, promoTypes text, purchaseUrls text, rarity text, scryfallId text, scryfallIllustrationId text, scryfallOracleId text, setCode text, side text, subtypes text, supertypes text, tcgplayerProductId text, text text, toughness text, type text, types text, uuid text, variations text, watermark text; PRIMARY KEY(id))\nforeign_data(id integer, flavorText text, language text, multiverseid integer, name text, text text, type text, uuid text; PRIMARY KEY(id); FK(uuid REFERENCES cards(uuid)))\nlegalities(id integer, format text, status text, uuid text; PRIMARY KEY(id); FK(uuid REFERENCES cards(uuid)))\nsets(id integer, baseSetSize integer, block text, booster text, code text, isFoilOnly integer, isForeignOnly integer, isNonFoilOnly integer, isOnlineOnly integer, isPartialPreview integer, keyruneCode text, mcmId integer, mcmIdExtras integer, mcmName text, mtgoCode text, name text, parentCode text, releaseDate date, tcgplayerGroupId integer, totalSetSize integer, type text; PRIMARY KEY(id))\nset_translations(id integer, language text, setCode text, translation text; PRIMARY KEY(id); FK(setCode REFERENCES sets(code)))\nrulings(id integer, date date, text text, uuid text; PRIMARY KEY(id); FK(uuid REFERENCES cards(uuid)))",
    "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.convertedManaCost = 10 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id), T1.name FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Abyssal Horror'",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "projection_case",
    "difficulty": "Hard"
  },
  {
    "idx": 67,
    "query_type": "projection_case",
    "question": "Among the cards with converted mana cost higher than 5 in the set Coldsnap, how many of them have unknown power?",
    "db_schema": "cards(id integer, artist text, asciiName text, availability text, borderColor text, cardKingdomFoilId text, cardKingdomId text, colorIdentity text, colorIndicator text, colors text, convertedManaCost real, duelDeck text, edhrecRank integer, faceConvertedManaCost real, faceName text, flavorName text, flavorText text, frameEffects text, frameVersion text, hand text, hasAlternativeDeckLimit integer, hasContentWarning integer, hasFoil integer, hasNonFoil integer, isAlternative integer, isFullArt integer, isOnlineOnly integer, isOversized integer, isPromo integer, isReprint integer, isReserved integer, isStarter integer, isStorySpotlight integer, isTextless integer, isTimeshifted integer, keywords text, layout text, leadershipSkills text, life text, loyalty text, manaCost text, mcmId text, mcmMetaId text, mtgArenaId text, mtgjsonV4Id text, mtgoFoilId text, mtgoId text, multiverseId text, name text, number text, originalReleaseDate text, originalText text, originalType text, otherFaceIds text, power text, printings text, promoTypes text, purchaseUrls text, rarity text, scryfallId text, scryfallIllustrationId text, scryfallOracleId text, setCode text, side text, subtypes text, supertypes text, tcgplayerProductId text, text text, toughness text, type text, types text, uuid text, variations text, watermark text; PRIMARY KEY(id))\nforeign_data(id integer, flavorText text, language text, multiverseid integer, name text, text text, type text, uuid text; PRIMARY KEY(id); FK(uuid REFERENCES cards(uuid)))\nlegalities(id integer, format text, status text, uuid text; PRIMARY KEY(id); FK(uuid REFERENCES cards(uuid)))\nsets(id integer, baseSetSize integer, block text, booster text, code text, isFoilOnly integer, isForeignOnly integer, isNonFoilOnly integer, isOnlineOnly integer, isPartialPreview integer, keyruneCode text, mcmId integer, mcmIdExtras integer, mcmName text, mtgoCode text, name text, parentCode text, releaseDate date, tcgplayerGroupId integer, totalSetSize integer, type text; PRIMARY KEY(id))\nset_translations(id integer, language text, setCode text, translation text; PRIMARY KEY(id); FK(setCode REFERENCES sets(code)))\nrulings(id integer, date date, text text, uuid text; PRIMARY KEY(id); FK(uuid REFERENCES cards(uuid)))",
    "ground_truth": "SELECT SUM(CASE WHEN T1.power LIKE '*' OR T1.power IS NULL THEN 1 ELSE 0 END) FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap' AND T1.convertedManaCost > 5",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "projection_case",
    "difficulty": "Hard"
  },
  {
    "idx": 68,
    "query_type": "projection_case",
    "question": "List the names of all the cards in the set Hour of Devastation and find the formats in which these cards are legal.",
    "db_schema": "cards(id integer, artist text, asciiName text, availability text, borderColor text, cardKingdomFoilId text, cardKingdomId text, colorIdentity text, colorIndicator text, colors text, convertedManaCost real, duelDeck text, edhrecRank integer, faceConvertedManaCost real, faceName text, flavorName text, flavorText text, frameEffects text, frameVersion text, hand text, hasAlternativeDeckLimit integer, hasContentWarning integer, hasFoil integer, hasNonFoil integer, isAlternative integer, isFullArt integer, isOnlineOnly integer, isOversized integer, isPromo integer, isReprint integer, isReserved integer, isStarter integer, isStorySpotlight integer, isTextless integer, isTimeshifted integer, keywords text, layout text, leadershipSkills text, life text, loyalty text, manaCost text, mcmId text, mcmMetaId text, mtgArenaId text, mtgjsonV4Id text, mtgoFoilId text, mtgoId text, multiverseId text, name text, number text, originalReleaseDate text, originalText text, originalType text, otherFaceIds text, power text, printings text, promoTypes text, purchaseUrls text, rarity text, scryfallId text, scryfallIllustrationId text, scryfallOracleId text, setCode text, side text, subtypes text, supertypes text, tcgplayerProductId text, text text, toughness text, type text, types text, uuid text, variations text, watermark text; PRIMARY KEY(id))\nforeign_data(id integer, flavorText text, language text, multiverseid integer, name text, text text, type text, uuid text; PRIMARY KEY(id); FK(uuid REFERENCES cards(uuid)))\nlegalities(id integer, format text, status text, uuid text; PRIMARY KEY(id); FK(uuid REFERENCES cards(uuid)))\nsets(id integer, baseSetSize integer, block text, booster text, code text, isFoilOnly integer, isForeignOnly integer, isNonFoilOnly integer, isOnlineOnly integer, isPartialPreview integer, keyruneCode text, mcmId integer, mcmIdExtras integer, mcmName text, mtgoCode text, name text, parentCode text, releaseDate date, tcgplayerGroupId integer, totalSetSize integer, type text; PRIMARY KEY(id))\nset_translations(id integer, language text, setCode text, translation text; PRIMARY KEY(id); FK(setCode REFERENCES sets(code)))\nrulings(id integer, date date, text text, uuid text; PRIMARY KEY(id); FK(uuid REFERENCES cards(uuid)))",
    "ground_truth": "SELECT DISTINCT T2.name , CASE WHEN T1.status = 'Legal' THEN T1.format ELSE NULL END FROM legalities AS T1 INNER JOIN cards AS T2 ON T2.uuid = T1.uuid WHERE T2.setCode IN ( SELECT code FROM sets WHERE name = 'Hour of Devastation' )",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "projection_case",
    "difficulty": "Hard"
  },
  {
    "idx": 69,
    "query_type": "projection_case",
    "question": "How many percent of female heroes were published by Marvel Comics?",
    "db_schema": "alignment(id integer, alignment text; PRIMARY KEY(id))\nattribute(id integer, attribute_name text; PRIMARY KEY(id))\ncolour(id integer, colour text; PRIMARY KEY(id))\ngender(id integer, gender text; PRIMARY KEY(id))\npublisher(id integer, publisher_name text; PRIMARY KEY(id))\nrace(id integer, race text; PRIMARY KEY(id))\nsuperhero(id integer, superhero_name text, full_name text, gender_id integer, eye_colour_id integer, hair_colour_id integer, skin_colour_id integer, race_id integer, publisher_id integer, alignment_id integer, height_cm integer, weight_kg integer; PRIMARY KEY(id); FK(gender_id REFERENCES gender(id)); FK(eye_colour_id REFERENCES colour(id)); FK(hair_colour_id REFERENCES colour(id)); FK(skin_colour_id REFERENCES colour(id)); FK(race_id REFERENCES race(id)); FK(publisher_id REFERENCES publisher(id)); FK(alignment_id REFERENCES alignment(id)))\nhero_attribute(hero_id integer, attribute_id integer, attribute_value integer; FK(hero_id REFERENCES superhero(id)); FK(attribute_id REFERENCES attribute(id)))\nsuperpower(id integer, power_name text; PRIMARY KEY(id))\nhero_power(hero_id integer, power_id integer; FK(hero_id REFERENCES superhero(id)); FK(power_id REFERENCES superpower(id)))",
    "ground_truth": "SELECT CAST(COUNT(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN gender AS T3 ON T1.gender_id = T3.id WHERE T3.gender = 'Female'",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "projection_case",
    "difficulty": "Hard"
  },
  {
    "idx": 70,
    "query_type": "projection_case",
    "question": "Among all superheroes in Marvel Comics, identify the percentage of 'good' superheroes.",
    "db_schema": "alignment(id integer, alignment text; PRIMARY KEY(id))\nattribute(id integer, attribute_name text; PRIMARY KEY(id))\ncolour(id integer, colour text; PRIMARY KEY(id))\ngender(id integer, gender text; PRIMARY KEY(id))\npublisher(id integer, publisher_name text; PRIMARY KEY(id))\nrace(id integer, race text; PRIMARY KEY(id))\nsuperhero(id integer, superhero_name text, full_name text, gender_id integer, eye_colour_id integer, hair_colour_id integer, skin_colour_id integer, race_id integer, publisher_id integer, alignment_id integer, height_cm integer, weight_kg integer; PRIMARY KEY(id); FK(gender_id REFERENCES gender(id)); FK(eye_colour_id REFERENCES colour(id)); FK(hair_colour_id REFERENCES colour(id)); FK(skin_colour_id REFERENCES colour(id)); FK(race_id REFERENCES race(id)); FK(publisher_id REFERENCES publisher(id)); FK(alignment_id REFERENCES alignment(id)))\nhero_attribute(hero_id integer, attribute_id integer, attribute_value integer; FK(hero_id REFERENCES superhero(id)); FK(attribute_id REFERENCES attribute(id)))\nsuperpower(id integer, power_name text; PRIMARY KEY(id))\nhero_power(hero_id integer, power_id integer; FK(hero_id REFERENCES superhero(id)); FK(power_id REFERENCES superpower(id)))",
    "ground_truth": "SELECT CAST(COUNT(CASE WHEN T3.alignment = 'Good' THEN T1.id ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN alignment AS T3 ON T1.alignment_id = T3.id WHERE T2.publisher_name = 'Marvel Comics'",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "projection_case",
    "difficulty": "Hard"
  },
  {
    "idx": 71,
    "query_type": "projection_case",
    "question": "What is the annual average number of races held during the first 10 years of the 21st century?",
    "db_schema": "circuits(circuitId integer, circuitRef text, name text, location text, country text, lat real, lng real, alt integer, url text; PRIMARY KEY(circuitId))\nconstructors(constructorId integer, constructorRef text, name text, nationality text, url text; PRIMARY KEY(constructorId))\ndrivers(driverId integer, driverRef text, number integer, code text, forename text, surname text, dob date, nationality text, url text; PRIMARY KEY(driverId))\nseasons(year integer, url text; PRIMARY KEY(year))\nraces(raceId integer, year integer, round integer, circuitId integer, name text, date date, time text, url text; PRIMARY KEY(raceId); FK(year REFERENCES seasons(year)); FK(circuitId REFERENCES circuits(circuitId)))\nconstructorResults(constructorResultsId integer, raceId integer, constructorId integer, points real, status text; PRIMARY KEY(constructorResultsId); FK(raceId REFERENCES races(raceId)); FK(constructorId REFERENCES constructors(constructorId)))\nconstructorStandings(constructorStandingsId integer, raceId integer, constructorId integer, points real, position integer, positionText text, wins integer; PRIMARY KEY(constructorStandingsId); FK(raceId REFERENCES races(raceId)); FK(constructorId REFERENCES constructors(constructorId)))\ndriverStandings(driverStandingsId integer, raceId integer, driverId integer, points real, position integer, positionText text, wins integer; PRIMARY KEY(driverStandingsId); FK(raceId REFERENCES races(raceId)); FK(driverId REFERENCES drivers(driverId)))\nlapTimes(raceId integer, driverId integer, lap integer, position integer, time text, milliseconds integer; FK(raceId REFERENCES races(raceId)); FK(driverId REFERENCES drivers(driverId)))\npitStops(raceId integer, driverId integer, stop integer, lap integer, time text, duration text, milliseconds integer; FK(raceId REFERENCES races(raceId)); FK(driverId REFERENCES drivers(driverId)))\nqualifying(qualifyId integer, raceId integer, driverId integer, constructorId integer, number integer, position integer, q1 text, q2 text, q3 text; PRIMARY KEY(qualifyId); FK(raceId REFERENCES races(raceId)); FK(driverId REFERENCES drivers(driverId)); FK(constructorId REFERENCES constructors(constructorId)))\nstatus(statusId integer, status text; PRIMARY KEY(statusId))\nresults(resultId integer, raceId integer, driverId integer, constructorId integer, number integer, grid integer, position integer, positionText text, positionOrder integer, points real, laps integer, time text, milliseconds integer, fastestLap integer, rank integer, fastestLapTime text, fastestLapSpeed text, statusId integer; PRIMARY KEY(resultId); FK(raceId REFERENCES races(raceId)); FK(driverId REFERENCES drivers(driverId)); FK(constructorId REFERENCES constructors(constructorId)); FK(statusId REFERENCES status(statusId)))",
    "ground_truth": "SELECT CAST(SUM(CASE WHEN year BETWEEN 2000 AND 2010 THEN 1 ELSE 0 END) AS REAL) / 10 FROM races WHERE date BETWEEN '2000-01-01' AND '2010-12-31'",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "projection_case",
    "difficulty": "Medium"
  },
  {
    "idx": 72,
    "query_type": "projection_case",
    "question": "What percentage is Landon Donovan's overall rating higher than Jordan Bowery on 2013/7/12?",
    "db_schema": "Player_Attributes(id integer, player_fifa_api_id integer, player_api_id integer, date text, overall_rating integer, potential integer, preferred_foot text, attacking_work_rate text, defensive_work_rate text, crossing integer, finishing integer, heading_accuracy integer, short_passing integer, volleys integer, dribbling integer, curve integer, free_kick_accuracy integer, long_passing integer, ball_control integer, acceleration integer, sprint_speed integer, agility integer, reactions integer, balance integer, shot_power integer, jumping integer, stamina integer, strength integer, long_shots integer, aggression integer, interceptions integer, positioning integer, vision integer, penalties integer, marking integer, standing_tackle integer, sliding_tackle integer, gk_diving integer, gk_handling integer, gk_kicking integer, gk_positioning integer, gk_reflexes integer; PRIMARY KEY(id); FK(player_fifa_api_id REFERENCES Player(player_fifa_api_id)); FK(player_api_id REFERENCES Player(player_api_id)))\nPlayer(id integer, player_api_id integer, player_name text, player_fifa_api_id integer, birthday text, height integer, weight integer; PRIMARY KEY(id))\nLeague(id integer, country_id integer, name text; PRIMARY KEY(id); FK(country_id REFERENCES Country(id)))\nCountry(id integer, name text; PRIMARY KEY(id))\nTeam(id integer, team_api_id integer, team_fifa_api_id integer, team_long_name text, team_short_name text; PRIMARY KEY(id))\nTeam_Attributes(id integer, team_fifa_api_id integer, team_api_id integer, date text, buildUpPlaySpeed integer, buildUpPlaySpeedClass text, buildUpPlayDribbling integer, buildUpPlayDribblingClass text, buildUpPlayPassing integer, buildUpPlayPassingClass text, buildUpPlayPositioningClass text, chanceCreationPassing integer, chanceCreationPassingClass text, chanceCreationCrossing integer, chanceCreationCrossingClass text, chanceCreationShooting integer, chanceCreationShootingClass text, chanceCreationPositioningClass text, defencePressure integer, defencePressureClass text, defenceAggression integer, defenceAggressionClass text, defenceTeamWidth integer, defenceTeamWidthClass text, defenceDefenderLineClass text; PRIMARY KEY(id); FK(team_fifa_api_id REFERENCES Team(team_fifa_api_id)); FK(team_api_id REFERENCES Team(team_api_id)))\nMatch(id integer, country_id integer, league_id integer, season text, stage integer, date text, match_api_id integer, home_team_api_id integer, away_team_api_id integer, home_team_goal integer, away_team_goal integer, home_player_X1 integer, home_player_X2 integer, home_player_X3 integer, home_player_X4 integer, home_player_X5 integer, home_player_X6 integer, home_player_X7 integer, home_player_X8 integer, home_player_X9 integer, home_player_X10 integer, home_player_X11 integer, away_player_X1 integer, away_player_X2 integer, away_player_X3 integer, away_player_X4 integer, away_player_X5 integer, away_player_X6 integer, away_player_X7 integer, away_player_X8 integer, away_player_X9 integer, away_player_X10 integer, away_player_X11 integer, home_player_Y1 integer, home_player_Y2 integer, home_player_Y3 integer, home_player_Y4 integer, home_player_Y5 integer, home_player_Y6 integer, home_player_Y7 integer, home_player_Y8 integer, home_player_Y9 integer, home_player_Y10 integer, home_player_Y11 integer, away_player_Y1 integer, away_player_Y2 integer, away_player_Y3 integer, away_player_Y4 integer, away_player_Y5 integer, away_player_Y6 integer, away_player_Y7 integer, away_player_Y8 integer, away_player_Y9 integer, away_player_Y10 integer, away_player_Y11 integer, home_player_1 integer, home_player_2 integer, home_player_3 integer, home_player_4 integer, home_player_5 integer, home_player_6 integer, home_player_7 integer, home_player_8 integer, home_player_9 integer, home_player_10 integer, home_player_11 integer, away_player_1 integer, away_player_2 integer, away_player_3 integer, away_player_4 integer, away_player_5 integer, away_player_6 integer, away_player_7 integer, away_player_8 integer, away_player_9 integer, away_player_10 integer, away_player_11 integer, goal text, shoton text, shotoff text, foulcommit text, card text, cross text, corner text, possession text, B365H real, B365D real, B365A real, BWH real, BWD real, BWA real, IWH real, IWD real, IWA real, LBH real, LBD real, LBA real, PSH real, PSD real, PSA real, WHH real, WHD real, WHA real, SJH real, SJD real, SJA real, VCH real, VCD real, VCA real, GBH real, GBD real, GBA real, BSH real, BSD real, BSA real; PRIMARY KEY(id); FK(home_team_api_id REFERENCES Team(team_api_id)); FK(away_team_api_id REFERENCES Team(team_api_id)); FK(home_player_1 REFERENCES Player(player_api_id)); FK(home_player_2 REFERENCES Player(player_api_id)); FK(home_player_3 REFERENCES Player(player_api_id)); FK(home_player_4 REFERENCES Player(player_api_id)); FK(home_player_5 REFERENCES Player(player_api_id)); FK(home_player_6 REFERENCES Player(player_api_id)); FK(home_player_7 REFERENCES Player(player_api_id)); FK(home_player_8 REFERENCES Player(player_api_id)); FK(home_player_9 REFERENCES Player(player_api_id)); FK(home_player_10 REFERENCES Player(player_api_id)); FK(home_player_11 REFERENCES Player(player_api_id)); FK(away_player_1 REFERENCES Player(player_api_id)); FK(away_player_2 REFERENCES Player(player_api_id)); FK(away_player_3 REFERENCES Player(player_api_id)); FK(away_player_4 REFERENCES Player(player_api_id)); FK(away_player_5 REFERENCES Player(player_api_id)); FK(away_player_6 REFERENCES Player(player_api_id)); FK(away_player_7 REFERENCES Player(player_api_id)); FK(away_player_8 REFERENCES Player(player_api_id)); FK(away_player_9 REFERENCES Player(player_api_id)); FK(away_player_10 REFERENCES Player(player_api_id)); FK(away_player_11 REFERENCES Player(player_api_id)))",
    "ground_truth": "SELECT (SUM(CASE WHEN t1.player_name = 'Landon Donovan' THEN t2.overall_rating ELSE 0 END) * 1.0 - SUM(CASE WHEN t1.player_name = 'Jordan Bowery' THEN t2.overall_rating ELSE 0 END)) * 100 / SUM(CASE WHEN t1.player_name = 'Landon Donovan' THEN t2.overall_rating ELSE 0 END) LvsJ_percent FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id WHERE SUBSTR(t2.`date`, 1, 10) = '2013-07-12'",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "projection_case",
    "difficulty": "Hard"
  },
  {
    "idx": 73,
    "query_type": "projection_case",
    "question": "What is the ratio of outpatient to inpatient followed up treatment among all the 'SLE' diagnosed patient?",
    "db_schema": "Examination(ID integer, Examination Date date, aCL IgG real, aCL IgM real, ANA integer, ANA Pattern text, aCL IgA integer, Diagnosis text, KCT text, RVVT text, LAC text, Symptoms text, Thrombosis integer; FK(ID REFERENCES Patient(ID)))\nPatient(ID integer, SEX text, Birthday date, Description date, First Date date, Admission text, Diagnosis text; PRIMARY KEY(ID))\nLaboratory(ID integer, Date date, GOT integer, GPT integer, LDH integer, ALP integer, TP real, ALB real, UA real, UN integer, CRE real, T-BIL real, T-CHO integer, TG integer, CPK integer, GLU integer, WBC real, RBC real, HGB real, HCT real, PLT integer, PT real, APTT integer, FG real, PIC integer, TAT integer, TAT2 integer, U-PRO text, IGG integer, IGA integer, IGM integer, CRP text, RA text, RF text, C3 integer, C4 integer, RNP text, SM text, SC170 text, SSA text, SSB text, CENTROMEA text, DNA text, DNA-II integer; FK(ID REFERENCES Patient(ID)))",
    "ground_truth": "SELECT SUM(CASE WHEN Admission = '+' THEN 1.0 ELSE 0 END) / SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END) FROM Patient WHERE Diagnosis = 'SLE'",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "projection_case",
    "difficulty": "Medium"
  },
  {
    "idx": 74,
    "query_type": "projection_case",
    "question": "What proportion of patients who had signs of thrombocytopenia had SLE diagnosed?",
    "db_schema": "Examination(ID integer, Examination Date date, aCL IgG real, aCL IgM real, ANA integer, ANA Pattern text, aCL IgA integer, Diagnosis text, KCT text, RVVT text, LAC text, Symptoms text, Thrombosis integer; FK(ID REFERENCES Patient(ID)))\nPatient(ID integer, SEX text, Birthday date, Description date, First Date date, Admission text, Diagnosis text; PRIMARY KEY(ID))\nLaboratory(ID integer, Date date, GOT integer, GPT integer, LDH integer, ALP integer, TP real, ALB real, UA real, UN integer, CRE real, T-BIL real, T-CHO integer, TG integer, CPK integer, GLU integer, WBC real, RBC real, HGB real, HCT real, PLT integer, PT real, APTT integer, FG real, PIC integer, TAT integer, TAT2 integer, U-PRO text, IGG integer, IGA integer, IGM integer, CRP text, RA text, RF text, C3 integer, C4 integer, RNP text, SM text, SC170 text, SSA text, SSB text, CENTROMEA text, DNA text, DNA-II integer; FK(ID REFERENCES Patient(ID)))",
    "ground_truth": "SELECT CAST(SUM(CASE WHEN Diagnosis = 'SLE' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(ID) FROM Examination WHERE Symptoms = 'thrombocytopenia'",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "projection_case",
    "difficulty": "Medium"
  },
  {
    "idx": 75,
    "query_type": "projection_case",
    "question": "For patients with abnormal platelet level, state the number of patients with lower than normal range. How is it compare to the number of patients with higher than normal range?",
    "db_schema": "Examination(ID integer, Examination Date date, aCL IgG real, aCL IgM real, ANA integer, ANA Pattern text, aCL IgA integer, Diagnosis text, KCT text, RVVT text, LAC text, Symptoms text, Thrombosis integer; FK(ID REFERENCES Patient(ID)))\nPatient(ID integer, SEX text, Birthday date, Description date, First Date date, Admission text, Diagnosis text; PRIMARY KEY(ID))\nLaboratory(ID integer, Date date, GOT integer, GPT integer, LDH integer, ALP integer, TP real, ALB real, UA real, UN integer, CRE real, T-BIL real, T-CHO integer, TG integer, CPK integer, GLU integer, WBC real, RBC real, HGB real, HCT real, PLT integer, PT real, APTT integer, FG real, PIC integer, TAT integer, TAT2 integer, U-PRO text, IGG integer, IGA integer, IGM integer, CRP text, RA text, RF text, C3 integer, C4 integer, RNP text, SM text, SC170 text, SSA text, SSB text, CENTROMEA text, DNA text, DNA-II integer; FK(ID REFERENCES Patient(ID)))",
    "ground_truth": "SELECT SUM(CASE WHEN T2.PLT <= 100 THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.PLT >= 400 THEN 1 ELSE 0 END) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "projection_case",
    "difficulty": "Medium"
  },
  {
    "idx": 76,
    "query_type": "subquery",
    "question": "List the name of clubs that do not have players.",
    "db_schema": "/* Schema not available */",
    "ground_truth": "SELECT Name FROM club WHERE Club_ID NOT IN (SELECT Club_ID FROM player)",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "subquery",
    "difficulty": "Medium"
  },
  {
    "idx": 77,
    "query_type": "subquery",
    "question": "Find the details of the customers who have used the least-used service .",
    "db_schema": "/* Schema not available */",
    "ground_truth": "select distinct t1.customer_details from customers as t1 join customers_and_services as t2 on t1.customer_id  =  t2.customer_id where t2.service_id  =  (select service_id from services group by service_id order by count(*) asc limit 1)",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "subquery",
    "difficulty": "Medium"
  },
  {
    "idx": 78,
    "query_type": "subquery",
    "question": "Show ids for all students who don't live in USA.",
    "db_schema": "/* Schema not available */",
    "ground_truth": "SELECT StuID FROM Student EXCEPT SELECT StuID FROM City AS T1 JOIN Student AS T2 ON T1.city_code  =  T2.city_code WHERE country  =  \"USA\"",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "subquery",
    "difficulty": "Medium"
  },
  {
    "idx": 79,
    "query_type": "subquery",
    "question": "What are the names and nationalities of the people who did not participate in any ACL conferences?",
    "db_schema": "/* Schema not available */",
    "ground_truth": "SELECT name ,  nationality FROM staff WHERE staff_id NOT IN (SELECT T2.staff_id FROM Conference AS T1 JOIN Conference_participation AS T2 ON T1.conference_id  =  T2.conference_id WHERE T1.Conference_Name  =  \"ACL\")",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "subquery",
    "difficulty": "Medium"
  },
  {
    "idx": 80,
    "query_type": "subquery",
    "question": "Show the names of languages that are the official language for both countries with overall score greater than 95 and countries with overall score less than than 90.",
    "db_schema": "/* Schema not available */",
    "ground_truth": "SELECT T3.name FROM countries AS T1 JOIN official_languages AS T2 ON T1.id  =  T2.country_id JOIN languages AS T3 ON T2.language_id  =  T3.id WHERE T1.overall_score  >  95 INTERSECT SELECT T3.name FROM countries AS T1 JOIN official_languages AS T2 ON T1.id  =  T2.country_id JOIN languages AS T3 ON T2.language_id  =  T3.id WHERE T1.overall_score  <  90",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "subquery",
    "difficulty": "Hard"
  },
  {
    "idx": 81,
    "query_type": "subquery",
    "question": "Find the name of all movies that are not played in Odeon theater.",
    "db_schema": "/* Schema not available */",
    "ground_truth": "SELECT title FROM movies EXCEPT SELECT T1.title FROM movies AS T1 JOIN movietheaters AS T2 ON T1.code  =  T2.movie WHERE T2.name  =  'Odeon'",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "subquery",
    "difficulty": "Medium"
  },
  {
    "idx": 82,
    "query_type": "subquery",
    "question": "What is the average age for all students who do not own any pets ?",
    "db_schema": "Student(StuID number, LName text, Fname text, Age number, Sex text, Major number, Advisor number, city_code text; PRIMARY KEY(StuID))\nHas_Pet(StuID number, PetID number; FK(StuID REFERENCES Student(StuID)); FK(PetID REFERENCES Pets(PetID)))\nPets(PetID number, PetType text, pet_age number, weight number; PRIMARY KEY(PetID))",
    "ground_truth": "select avg(age) from student where stuid not in (select stuid from has_pet)",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "subquery",
    "difficulty": "Medium"
  },
  {
    "idx": 83,
    "query_type": "subquery",
    "question": "What are the names of people who do not play poker?",
    "db_schema": "poker_player(Poker_Player_ID number, People_ID number, Final_Table_Made number, Best_Finish number, Money_Rank number, Earnings number; PRIMARY KEY(Poker_Player_ID); FK(People_ID REFERENCES people(People_ID)))\npeople(People_ID number, Nationality text, Name text, Birth_Date text, Height number; PRIMARY KEY(People_ID))",
    "ground_truth": "SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM poker_player)",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "subquery",
    "difficulty": "Medium"
  },
  {
    "idx": 84,
    "query_type": "subquery",
    "question": "List the last name of the owner owning the youngest dog.",
    "db_schema": "Breeds(breed_code text, breed_name text; PRIMARY KEY(breed_code))\nCharges(charge_id number, charge_type text, charge_amount number; PRIMARY KEY(charge_id))\nSizes(size_code text, size_description text; PRIMARY KEY(size_code))\nTreatment_Types(treatment_type_code text, treatment_type_description text; PRIMARY KEY(treatment_type_code))\nOwners(owner_id number, first_name text, last_name text, street text, city text, state text, zip_code text, email_address text, home_phone text, cell_number text; PRIMARY KEY(owner_id))\nDogs(dog_id number, owner_id number, abandoned_yn text, breed_code text, size_code text, name text, age text, date_of_birth time, gender text, weight text, date_arrived time, date_adopted time, date_departed time; PRIMARY KEY(dog_id); FK(owner_id REFERENCES Owners(owner_id)); FK(owner_id REFERENCES Owners(owner_id)); FK(breed_code REFERENCES Breeds(breed_code)); FK(size_code REFERENCES Sizes(size_code)))\nProfessionals(professional_id number, role_code text, first_name text, street text, city text, state text, zip_code text, last_name text, email_address text, home_phone text, cell_number text; PRIMARY KEY(professional_id))\nTreatments(treatment_id number, dog_id number, professional_id number, treatment_type_code text, date_of_treatment time, cost_of_treatment number; PRIMARY KEY(treatment_id); FK(dog_id REFERENCES Dogs(dog_id)); FK(professional_id REFERENCES Professionals(professional_id)); FK(treatment_type_code REFERENCES Treatment_Types(treatment_type_code)))",
    "ground_truth": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "subquery",
    "difficulty": "Hard"
  },
  {
    "idx": 85,
    "query_type": "subquery",
    "question": "Which user ID has the lowest view?",
    "db_schema": "badges(Id integer, UserId integer, Name text, Date datetime; PRIMARY KEY(Id); FK(UserId REFERENCES users(Id)))\ncomments(Id integer, PostId integer, Score integer, Text text, CreationDate datetime, UserId integer, UserDisplayName text; PRIMARY KEY(Id); FK(PostId REFERENCES posts(Id)); FK(UserId REFERENCES users(Id)))\npostHistory(Id integer, PostHistoryTypeId integer, PostId integer, RevisionGUID text, CreationDate datetime, UserId integer, Text text, Comment text, UserDisplayName text; PRIMARY KEY(Id); FK(PostId REFERENCES posts(Id)); FK(UserId REFERENCES users(Id)))\npostLinks(Id integer, CreationDate datetime, PostId integer, RelatedPostId integer, LinkTypeId integer; PRIMARY KEY(Id); FK(PostId REFERENCES posts(Id)); FK(RelatedPostId REFERENCES posts(Id)))\nposts(Id integer, PostTypeId integer, AcceptedAnswerId integer, CreaionDate datetime, Score integer, ViewCount integer, Body text, OwnerUserId integer, LasActivityDate datetime, Title text, Tags text, AnswerCount integer, CommentCount integer, FavoriteCount integer, LastEditorUserId integer, LastEditDate datetime, CommunityOwnedDate datetime, ParentId integer, ClosedDate datetime, OwnerDisplayName text, LastEditorDisplayName text; PRIMARY KEY(Id); FK(OwnerUserId REFERENCES users(Id)); FK(LastEditorUserId REFERENCES users(Id)); FK(ParentId REFERENCES posts(Id)))\ntags(Id integer, TagName text, Count integer, ExcerptPostId integer, WikiPostId integer; PRIMARY KEY(Id); FK(ExcerptPostId REFERENCES posts(Id)))\nusers(Id integer, Reputation integer, CreationDate datetime, DisplayName text, LastAccessDate datetime, WebsiteUrl text, Location text, AboutMe text, Views integer, UpVotes integer, DownVotes integer, AccountId integer, Age integer, ProfileImageUrl text; PRIMARY KEY(Id))\nvotes(Id integer, PostId integer, VoteTypeId integer, CreationDate date, UserId integer, BountyAmount integer; PRIMARY KEY(Id); FK(PostId REFERENCES posts(Id)); FK(UserId REFERENCES users(Id)))",
    "ground_truth": "SELECT Id FROM users WHERE Views = ( SELECT MIN(Views) FROM users )",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "subquery",
    "difficulty": "Hard"
  },
  {
    "idx": 86,
    "query_type": "group_by_having",
    "question": "List the manufacturers that are associated with more than one club.",
    "db_schema": "/* Schema not available */",
    "ground_truth": "SELECT Manufacturer FROM club GROUP BY Manufacturer HAVING COUNT(*)  >  1",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "group_by_having",
    "difficulty": "Medium"
  },
  {
    "idx": 87,
    "query_type": "group_by_having",
    "question": "Show the names of regions that have more than one building.",
    "db_schema": "/* Schema not available */",
    "ground_truth": "SELECT T2.Name FROM building AS T1 JOIN region AS T2 ON T1.Region_ID  =  T2.Region_ID GROUP BY T1.Region_ID HAVING COUNT(*)  >  1",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "group_by_having",
    "difficulty": "Medium"
  },
  {
    "idx": 88,
    "query_type": "group_by_having",
    "question": "What are the names of cities with at least three students?",
    "db_schema": "/* Schema not available */",
    "ground_truth": "SELECT T1.city_name FROM City AS T1 JOIN Student AS T2 ON T1.city_code  =  T2.city_code GROUP BY T1.city_code HAVING count(*)  >=  3",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "group_by_having",
    "difficulty": "Medium"
  },
  {
    "idx": 89,
    "query_type": "group_by_having",
    "question": "Find the teams that won more than once.",
    "db_schema": "/* Schema not available */",
    "ground_truth": "SELECT Winning_team FROM race GROUP BY Winning_team HAVING count(*)  >  1",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "group_by_having",
    "difficulty": "Medium"
  },
  {
    "idx": 90,
    "query_type": "group_by_having",
    "question": "Find the team with two or more drivers and return the the manager and car owner of the team.",
    "db_schema": "/* Schema not available */",
    "ground_truth": "SELECT t1.manager ,  t1.car_owner FROM team AS t1 JOIN team_driver AS t2 ON t1.team_id  =  t2.team_id GROUP BY t2.team_id HAVING count(*)  >=  2",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "group_by_having",
    "difficulty": "Medium"
  },
  {
    "idx": 91,
    "query_type": "group_by_having",
    "question": "What are the id, sic code and agency id of the client who has attended 1 meeting and has any invoice.",
    "db_schema": "/* Schema not available */",
    "ground_truth": "SELECT T1.client_id ,  T1.sic_code ,  T1.agency_id FROM clients AS T1 JOIN meetings AS T2 ON T1.client_id  =  T2.client_id GROUP BY T1.client_id HAVING count(*)  =  1 INTERSECT SELECT T1.client_id ,  T1.sic_code ,  T1.agency_id FROM clients AS T1 JOIN invoices AS T2 ON T1.client_id  =  T2.client_id",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "group_by_having",
    "difficulty": "Hard"
  },
  {
    "idx": 92,
    "query_type": "group_by_having",
    "question": "Show names of teachers that teach at least two courses.",
    "db_schema": "course(Course_ID number, Staring_Date text, Course text; PRIMARY KEY(Course_ID))\nteacher(Teacher_ID number, Name text, Age text, Hometown text; PRIMARY KEY(Teacher_ID))\ncourse_arrange(Course_ID number, Teacher_ID number, Grade number; PRIMARY KEY(Course_ID); FK(Course_ID REFERENCES course(Course_ID)); FK(Teacher_ID REFERENCES teacher(Teacher_ID)))",
    "ground_truth": "SELECT T2.Name FROM course_arrange AS T1 JOIN teacher AS T2 ON T1.Teacher_ID  =  T2.Teacher_ID GROUP BY T2.Name HAVING COUNT(*)  >=  2",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "group_by_having",
    "difficulty": "Hard"
  },
  {
    "idx": 93,
    "query_type": "group_by_having",
    "question": "Which grades have 4 or more high schoolers?",
    "db_schema": "Highschooler(ID number, name text, grade number; PRIMARY KEY(ID))\nFriend(student_id number, friend_id number; PRIMARY KEY(student_id); FK(student_id REFERENCES Highschooler(ID)); FK(friend_id REFERENCES Highschooler(ID)))\nLikes(student_id number, liked_id number; PRIMARY KEY(student_id); FK(student_id REFERENCES Highschooler(ID)); FK(liked_id REFERENCES Highschooler(ID)))",
    "ground_truth": "SELECT grade FROM Highschooler GROUP BY grade HAVING count(*)  >=  4",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "group_by_having",
    "difficulty": "Medium"
  },
  {
    "idx": 94,
    "query_type": "window_function",
    "question": "Rank schools by their average score in Writing where the score is greater than 499, showing their charter numbers.",
    "db_schema": "frpm(CDSCode text, Academic Year text, County Code text, District Code integer, School Code text, County Name text, District Name text, School Name text, District Type text, School Type text, Educational Option Type text, NSLP Provision Status text, Charter School (Y/N) integer, Charter School Number text, Charter Funding Type text, IRC integer, Low Grade text, High Grade text, Enrollment (K-12) real, Free Meal Count (K-12) real, Percent (%) Eligible Free (K-12) real, FRPM Count (K-12) real, Percent (%) Eligible FRPM (K-12) real, Enrollment (Ages 5-17) real, Free Meal Count (Ages 5-17) real, Percent (%) Eligible Free (Ages 5-17) real, FRPM Count (Ages 5-17) real, Percent (%) Eligible FRPM (Ages 5-17) real, 2013-14 CALPADS Fall 1 Certification Status integer; PRIMARY KEY(CDSCode); FK(CDSCode REFERENCES schools(CDSCode)))\nsatscores(cds text, rtype text, sname text, dname text, cname text, enroll12 integer, NumTstTakr integer, AvgScrRead integer, AvgScrMath integer, AvgScrWrite integer, NumGE1500 integer; PRIMARY KEY(cds); FK(cds REFERENCES schools(CDSCode)))\nschools(CDSCode text, NCESDist text, NCESSchool text, StatusType text, County text, District text, School text, Street text, StreetAbr text, City text, Zip text, State text, MailStreet text, MailStrAbr text, MailCity text, MailZip text, MailState text, Phone text, Ext text, Website text, OpenDate date, ClosedDate date, Charter integer, CharterNum text, FundingType text, DOC text, DOCType text, SOC text, SOCType text, EdOpsCode text, EdOpsName text, EILCode text, EILName text, GSoffered text, GSserved text, Virtual text, Magnet integer, Latitude real, Longitude real, AdmFName1 text, AdmLName1 text, AdmEmail1 text, AdmFName2 text, AdmLName2 text, AdmEmail2 text, AdmFName3 text, AdmLName3 text, AdmEmail3 text, LastUpdate date; PRIMARY KEY(CDSCode))",
    "ground_truth": "SELECT CharterNum, AvgScrWrite, RANK() OVER (ORDER BY AvgScrWrite DESC) AS WritingScoreRank FROM schools AS T1  INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE T2.AvgScrWrite > 499 AND CharterNum is not null",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "window_function",
    "difficulty": "Hard"
  },
  {
    "idx": 95,
    "query_type": "window_function",
    "question": "List the names of virtual schools that are among the top 5 in their respective counties based on average reading scores.",
    "db_schema": "frpm(CDSCode text, Academic Year text, County Code text, District Code integer, School Code text, County Name text, District Name text, School Name text, District Type text, School Type text, Educational Option Type text, NSLP Provision Status text, Charter School (Y/N) integer, Charter School Number text, Charter Funding Type text, IRC integer, Low Grade text, High Grade text, Enrollment (K-12) real, Free Meal Count (K-12) real, Percent (%) Eligible Free (K-12) real, FRPM Count (K-12) real, Percent (%) Eligible FRPM (K-12) real, Enrollment (Ages 5-17) real, Free Meal Count (Ages 5-17) real, Percent (%) Eligible Free (Ages 5-17) real, FRPM Count (Ages 5-17) real, Percent (%) Eligible FRPM (Ages 5-17) real, 2013-14 CALPADS Fall 1 Certification Status integer; PRIMARY KEY(CDSCode); FK(CDSCode REFERENCES schools(CDSCode)))\nsatscores(cds text, rtype text, sname text, dname text, cname text, enroll12 integer, NumTstTakr integer, AvgScrRead integer, AvgScrMath integer, AvgScrWrite integer, NumGE1500 integer; PRIMARY KEY(cds); FK(cds REFERENCES schools(CDSCode)))\nschools(CDSCode text, NCESDist text, NCESSchool text, StatusType text, County text, District text, School text, Street text, StreetAbr text, City text, Zip text, State text, MailStreet text, MailStrAbr text, MailCity text, MailZip text, MailState text, Phone text, Ext text, Website text, OpenDate date, ClosedDate date, Charter integer, CharterNum text, FundingType text, DOC text, DOCType text, SOC text, SOCType text, EdOpsCode text, EdOpsName text, EILCode text, EILName text, GSoffered text, GSserved text, Virtual text, Magnet integer, Latitude real, Longitude real, AdmFName1 text, AdmLName1 text, AdmEmail1 text, AdmFName2 text, AdmLName2 text, AdmEmail2 text, AdmFName3 text, AdmLName3 text, AdmEmail3 text, LastUpdate date; PRIMARY KEY(CDSCode))",
    "ground_truth": "SELECT School FROM (SELECT T2.School,T1.AvgScrRead, RANK() OVER (PARTITION BY T2.County ORDER BY T1.AvgScrRead DESC) AS rnk FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.Virtual = 'F' ) ranked_schools WHERE rnk <= 5",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "window_function",
    "difficulty": "Hard"
  },
  {
    "idx": 96,
    "query_type": "window_function",
    "question": "Rank heroes published by Marvel Comics by their height in descending order.",
    "db_schema": "alignment(id integer, alignment text; PRIMARY KEY(id))\nattribute(id integer, attribute_name text; PRIMARY KEY(id))\ncolour(id integer, colour text; PRIMARY KEY(id))\ngender(id integer, gender text; PRIMARY KEY(id))\npublisher(id integer, publisher_name text; PRIMARY KEY(id))\nrace(id integer, race text; PRIMARY KEY(id))\nsuperhero(id integer, superhero_name text, full_name text, gender_id integer, eye_colour_id integer, hair_colour_id integer, skin_colour_id integer, race_id integer, publisher_id integer, alignment_id integer, height_cm integer, weight_kg integer; PRIMARY KEY(id); FK(gender_id REFERENCES gender(id)); FK(eye_colour_id REFERENCES colour(id)); FK(hair_colour_id REFERENCES colour(id)); FK(skin_colour_id REFERENCES colour(id)); FK(race_id REFERENCES race(id)); FK(publisher_id REFERENCES publisher(id)); FK(alignment_id REFERENCES alignment(id)))\nhero_attribute(hero_id integer, attribute_id integer, attribute_value integer; FK(hero_id REFERENCES superhero(id)); FK(attribute_id REFERENCES attribute(id)))\nsuperpower(id integer, power_name text; PRIMARY KEY(id))\nhero_power(hero_id integer, power_id integer; FK(hero_id REFERENCES superhero(id)); FK(power_id REFERENCES superpower(id)))",
    "ground_truth": "SELECT superhero_name, height_cm, RANK() OVER (ORDER BY height_cm DESC) AS HeightRank FROM superhero INNER JOIN publisher ON superhero.publisher_id = publisher.id WHERE publisher.publisher_name = 'Marvel Comics'",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "window_function",
    "difficulty": "Hard"
  },
  {
    "idx": 97,
    "query_type": "window_function",
    "question": "Rank superheroes from Marvel Comics by their eye color popularity, starting with the most common color.",
    "db_schema": "alignment(id integer, alignment text; PRIMARY KEY(id))\nattribute(id integer, attribute_name text; PRIMARY KEY(id))\ncolour(id integer, colour text; PRIMARY KEY(id))\ngender(id integer, gender text; PRIMARY KEY(id))\npublisher(id integer, publisher_name text; PRIMARY KEY(id))\nrace(id integer, race text; PRIMARY KEY(id))\nsuperhero(id integer, superhero_name text, full_name text, gender_id integer, eye_colour_id integer, hair_colour_id integer, skin_colour_id integer, race_id integer, publisher_id integer, alignment_id integer, height_cm integer, weight_kg integer; PRIMARY KEY(id); FK(gender_id REFERENCES gender(id)); FK(eye_colour_id REFERENCES colour(id)); FK(hair_colour_id REFERENCES colour(id)); FK(skin_colour_id REFERENCES colour(id)); FK(race_id REFERENCES race(id)); FK(publisher_id REFERENCES publisher(id)); FK(alignment_id REFERENCES alignment(id)))\nhero_attribute(hero_id integer, attribute_id integer, attribute_value integer; FK(hero_id REFERENCES superhero(id)); FK(attribute_id REFERENCES attribute(id)))\nsuperpower(id integer, power_name text; PRIMARY KEY(id))\nhero_power(hero_id integer, power_id integer; FK(hero_id REFERENCES superhero(id)); FK(power_id REFERENCES superpower(id)))",
    "ground_truth": "SELECT colour.colour AS EyeColor, COUNT(superhero.id) AS Count, RANK() OVER (ORDER BY COUNT(superhero.id) DESC) AS PopularityRank FROM superhero INNER JOIN colour ON superhero.eye_colour_id = colour.id INNER JOIN publisher ON superhero.publisher_id = publisher.id WHERE publisher.publisher_name = 'Marvel Comics' GROUP BY colour.colour",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "window_function",
    "difficulty": "Hard"
  },
  {
    "idx": 98,
    "query_type": "window_function",
    "question": "List down most tallest players' name.",
    "db_schema": "Player_Attributes(id integer, player_fifa_api_id integer, player_api_id integer, date text, overall_rating integer, potential integer, preferred_foot text, attacking_work_rate text, defensive_work_rate text, crossing integer, finishing integer, heading_accuracy integer, short_passing integer, volleys integer, dribbling integer, curve integer, free_kick_accuracy integer, long_passing integer, ball_control integer, acceleration integer, sprint_speed integer, agility integer, reactions integer, balance integer, shot_power integer, jumping integer, stamina integer, strength integer, long_shots integer, aggression integer, interceptions integer, positioning integer, vision integer, penalties integer, marking integer, standing_tackle integer, sliding_tackle integer, gk_diving integer, gk_handling integer, gk_kicking integer, gk_positioning integer, gk_reflexes integer; PRIMARY KEY(id); FK(player_fifa_api_id REFERENCES Player(player_fifa_api_id)); FK(player_api_id REFERENCES Player(player_api_id)))\nPlayer(id integer, player_api_id integer, player_name text, player_fifa_api_id integer, birthday text, height integer, weight integer; PRIMARY KEY(id))\nLeague(id integer, country_id integer, name text; PRIMARY KEY(id); FK(country_id REFERENCES Country(id)))\nCountry(id integer, name text; PRIMARY KEY(id))\nTeam(id integer, team_api_id integer, team_fifa_api_id integer, team_long_name text, team_short_name text; PRIMARY KEY(id))\nTeam_Attributes(id integer, team_fifa_api_id integer, team_api_id integer, date text, buildUpPlaySpeed integer, buildUpPlaySpeedClass text, buildUpPlayDribbling integer, buildUpPlayDribblingClass text, buildUpPlayPassing integer, buildUpPlayPassingClass text, buildUpPlayPositioningClass text, chanceCreationPassing integer, chanceCreationPassingClass text, chanceCreationCrossing integer, chanceCreationCrossingClass text, chanceCreationShooting integer, chanceCreationShootingClass text, chanceCreationPositioningClass text, defencePressure integer, defencePressureClass text, defenceAggression integer, defenceAggressionClass text, defenceTeamWidth integer, defenceTeamWidthClass text, defenceDefenderLineClass text; PRIMARY KEY(id); FK(team_fifa_api_id REFERENCES Team(team_fifa_api_id)); FK(team_api_id REFERENCES Team(team_api_id)))\nMatch(id integer, country_id integer, league_id integer, season text, stage integer, date text, match_api_id integer, home_team_api_id integer, away_team_api_id integer, home_team_goal integer, away_team_goal integer, home_player_X1 integer, home_player_X2 integer, home_player_X3 integer, home_player_X4 integer, home_player_X5 integer, home_player_X6 integer, home_player_X7 integer, home_player_X8 integer, home_player_X9 integer, home_player_X10 integer, home_player_X11 integer, away_player_X1 integer, away_player_X2 integer, away_player_X3 integer, away_player_X4 integer, away_player_X5 integer, away_player_X6 integer, away_player_X7 integer, away_player_X8 integer, away_player_X9 integer, away_player_X10 integer, away_player_X11 integer, home_player_Y1 integer, home_player_Y2 integer, home_player_Y3 integer, home_player_Y4 integer, home_player_Y5 integer, home_player_Y6 integer, home_player_Y7 integer, home_player_Y8 integer, home_player_Y9 integer, home_player_Y10 integer, home_player_Y11 integer, away_player_Y1 integer, away_player_Y2 integer, away_player_Y3 integer, away_player_Y4 integer, away_player_Y5 integer, away_player_Y6 integer, away_player_Y7 integer, away_player_Y8 integer, away_player_Y9 integer, away_player_Y10 integer, away_player_Y11 integer, home_player_1 integer, home_player_2 integer, home_player_3 integer, home_player_4 integer, home_player_5 integer, home_player_6 integer, home_player_7 integer, home_player_8 integer, home_player_9 integer, home_player_10 integer, home_player_11 integer, away_player_1 integer, away_player_2 integer, away_player_3 integer, away_player_4 integer, away_player_5 integer, away_player_6 integer, away_player_7 integer, away_player_8 integer, away_player_9 integer, away_player_10 integer, away_player_11 integer, goal text, shoton text, shotoff text, foulcommit text, card text, cross text, corner text, possession text, B365H real, B365D real, B365A real, BWH real, BWD real, BWA real, IWH real, IWD real, IWA real, LBH real, LBD real, LBA real, PSH real, PSD real, PSA real, WHH real, WHD real, WHA real, SJH real, SJD real, SJA real, VCH real, VCD real, VCA real, GBH real, GBD real, GBA real, BSH real, BSD real, BSA real; PRIMARY KEY(id); FK(home_team_api_id REFERENCES Team(team_api_id)); FK(away_team_api_id REFERENCES Team(team_api_id)); FK(home_player_1 REFERENCES Player(player_api_id)); FK(home_player_2 REFERENCES Player(player_api_id)); FK(home_player_3 REFERENCES Player(player_api_id)); FK(home_player_4 REFERENCES Player(player_api_id)); FK(home_player_5 REFERENCES Player(player_api_id)); FK(home_player_6 REFERENCES Player(player_api_id)); FK(home_player_7 REFERENCES Player(player_api_id)); FK(home_player_8 REFERENCES Player(player_api_id)); FK(home_player_9 REFERENCES Player(player_api_id)); FK(home_player_10 REFERENCES Player(player_api_id)); FK(home_player_11 REFERENCES Player(player_api_id)); FK(away_player_1 REFERENCES Player(player_api_id)); FK(away_player_2 REFERENCES Player(player_api_id)); FK(away_player_3 REFERENCES Player(player_api_id)); FK(away_player_4 REFERENCES Player(player_api_id)); FK(away_player_5 REFERENCES Player(player_api_id)); FK(away_player_6 REFERENCES Player(player_api_id)); FK(away_player_7 REFERENCES Player(player_api_id)); FK(away_player_8 REFERENCES Player(player_api_id)); FK(away_player_9 REFERENCES Player(player_api_id)); FK(away_player_10 REFERENCES Player(player_api_id)); FK(away_player_11 REFERENCES Player(player_api_id)))",
    "ground_truth": "SELECT player_name FROM (SELECT player_name, height, DENSE_RANK() OVER (ORDER BY height DESC) as rank FROM Player) WHERE rank = 1",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "window_function",
    "difficulty": "Hard"
  },
  {
    "idx": 99,
    "query_type": "order_limit",
    "question": "What is the name of the player with the highest earnings?",
    "db_schema": "/* Schema not available */",
    "ground_truth": "SELECT Name FROM player ORDER BY Earnings DESC LIMIT 1",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "order_limit",
    "difficulty": "Easy"
  },
  {
    "idx": 100,
    "query_type": "order_limit",
    "question": "What is the cheapest cookie and its flavor?",
    "db_schema": "/* Schema not available */",
    "ground_truth": "SELECT id ,  flavor FROM goods WHERE food  =  \"Cookie\" ORDER BY price LIMIT 1",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "order_limit",
    "difficulty": "Easy"
  },
  {
    "idx": 101,
    "query_type": "order_limit",
    "question": "What is the first, middle, and last name of the first student to register?",
    "db_schema": "Addresses(address_id number, line_1 text, line_2 text, line_3 text, city text, zip_postcode text, state_province_county text, country text, other_address_details text; PRIMARY KEY(address_id))\nCourses(course_id number, course_name text, course_description text, other_details text; PRIMARY KEY(course_id))\nDepartments(department_id number, department_name text, department_description text, other_details text; PRIMARY KEY(department_id))\nDegree_Programs(degree_program_id number, department_id number, degree_summary_name text, degree_summary_description text, other_details text; PRIMARY KEY(degree_program_id); FK(department_id REFERENCES Departments(department_id)))\nSections(section_id number, course_id number, section_name text, section_description text, other_details text; PRIMARY KEY(section_id); FK(course_id REFERENCES Courses(course_id)))\nSemesters(semester_id number, semester_name text, semester_description text, other_details text; PRIMARY KEY(semester_id))\nStudents(student_id number, current_address_id number, permanent_address_id number, first_name text, middle_name text, last_name text, cell_mobile_number text, email_address text, ssn text, date_first_registered time, date_left time, other_student_details text; PRIMARY KEY(student_id); FK(current_address_id REFERENCES Addresses(address_id)); FK(permanent_address_id REFERENCES Addresses(address_id)))\nStudent_Enrolment(student_enrolment_id number, degree_program_id number, semester_id number, student_id number, other_details text; PRIMARY KEY(student_enrolment_id); FK(degree_program_id REFERENCES Degree_Programs(degree_program_id)); FK(semester_id REFERENCES Semesters(semester_id)); FK(student_id REFERENCES Students(student_id)))\nStudent_Enrolment_Courses(student_course_id number, course_id number, student_enrolment_id number; PRIMARY KEY(student_course_id); FK(course_id REFERENCES Courses(course_id)); FK(student_enrolment_id REFERENCES Student_Enrolment(student_enrolment_id)))\nTranscripts(transcript_id number, transcript_date time, other_details text; PRIMARY KEY(transcript_id))\nTranscript_Contents(student_course_id number, transcript_id number; FK(student_course_id REFERENCES Student_Enrolment_Courses(student_course_id)); FK(transcript_id REFERENCES Transcripts(transcript_id)))",
    "ground_truth": "SELECT first_name ,  middle_name ,  last_name FROM Students ORDER BY date_first_registered ASC LIMIT 1",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "order_limit",
    "difficulty": "Medium"
  },
  {
    "idx": 102,
    "query_type": "order_limit",
    "question": "Among the accounts who have loan validity more than 24 months, list out the accounts that have the lowest approved amount and have account opening date before 1997.",
    "db_schema": "account(account_id integer, district_id integer, frequency text, date date; PRIMARY KEY(account_id); FK(district_id REFERENCES district(district_id)))\ncard(card_id integer, disp_id integer, type text, issued date; PRIMARY KEY(card_id); FK(disp_id REFERENCES disp(disp_id)))\nclient(client_id integer, gender text, birth_date date, district_id integer; PRIMARY KEY(client_id); FK(district_id REFERENCES district(district_id)))\ndisp(disp_id integer, client_id integer, account_id integer, type text; PRIMARY KEY(disp_id); FK(client_id REFERENCES client(client_id)); FK(account_id REFERENCES account(account_id)))\ndistrict(district_id integer, A2 text, A3 text, A4 text, A5 text, A6 text, A7 text, A8 integer, A9 integer, A10 real, A11 integer, A12 real, A13 real, A14 integer, A15 integer, A16 integer; PRIMARY KEY(district_id))\nloan(loan_id integer, account_id integer, date date, amount integer, duration integer, payments real, status text; PRIMARY KEY(loan_id); FK(account_id REFERENCES account(account_id)))\norder(order_id integer, account_id integer, bank_to text, account_to integer, amount real, k_symbol text; PRIMARY KEY(order_id); FK(account_id REFERENCES account(account_id)))\ntrans(trans_id integer, account_id integer, date date, type text, operation text, amount integer, balance integer, k_symbol text, bank text, account integer; PRIMARY KEY(trans_id); FK(account_id REFERENCES account(account_id)))",
    "ground_truth": "SELECT T1.account_id FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T1.duration > 24 AND STRFTIME('%Y', T2.date) < '1997' ORDER BY T1.amount ASC LIMIT 1",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "order_limit",
    "difficulty": "Medium"
  },
  {
    "idx": 103,
    "query_type": "order_limit",
    "question": "Which race has the shortest actual finishing time? Please give the name and year.",
    "db_schema": "circuits(circuitId integer, circuitRef text, name text, location text, country text, lat real, lng real, alt integer, url text; PRIMARY KEY(circuitId))\nconstructors(constructorId integer, constructorRef text, name text, nationality text, url text; PRIMARY KEY(constructorId))\ndrivers(driverId integer, driverRef text, number integer, code text, forename text, surname text, dob date, nationality text, url text; PRIMARY KEY(driverId))\nseasons(year integer, url text; PRIMARY KEY(year))\nraces(raceId integer, year integer, round integer, circuitId integer, name text, date date, time text, url text; PRIMARY KEY(raceId); FK(year REFERENCES seasons(year)); FK(circuitId REFERENCES circuits(circuitId)))\nconstructorResults(constructorResultsId integer, raceId integer, constructorId integer, points real, status text; PRIMARY KEY(constructorResultsId); FK(raceId REFERENCES races(raceId)); FK(constructorId REFERENCES constructors(constructorId)))\nconstructorStandings(constructorStandingsId integer, raceId integer, constructorId integer, points real, position integer, positionText text, wins integer; PRIMARY KEY(constructorStandingsId); FK(raceId REFERENCES races(raceId)); FK(constructorId REFERENCES constructors(constructorId)))\ndriverStandings(driverStandingsId integer, raceId integer, driverId integer, points real, position integer, positionText text, wins integer; PRIMARY KEY(driverStandingsId); FK(raceId REFERENCES races(raceId)); FK(driverId REFERENCES drivers(driverId)))\nlapTimes(raceId integer, driverId integer, lap integer, position integer, time text, milliseconds integer; FK(raceId REFERENCES races(raceId)); FK(driverId REFERENCES drivers(driverId)))\npitStops(raceId integer, driverId integer, stop integer, lap integer, time text, duration text, milliseconds integer; FK(raceId REFERENCES races(raceId)); FK(driverId REFERENCES drivers(driverId)))\nqualifying(qualifyId integer, raceId integer, driverId integer, constructorId integer, number integer, position integer, q1 text, q2 text, q3 text; PRIMARY KEY(qualifyId); FK(raceId REFERENCES races(raceId)); FK(driverId REFERENCES drivers(driverId)); FK(constructorId REFERENCES constructors(constructorId)))\nstatus(statusId integer, status text; PRIMARY KEY(statusId))\nresults(resultId integer, raceId integer, driverId integer, constructorId integer, number integer, grid integer, position integer, positionText text, positionOrder integer, points real, laps integer, time text, milliseconds integer, fastestLap integer, rank integer, fastestLapTime text, fastestLapSpeed text, statusId integer; PRIMARY KEY(resultId); FK(raceId REFERENCES races(raceId)); FK(driverId REFERENCES drivers(driverId)); FK(constructorId REFERENCES constructors(constructorId)); FK(statusId REFERENCES status(statusId)))",
    "ground_truth": "SELECT T1.name, T1.year FROM races AS T1 INNER JOIN results AS T2 on T1.raceId = T2.raceId WHERE T2.milliseconds IS NOT NULL ORDER BY T2.milliseconds LIMIT 1",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "order_limit",
    "difficulty": "Medium"
  },
  {
    "idx": 104,
    "query_type": "null_handling",
    "question": "Please list the lowest three eligible free rates for students aged 5-17 in continuation schools.",
    "db_schema": "frpm(CDSCode text, Academic Year text, County Code text, District Code integer, School Code text, County Name text, District Name text, School Name text, District Type text, School Type text, Educational Option Type text, NSLP Provision Status text, Charter School (Y/N) integer, Charter School Number text, Charter Funding Type text, IRC integer, Low Grade text, High Grade text, Enrollment (K-12) real, Free Meal Count (K-12) real, Percent (%) Eligible Free (K-12) real, FRPM Count (K-12) real, Percent (%) Eligible FRPM (K-12) real, Enrollment (Ages 5-17) real, Free Meal Count (Ages 5-17) real, Percent (%) Eligible Free (Ages 5-17) real, FRPM Count (Ages 5-17) real, Percent (%) Eligible FRPM (Ages 5-17) real, 2013-14 CALPADS Fall 1 Certification Status integer; PRIMARY KEY(CDSCode); FK(CDSCode REFERENCES schools(CDSCode)))\nsatscores(cds text, rtype text, sname text, dname text, cname text, enroll12 integer, NumTstTakr integer, AvgScrRead integer, AvgScrMath integer, AvgScrWrite integer, NumGE1500 integer; PRIMARY KEY(cds); FK(cds REFERENCES schools(CDSCode)))\nschools(CDSCode text, NCESDist text, NCESSchool text, StatusType text, County text, District text, School text, Street text, StreetAbr text, City text, Zip text, State text, MailStreet text, MailStrAbr text, MailCity text, MailZip text, MailState text, Phone text, Ext text, Website text, OpenDate date, ClosedDate date, Charter integer, CharterNum text, FundingType text, DOC text, DOCType text, SOC text, SOCType text, EdOpsCode text, EdOpsName text, EILCode text, EILName text, GSoffered text, GSserved text, Virtual text, Magnet integer, Latitude real, Longitude real, AdmFName1 text, AdmLName1 text, AdmEmail1 text, AdmFName2 text, AdmLName2 text, AdmEmail2 text, AdmFName3 text, AdmLName3 text, AdmEmail3 text, LastUpdate date; PRIMARY KEY(CDSCode))",
    "ground_truth": "SELECT `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` FROM frpm WHERE `Educational Option Type` = 'Continuation School' AND `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` IS NOT NULL ORDER BY `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` ASC LIMIT 3",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "null_handling",
    "difficulty": "Easy"
  },
  {
    "idx": 105,
    "query_type": "null_handling",
    "question": "How many white bordered cards are powerful?",
    "db_schema": "cards(id integer, artist text, asciiName text, availability text, borderColor text, cardKingdomFoilId text, cardKingdomId text, colorIdentity text, colorIndicator text, colors text, convertedManaCost real, duelDeck text, edhrecRank integer, faceConvertedManaCost real, faceName text, flavorName text, flavorText text, frameEffects text, frameVersion text, hand text, hasAlternativeDeckLimit integer, hasContentWarning integer, hasFoil integer, hasNonFoil integer, isAlternative integer, isFullArt integer, isOnlineOnly integer, isOversized integer, isPromo integer, isReprint integer, isReserved integer, isStarter integer, isStorySpotlight integer, isTextless integer, isTimeshifted integer, keywords text, layout text, leadershipSkills text, life text, loyalty text, manaCost text, mcmId text, mcmMetaId text, mtgArenaId text, mtgjsonV4Id text, mtgoFoilId text, mtgoId text, multiverseId text, name text, number text, originalReleaseDate text, originalText text, originalType text, otherFaceIds text, power text, printings text, promoTypes text, purchaseUrls text, rarity text, scryfallId text, scryfallIllustrationId text, scryfallOracleId text, setCode text, side text, subtypes text, supertypes text, tcgplayerProductId text, text text, toughness text, type text, types text, uuid text, variations text, watermark text; PRIMARY KEY(id))\nforeign_data(id integer, flavorText text, language text, multiverseid integer, name text, text text, type text, uuid text; PRIMARY KEY(id); FK(uuid REFERENCES cards(uuid)))\nlegalities(id integer, format text, status text, uuid text; PRIMARY KEY(id); FK(uuid REFERENCES cards(uuid)))\nsets(id integer, baseSetSize integer, block text, booster text, code text, isFoilOnly integer, isForeignOnly integer, isNonFoilOnly integer, isOnlineOnly integer, isPartialPreview integer, keyruneCode text, mcmId integer, mcmIdExtras integer, mcmName text, mtgoCode text, name text, parentCode text, releaseDate date, tcgplayerGroupId integer, totalSetSize integer, type text; PRIMARY KEY(id))\nset_translations(id integer, language text, setCode text, translation text; PRIMARY KEY(id); FK(setCode REFERENCES sets(code)))\nrulings(id integer, date date, text text, uuid text; PRIMARY KEY(id); FK(uuid REFERENCES cards(uuid)))",
    "ground_truth": "SELECT COUNT(id) FROM cards WHERE borderColor = 'white' AND cardKingdomId IS NOT NULL AND cardKingdomFoilId IS NOT NULL",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "null_handling",
    "difficulty": "Medium"
  },
  {
    "idx": 106,
    "query_type": "null_handling",
    "question": "Did the set of cards with \"Angel of Mercy\" appear on Magic: The Gathering Online?",
    "db_schema": "cards(id integer, artist text, asciiName text, availability text, borderColor text, cardKingdomFoilId text, cardKingdomId text, colorIdentity text, colorIndicator text, colors text, convertedManaCost real, duelDeck text, edhrecRank integer, faceConvertedManaCost real, faceName text, flavorName text, flavorText text, frameEffects text, frameVersion text, hand text, hasAlternativeDeckLimit integer, hasContentWarning integer, hasFoil integer, hasNonFoil integer, isAlternative integer, isFullArt integer, isOnlineOnly integer, isOversized integer, isPromo integer, isReprint integer, isReserved integer, isStarter integer, isStorySpotlight integer, isTextless integer, isTimeshifted integer, keywords text, layout text, leadershipSkills text, life text, loyalty text, manaCost text, mcmId text, mcmMetaId text, mtgArenaId text, mtgjsonV4Id text, mtgoFoilId text, mtgoId text, multiverseId text, name text, number text, originalReleaseDate text, originalText text, originalType text, otherFaceIds text, power text, printings text, promoTypes text, purchaseUrls text, rarity text, scryfallId text, scryfallIllustrationId text, scryfallOracleId text, setCode text, side text, subtypes text, supertypes text, tcgplayerProductId text, text text, toughness text, type text, types text, uuid text, variations text, watermark text; PRIMARY KEY(id))\nforeign_data(id integer, flavorText text, language text, multiverseid integer, name text, text text, type text, uuid text; PRIMARY KEY(id); FK(uuid REFERENCES cards(uuid)))\nlegalities(id integer, format text, status text, uuid text; PRIMARY KEY(id); FK(uuid REFERENCES cards(uuid)))\nsets(id integer, baseSetSize integer, block text, booster text, code text, isFoilOnly integer, isForeignOnly integer, isNonFoilOnly integer, isOnlineOnly integer, isPartialPreview integer, keyruneCode text, mcmId integer, mcmIdExtras integer, mcmName text, mtgoCode text, name text, parentCode text, releaseDate date, tcgplayerGroupId integer, totalSetSize integer, type text; PRIMARY KEY(id))\nset_translations(id integer, language text, setCode text, translation text; PRIMARY KEY(id); FK(setCode REFERENCES sets(code)))\nrulings(id integer, date date, text text, uuid text; PRIMARY KEY(id); FK(uuid REFERENCES cards(uuid)))",
    "ground_truth": "SELECT IIF(T2.mtgoCode IS NOT NULL, 'YES', 'NO') FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Angel of Mercy'",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "null_handling",
    "difficulty": "Medium"
  },
  {
    "idx": 107,
    "query_type": "null_handling",
    "question": "Describe the display name of the parent ID for child post with the highest score.",
    "db_schema": "badges(Id integer, UserId integer, Name text, Date datetime; PRIMARY KEY(Id); FK(UserId REFERENCES users(Id)))\ncomments(Id integer, PostId integer, Score integer, Text text, CreationDate datetime, UserId integer, UserDisplayName text; PRIMARY KEY(Id); FK(PostId REFERENCES posts(Id)); FK(UserId REFERENCES users(Id)))\npostHistory(Id integer, PostHistoryTypeId integer, PostId integer, RevisionGUID text, CreationDate datetime, UserId integer, Text text, Comment text, UserDisplayName text; PRIMARY KEY(Id); FK(PostId REFERENCES posts(Id)); FK(UserId REFERENCES users(Id)))\npostLinks(Id integer, CreationDate datetime, PostId integer, RelatedPostId integer, LinkTypeId integer; PRIMARY KEY(Id); FK(PostId REFERENCES posts(Id)); FK(RelatedPostId REFERENCES posts(Id)))\nposts(Id integer, PostTypeId integer, AcceptedAnswerId integer, CreaionDate datetime, Score integer, ViewCount integer, Body text, OwnerUserId integer, LasActivityDate datetime, Title text, Tags text, AnswerCount integer, CommentCount integer, FavoriteCount integer, LastEditorUserId integer, LastEditDate datetime, CommunityOwnedDate datetime, ParentId integer, ClosedDate datetime, OwnerDisplayName text, LastEditorDisplayName text; PRIMARY KEY(Id); FK(OwnerUserId REFERENCES users(Id)); FK(LastEditorUserId REFERENCES users(Id)); FK(ParentId REFERENCES posts(Id)))\ntags(Id integer, TagName text, Count integer, ExcerptPostId integer, WikiPostId integer; PRIMARY KEY(Id); FK(ExcerptPostId REFERENCES posts(Id)))\nusers(Id integer, Reputation integer, CreationDate datetime, DisplayName text, LastAccessDate datetime, WebsiteUrl text, Location text, AboutMe text, Views integer, UpVotes integer, DownVotes integer, AccountId integer, Age integer, ProfileImageUrl text; PRIMARY KEY(Id))\nvotes(Id integer, PostId integer, VoteTypeId integer, CreationDate date, UserId integer, BountyAmount integer; PRIMARY KEY(Id); FK(PostId REFERENCES posts(Id)); FK(UserId REFERENCES users(Id)))",
    "ground_truth": "SELECT DisplayName FROM users WHERE Id = ( SELECT OwnerUserId FROM posts WHERE ParentId IS NOT NULL ORDER BY Score DESC LIMIT 1 )",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "null_handling",
    "difficulty": "Medium"
  },
  {
    "idx": 108,
    "query_type": "null_handling",
    "question": "What was the fastest lap speed among all drivers in the 2009 Spanish Grand Prix?",
    "db_schema": "circuits(circuitId integer, circuitRef text, name text, location text, country text, lat real, lng real, alt integer, url text; PRIMARY KEY(circuitId))\nconstructors(constructorId integer, constructorRef text, name text, nationality text, url text; PRIMARY KEY(constructorId))\ndrivers(driverId integer, driverRef text, number integer, code text, forename text, surname text, dob date, nationality text, url text; PRIMARY KEY(driverId))\nseasons(year integer, url text; PRIMARY KEY(year))\nraces(raceId integer, year integer, round integer, circuitId integer, name text, date date, time text, url text; PRIMARY KEY(raceId); FK(year REFERENCES seasons(year)); FK(circuitId REFERENCES circuits(circuitId)))\nconstructorResults(constructorResultsId integer, raceId integer, constructorId integer, points real, status text; PRIMARY KEY(constructorResultsId); FK(raceId REFERENCES races(raceId)); FK(constructorId REFERENCES constructors(constructorId)))\nconstructorStandings(constructorStandingsId integer, raceId integer, constructorId integer, points real, position integer, positionText text, wins integer; PRIMARY KEY(constructorStandingsId); FK(raceId REFERENCES races(raceId)); FK(constructorId REFERENCES constructors(constructorId)))\ndriverStandings(driverStandingsId integer, raceId integer, driverId integer, points real, position integer, positionText text, wins integer; PRIMARY KEY(driverStandingsId); FK(raceId REFERENCES races(raceId)); FK(driverId REFERENCES drivers(driverId)))\nlapTimes(raceId integer, driverId integer, lap integer, position integer, time text, milliseconds integer; FK(raceId REFERENCES races(raceId)); FK(driverId REFERENCES drivers(driverId)))\npitStops(raceId integer, driverId integer, stop integer, lap integer, time text, duration text, milliseconds integer; FK(raceId REFERENCES races(raceId)); FK(driverId REFERENCES drivers(driverId)))\nqualifying(qualifyId integer, raceId integer, driverId integer, constructorId integer, number integer, position integer, q1 text, q2 text, q3 text; PRIMARY KEY(qualifyId); FK(raceId REFERENCES races(raceId)); FK(driverId REFERENCES drivers(driverId)); FK(constructorId REFERENCES constructors(constructorId)))\nstatus(statusId integer, status text; PRIMARY KEY(statusId))\nresults(resultId integer, raceId integer, driverId integer, constructorId integer, number integer, grid integer, position integer, positionText text, positionOrder integer, points real, laps integer, time text, milliseconds integer, fastestLap integer, rank integer, fastestLapTime text, fastestLapSpeed text, statusId integer; PRIMARY KEY(resultId); FK(raceId REFERENCES races(raceId)); FK(driverId REFERENCES drivers(driverId)); FK(constructorId REFERENCES constructors(constructorId)); FK(statusId REFERENCES status(statusId)))",
    "ground_truth": "SELECT T2.fastestLapSpeed FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.name = 'Spanish Grand Prix' AND T1.year = 2009 AND T2.fastestLapSpeed IS NOT NULL ORDER BY T2.fastestLapSpeed DESC LIMIT 1",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "null_handling",
    "difficulty": "Medium"
  },
  {
    "idx": 109,
    "query_type": "null_handling",
    "question": "What is full name of the racer who ranked 1st in the 3rd qualifying race held in the Marina Bay Street Circuit in 2008?",
    "db_schema": "circuits(circuitId integer, circuitRef text, name text, location text, country text, lat real, lng real, alt integer, url text; PRIMARY KEY(circuitId))\nconstructors(constructorId integer, constructorRef text, name text, nationality text, url text; PRIMARY KEY(constructorId))\ndrivers(driverId integer, driverRef text, number integer, code text, forename text, surname text, dob date, nationality text, url text; PRIMARY KEY(driverId))\nseasons(year integer, url text; PRIMARY KEY(year))\nraces(raceId integer, year integer, round integer, circuitId integer, name text, date date, time text, url text; PRIMARY KEY(raceId); FK(year REFERENCES seasons(year)); FK(circuitId REFERENCES circuits(circuitId)))\nconstructorResults(constructorResultsId integer, raceId integer, constructorId integer, points real, status text; PRIMARY KEY(constructorResultsId); FK(raceId REFERENCES races(raceId)); FK(constructorId REFERENCES constructors(constructorId)))\nconstructorStandings(constructorStandingsId integer, raceId integer, constructorId integer, points real, position integer, positionText text, wins integer; PRIMARY KEY(constructorStandingsId); FK(raceId REFERENCES races(raceId)); FK(constructorId REFERENCES constructors(constructorId)))\ndriverStandings(driverStandingsId integer, raceId integer, driverId integer, points real, position integer, positionText text, wins integer; PRIMARY KEY(driverStandingsId); FK(raceId REFERENCES races(raceId)); FK(driverId REFERENCES drivers(driverId)))\nlapTimes(raceId integer, driverId integer, lap integer, position integer, time text, milliseconds integer; FK(raceId REFERENCES races(raceId)); FK(driverId REFERENCES drivers(driverId)))\npitStops(raceId integer, driverId integer, stop integer, lap integer, time text, duration text, milliseconds integer; FK(raceId REFERENCES races(raceId)); FK(driverId REFERENCES drivers(driverId)))\nqualifying(qualifyId integer, raceId integer, driverId integer, constructorId integer, number integer, position integer, q1 text, q2 text, q3 text; PRIMARY KEY(qualifyId); FK(raceId REFERENCES races(raceId)); FK(driverId REFERENCES drivers(driverId)); FK(constructorId REFERENCES constructors(constructorId)))\nstatus(statusId integer, status text; PRIMARY KEY(statusId))\nresults(resultId integer, raceId integer, driverId integer, constructorId integer, number integer, grid integer, position integer, positionText text, positionOrder integer, points real, laps integer, time text, milliseconds integer, fastestLap integer, rank integer, fastestLapTime text, fastestLapSpeed text, statusId integer; PRIMARY KEY(resultId); FK(raceId REFERENCES races(raceId)); FK(driverId REFERENCES drivers(driverId)); FK(constructorId REFERENCES constructors(constructorId)); FK(statusId REFERENCES status(statusId)))",
    "ground_truth": "SELECT T2.forename, T2.surname FROM qualifying AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId INNER JOIN races AS T3 ON T1.raceid = T3.raceid WHERE q3 IS NOT NULL AND T3.year = 2008 AND T3.circuitId IN ( SELECT circuitId FROM circuits WHERE name = 'Marina Bay Street Circuit' ) ORDER BY CAST(SUBSTR(q3, 1, INSTR(q3, ':') - 1) AS INTEGER) * 60 + CAST(SUBSTR(q3, INSTR(q3, ':') + 1, INSTR(q3, '.') - INSTR(q3, ':') - 1) AS REAL) + CAST(SUBSTR(q3, INSTR(q3, '.') + 1) AS REAL) / 1000 ASC LIMIT 1",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "null_handling",
    "difficulty": "Hard"
  },
  {
    "idx": 110,
    "query_type": "string_semantics",
    "question": "What are the login names and passwords of the customers whose phone number have the prefix '+12'?",
    "db_schema": "/* Schema not available */",
    "ground_truth": "SELECT login_name ,  login_password FROM Customers WHERE phone_number LIKE '+12%'",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "string_semantics",
    "difficulty": "Easy"
  },
  {
    "idx": 111,
    "query_type": "string_semantics",
    "question": "What is the name of every sailor whose name contains the letter e?",
    "db_schema": "/* Schema not available */",
    "ground_truth": "SELECT name FROM Sailors WHERE name LIKE '%e%'",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "string_semantics",
    "difficulty": "Easy"
  },
  {
    "idx": 112,
    "query_type": "string_semantics",
    "question": "Return the names of langauges that contain the substring \"ish\".",
    "db_schema": "/* Schema not available */",
    "ground_truth": "SELECT name FROM languages WHERE name LIKE \"%ish%\"",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "string_semantics",
    "difficulty": "Easy"
  },
  {
    "idx": 113,
    "query_type": "string_semantics",
    "question": "Find the role, street, city and state of the professionals living in a city that contains the substring 'West'.",
    "db_schema": "Breeds(breed_code text, breed_name text; PRIMARY KEY(breed_code))\nCharges(charge_id number, charge_type text, charge_amount number; PRIMARY KEY(charge_id))\nSizes(size_code text, size_description text; PRIMARY KEY(size_code))\nTreatment_Types(treatment_type_code text, treatment_type_description text; PRIMARY KEY(treatment_type_code))\nOwners(owner_id number, first_name text, last_name text, street text, city text, state text, zip_code text, email_address text, home_phone text, cell_number text; PRIMARY KEY(owner_id))\nDogs(dog_id number, owner_id number, abandoned_yn text, breed_code text, size_code text, name text, age text, date_of_birth time, gender text, weight text, date_arrived time, date_adopted time, date_departed time; PRIMARY KEY(dog_id); FK(owner_id REFERENCES Owners(owner_id)); FK(owner_id REFERENCES Owners(owner_id)); FK(breed_code REFERENCES Breeds(breed_code)); FK(size_code REFERENCES Sizes(size_code)))\nProfessionals(professional_id number, role_code text, first_name text, street text, city text, state text, zip_code text, last_name text, email_address text, home_phone text, cell_number text; PRIMARY KEY(professional_id))\nTreatments(treatment_id number, dog_id number, professional_id number, treatment_type_code text, date_of_treatment time, cost_of_treatment number; PRIMARY KEY(treatment_id); FK(dog_id REFERENCES Dogs(dog_id)); FK(professional_id REFERENCES Professionals(professional_id)); FK(treatment_type_code REFERENCES Treatment_Types(treatment_type_code)))",
    "ground_truth": "SELECT role_code ,  street ,  city ,  state FROM professionals WHERE city LIKE '%West%'",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "string_semantics",
    "difficulty": "Medium"
  },
  {
    "idx": 114,
    "query_type": "string_semantics",
    "question": "Who was the player that got the lap time of 0:01:27 in the race No. 161? Show his introduction website.",
    "db_schema": "circuits(circuitId integer, circuitRef text, name text, location text, country text, lat real, lng real, alt integer, url text; PRIMARY KEY(circuitId))\nconstructors(constructorId integer, constructorRef text, name text, nationality text, url text; PRIMARY KEY(constructorId))\ndrivers(driverId integer, driverRef text, number integer, code text, forename text, surname text, dob date, nationality text, url text; PRIMARY KEY(driverId))\nseasons(year integer, url text; PRIMARY KEY(year))\nraces(raceId integer, year integer, round integer, circuitId integer, name text, date date, time text, url text; PRIMARY KEY(raceId); FK(year REFERENCES seasons(year)); FK(circuitId REFERENCES circuits(circuitId)))\nconstructorResults(constructorResultsId integer, raceId integer, constructorId integer, points real, status text; PRIMARY KEY(constructorResultsId); FK(raceId REFERENCES races(raceId)); FK(constructorId REFERENCES constructors(constructorId)))\nconstructorStandings(constructorStandingsId integer, raceId integer, constructorId integer, points real, position integer, positionText text, wins integer; PRIMARY KEY(constructorStandingsId); FK(raceId REFERENCES races(raceId)); FK(constructorId REFERENCES constructors(constructorId)))\ndriverStandings(driverStandingsId integer, raceId integer, driverId integer, points real, position integer, positionText text, wins integer; PRIMARY KEY(driverStandingsId); FK(raceId REFERENCES races(raceId)); FK(driverId REFERENCES drivers(driverId)))\nlapTimes(raceId integer, driverId integer, lap integer, position integer, time text, milliseconds integer; FK(raceId REFERENCES races(raceId)); FK(driverId REFERENCES drivers(driverId)))\npitStops(raceId integer, driverId integer, stop integer, lap integer, time text, duration text, milliseconds integer; FK(raceId REFERENCES races(raceId)); FK(driverId REFERENCES drivers(driverId)))\nqualifying(qualifyId integer, raceId integer, driverId integer, constructorId integer, number integer, position integer, q1 text, q2 text, q3 text; PRIMARY KEY(qualifyId); FK(raceId REFERENCES races(raceId)); FK(driverId REFERENCES drivers(driverId)); FK(constructorId REFERENCES constructors(constructorId)))\nstatus(statusId integer, status text; PRIMARY KEY(statusId))\nresults(resultId integer, raceId integer, driverId integer, constructorId integer, number integer, grid integer, position integer, positionText text, positionOrder integer, points real, laps integer, time text, milliseconds integer, fastestLap integer, rank integer, fastestLapTime text, fastestLapSpeed text, statusId integer; PRIMARY KEY(resultId); FK(raceId REFERENCES races(raceId)); FK(driverId REFERENCES drivers(driverId)); FK(constructorId REFERENCES constructors(constructorId)); FK(statusId REFERENCES status(statusId)))",
    "ground_truth": "SELECT DISTINCT T2.forename, T2.surname, T2.url FROM lapTimes AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 161 AND T1.time LIKE '1:27%'",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "string_semantics",
    "difficulty": "Medium"
  },
  {
    "idx": 115,
    "query_type": "exists_equivalence",
    "question": "List the superheroes from Marvel Comics who have the super power of 'Super Strength'.",
    "db_schema": "alignment(id integer, alignment text; PRIMARY KEY(id))\nattribute(id integer, attribute_name text; PRIMARY KEY(id))\ncolour(id integer, colour text; PRIMARY KEY(id))\ngender(id integer, gender text; PRIMARY KEY(id))\npublisher(id integer, publisher_name text; PRIMARY KEY(id))\nrace(id integer, race text; PRIMARY KEY(id))\nsuperhero(id integer, superhero_name text, full_name text, gender_id integer, eye_colour_id integer, hair_colour_id integer, skin_colour_id integer, race_id integer, publisher_id integer, alignment_id integer, height_cm integer, weight_kg integer; PRIMARY KEY(id); FK(gender_id REFERENCES gender(id)); FK(eye_colour_id REFERENCES colour(id)); FK(hair_colour_id REFERENCES colour(id)); FK(skin_colour_id REFERENCES colour(id)); FK(race_id REFERENCES race(id)); FK(publisher_id REFERENCES publisher(id)); FK(alignment_id REFERENCES alignment(id)))\nhero_attribute(hero_id integer, attribute_id integer, attribute_value integer; FK(hero_id REFERENCES superhero(id)); FK(attribute_id REFERENCES attribute(id)))\nsuperpower(id integer, power_name text; PRIMARY KEY(id))\nhero_power(hero_id integer, power_id integer; FK(hero_id REFERENCES superhero(id)); FK(power_id REFERENCES superpower(id)))",
    "ground_truth": "SELECT superhero_name FROM superhero AS T1 WHERE EXISTS (SELECT 1 FROM hero_power AS T2 INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Super Strength' AND T1.id = T2.hero_id)AND EXISTS (SELECT 1 FROM publisher AS T4 WHERE T4.publisher_name = 'Marvel Comics' AND T1.publisher_id = T4.id)",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "exists_equivalence",
    "difficulty": "Hard"
  },
  {
    "idx": 116,
    "query_type": "exists_equivalence",
    "question": "Which superheroes have a durability attribute value of less than 50?",
    "db_schema": "alignment(id integer, alignment text; PRIMARY KEY(id))\nattribute(id integer, attribute_name text; PRIMARY KEY(id))\ncolour(id integer, colour text; PRIMARY KEY(id))\ngender(id integer, gender text; PRIMARY KEY(id))\npublisher(id integer, publisher_name text; PRIMARY KEY(id))\nrace(id integer, race text; PRIMARY KEY(id))\nsuperhero(id integer, superhero_name text, full_name text, gender_id integer, eye_colour_id integer, hair_colour_id integer, skin_colour_id integer, race_id integer, publisher_id integer, alignment_id integer, height_cm integer, weight_kg integer; PRIMARY KEY(id); FK(gender_id REFERENCES gender(id)); FK(eye_colour_id REFERENCES colour(id)); FK(hair_colour_id REFERENCES colour(id)); FK(skin_colour_id REFERENCES colour(id)); FK(race_id REFERENCES race(id)); FK(publisher_id REFERENCES publisher(id)); FK(alignment_id REFERENCES alignment(id)))\nhero_attribute(hero_id integer, attribute_id integer, attribute_value integer; FK(hero_id REFERENCES superhero(id)); FK(attribute_id REFERENCES attribute(id)))\nsuperpower(id integer, power_name text; PRIMARY KEY(id))\nhero_power(hero_id integer, power_id integer; FK(hero_id REFERENCES superhero(id)); FK(power_id REFERENCES superpower(id)))",
    "ground_truth": "SELECT superhero_name FROM superhero AS T1 WHERE EXISTS (SELECT 1 FROM hero_attribute AS T2 INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Durability' AND T2.attribute_value < 50 AND T1.id = T2.hero_id)",
    "base_sql": "ERROR: 'NoneType' object is not callable",
    "base_correct": false,
    "finetuned_sql": "ERROR: 'NoneType' object is not callable",
    "finetuned_correct": false,
    "gemini_sql": "ERROR: No Gemini API available",
    "gemini_correct": false,
    "gemini_model": "Gemini (unavailable)",
    "query_type_name": "exists_equivalence",
    "difficulty": "Hard"
  }
]