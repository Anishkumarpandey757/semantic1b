# Comprehensive Test Dataset
# Generated: 2025-12-28 08:55:07
# Source: bird_spider_5k_balanced.jsonl
# Total samples: 109
# Query types: 14
#
# Format: Each line is a JSON object with:
#   - question: Natural language question
#   - SQL: Ground truth SQL query
#   - db_schema: Database schema (compressed format)
#   - db_id: Database identifier
#   - query_type: Query type key
#   - query_type_name: Human-readable query type
#   - category: Query category
#   - difficulty: Estimated difficulty (Easy/Medium/Hard)
#   - source_dataset: Origin dataset (BIRD+Spider)
#
{"question": "List in alphabetic order all different amenities.", "SQL": "SELECT amenity_name FROM dorm_amenity ORDER BY amenity_name", "db_schema": "Student(StuID number, LName text, Fname text, Age number, Sex text, Major number, Advisor number, city_code text; PRIMARY KEY(StuID))\nDorm(dormid number, dorm_name text, student_capacity number, gender text)\nDorm_amenity(amenid number, amenity_name text)\nHas_amenity(dormid number, amenid number; FK(dormid REFERENCES Dorm(dormid)); FK(amenid REFERENCES Dorm_amenity(amenid)))\nLives_in(stuid number, dormid number, room_number number; FK(stuid REFERENCES Student(StuID)); FK(dormid REFERENCES Dorm(dormid)))", "db_id": "dorm_1", "source": "spider", "query_type": "simple_select", "query_type_name": "Simple SELECT", "category": "Basic Queries", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.366562"}
{"question": "What are the distinct classes that races can have?", "SQL": "SELECT DISTINCT CLASS FROM race", "db_schema": "race(Race_ID number, Name text, Class text, Date text, Track_ID text; PRIMARY KEY(Race_ID); FK(Track_ID REFERENCES track(Track_ID)))\ntrack(Track_ID number, Name text, Location text, Seating number, Year_Opened number; PRIMARY KEY(Track_ID))", "db_id": "race_track", "source": "spider", "query_type": "simple_select", "query_type_name": "Simple SELECT", "category": "Basic Queries", "difficulty": "Easy", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.366562"}
{"question": "List the names and locations of all stations ordered by their yearly entry exit and interchange amounts.", "SQL": "SELECT name ,  LOCATION FROM station ORDER BY Annual_entry_exit ,  Annual_interchanges", "db_schema": "station(Station_ID number, Name text, Annual_entry_exit number, Annual_interchanges number, Total_Passengers number, Location text, Main_Services text, Number_of_Platforms number; PRIMARY KEY(Station_ID))\ntrain(Train_ID number, Name text, Time text, Service text; PRIMARY KEY(Train_ID))\ntrain_station(Train_ID number, Station_ID number; PRIMARY KEY(Train_ID); FK(Train_ID REFERENCES train(Train_ID)); FK(Station_ID REFERENCES station(Station_ID)))", "db_id": "train_station", "source": "spider", "query_type": "simple_select", "query_type_name": "Simple SELECT", "category": "Basic Queries", "difficulty": "Easy", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.367570"}
{"question": "List all the event names by year from the most recent to the oldest.", "SQL": "SELECT name FROM event ORDER BY YEAR DESC", "db_schema": "swimmer(ID number, name text, Nationality text, meter_100 number, meter_200 text, meter_300 text, meter_400 text, meter_500 text, meter_600 text, meter_700 text, Time text; PRIMARY KEY(ID))\nstadium(ID number, name text, Capacity number, City text, Country text, Opening_year number; PRIMARY KEY(ID))\nevent(ID number, Name text, Stadium_ID number, Year text; PRIMARY KEY(ID); FK(Stadium_ID REFERENCES stadium(ID)))\nrecord(ID number, Result text, Swimmer_ID number, Event_ID number; PRIMARY KEY(Swimmer_ID); FK(Swimmer_ID REFERENCES swimmer(ID)); FK(Event_ID REFERENCES event(ID)))", "db_id": "swimming", "source": "spider", "query_type": "simple_select", "query_type_name": "Simple SELECT", "category": "Basic Queries", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.367570"}
{"question": "What is the name and salary of all employees in order of salary?", "SQL": "SELECT name ,  salary FROM Employee ORDER BY salary", "db_schema": "flight(flno number, origin text, destination text, distance number, departure_date time, arrival_date time, price number, aid number; PRIMARY KEY(flno); FK(aid REFERENCES aircraft(aid)))\naircraft(aid number, name text, distance number; PRIMARY KEY(aid))\nemployee(eid number, name text, salary number; PRIMARY KEY(eid))\ncertificate(eid number, aid number; PRIMARY KEY(eid); FK(eid REFERENCES employee(eid)); FK(aid REFERENCES aircraft(aid)))", "db_id": "flight_1", "source": "spider", "query_type": "simple_select", "query_type_name": "Simple SELECT", "category": "Basic Queries", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.367570"}
{"question": "Return the duration of the actor with the greatest age.", "SQL": "SELECT Duration FROM actor ORDER BY Age DESC LIMIT 1", "db_schema": "musical(Musical_ID number, Name text, Year number, Award text, Category text, Nominee text, Result text; PRIMARY KEY(Musical_ID))\nactor(Actor_ID number, Name text, Musical_ID number, Character text, Duration text, age number; PRIMARY KEY(Actor_ID); FK(Musical_ID REFERENCES actor(Actor_ID)))", "db_id": "musical", "source": "spider", "query_type": "simple_select", "query_type_name": "Simple SELECT", "category": "Basic Queries", "difficulty": "Easy", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.367570"}
{"question": "what are the order id and customer id of the oldest order?", "SQL": "SELECT order_id ,  customer_id FROM orders ORDER BY date_order_placed LIMIT 1", "db_schema": "Customers(customer_id number, customer_name text, customer_details text; PRIMARY KEY(customer_id))\nInvoices(invoice_number number, invoice_date time, invoice_details text; PRIMARY KEY(invoice_number))\nOrders(order_id number, customer_id number, order_status text, date_order_placed time, order_details text; PRIMARY KEY(order_id); FK(customer_id REFERENCES Customers(customer_id)))\nProducts(product_id number, product_name text, product_details text; PRIMARY KEY(product_id))\nOrder_Items(order_item_id number, product_id number, order_id number, order_item_status text, order_item_details text; PRIMARY KEY(order_item_id); FK(product_id REFERENCES Products(product_id)); FK(order_id REFERENCES Orders(order_id)))\nShipments(shipment_id number, order_id number, invoice_number number, shipment_tracking_number text, shipment_date time, other_shipment_details text; PRIMARY KEY(shipment_id); FK(order_id REFERENCES Orders(order_id)); FK(invoice_number REFERENCES Invoices(invoice_number)))\nShipment_Items(shipment_id number, order_item_id number; FK(shipment_id REFERENCES Shipments(shipment_id)); FK(order_item_id REFERENCES Order_Items(order_item_id)))", "db_id": "tracking_orders", "source": "spider", "query_type": "simple_select", "query_type_name": "Simple SELECT", "category": "Basic Queries", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.367570"}
{"question": "What are all the players who played in match season, sorted by college in ascending alphabetical order?", "SQL": "SELECT player FROM match_season ORDER BY College ASC", "db_schema": "country(Country_id number, Country_name text, Capital text, Official_native_language text; PRIMARY KEY(Country_id))\nteam(Team_id number, Name text; PRIMARY KEY(Team_id))\nmatch_season(Season number, Player text, Position text, Country number, Team number, Draft_Pick_Number number, Draft_Class text, College text; PRIMARY KEY(Season); FK(Country REFERENCES country(Country_id)); FK(Team REFERENCES team(Team_id)))\nplayer(Player_ID number, Player text, Years_Played text, Total_WL text, Singles_WL text, Doubles_WL text, Team number; PRIMARY KEY(Player_ID); FK(Team REFERENCES team(Team_id)))", "db_id": "match_season", "source": "spider", "query_type": "simple_select", "query_type_name": "Simple SELECT", "category": "Basic Queries", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.367570"}
{"question": "What are the names of the technicians by ascending order of age?", "SQL": "SELECT Name FROM technician ORDER BY Age ASC", "db_schema": "repair(repair_ID number, name text, Launch_Date text, Notes text; PRIMARY KEY(repair_ID))\nmachine(Machine_ID number, Making_Year number, Class text, Team text, Machine_series text, value_points number, quality_rank number; PRIMARY KEY(Machine_ID))\ntechnician(technician_id number, Name text, Team text, Starting_Year number, Age number; PRIMARY KEY(technician_id))\nrepair_assignment(technician_id number, repair_ID number, Machine_ID number; PRIMARY KEY(technician_id); FK(technician_id REFERENCES technician(technician_id)); FK(repair_ID REFERENCES repair(repair_ID)); FK(Machine_ID REFERENCES machine(Machine_ID)))", "db_id": "machine_repair", "source": "spider", "query_type": "simple_select", "query_type_name": "Simple SELECT", "category": "Basic Queries", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.367570"}
{"question": "What is the starting year for the oldest technician?", "SQL": "SELECT Starting_Year FROM technician ORDER BY Age DESC LIMIT 1", "db_schema": "repair(repair_ID number, name text, Launch_Date text, Notes text; PRIMARY KEY(repair_ID))\nmachine(Machine_ID number, Making_Year number, Class text, Team text, Machine_series text, value_points number, quality_rank number; PRIMARY KEY(Machine_ID))\ntechnician(technician_id number, Name text, Team text, Starting_Year number, Age number; PRIMARY KEY(technician_id))\nrepair_assignment(technician_id number, repair_ID number, Machine_ID number; PRIMARY KEY(technician_id); FK(technician_id REFERENCES technician(technician_id)); FK(repair_ID REFERENCES repair(repair_ID)); FK(Machine_ID REFERENCES machine(Machine_ID)))", "db_id": "machine_repair", "source": "spider", "query_type": "simple_select", "query_type_name": "Simple SELECT", "category": "Basic Queries", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.367570"}
{"question": "What are the names of wrestlers days held less than 100?", "SQL": "SELECT Name FROM wrestler WHERE Days_held  <  100", "db_schema": "wrestler(Wrestler_ID number, Name text, Reign text, Days_held text, Location text, Event text; PRIMARY KEY(Wrestler_ID))\nElimination(Elimination_ID text, Wrestler_ID text, Team text, Eliminated_By text, Elimination_Move text, Time text; PRIMARY KEY(Elimination_ID); FK(Wrestler_ID REFERENCES wrestler(Wrestler_ID)))", "db_id": "wrestler", "source": "spider", "query_type": "single_table_where", "query_type_name": "Single-table WHERE", "category": "Basic Queries", "difficulty": "Easy", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.371570"}
{"question": "What is the document type code for document type \"Paper\"?", "SQL": "SELECT document_type_code FROM Ref_document_types WHERE document_type_name  =  \"Paper\"", "db_schema": "Ref_Document_Types(Document_Type_Code text, Document_Type_Name text, Document_Type_Description text; PRIMARY KEY(Document_Type_Code))\nRef_Calendar(Calendar_Date time, Day_Number number; PRIMARY KEY(Calendar_Date))\nRef_Locations(Location_Code text, Location_Name text, Location_Description text; PRIMARY KEY(Location_Code))\nRoles(Role_Code text, Role_Name text, Role_Description text; PRIMARY KEY(Role_Code))\nAll_Documents(Document_ID number, Date_Stored time, Document_Type_Code text, Document_Name text, Document_Description text, Other_Details text; PRIMARY KEY(Document_ID); FK(Date_Stored REFERENCES Ref_Calendar(Calendar_Date)); FK(Document_Type_Code REFERENCES Ref_Document_Types(Document_Type_Code)))\nEmployees(Employee_ID number, Role_Code text, Employee_Name text, Gender_MFU text, Date_of_Birth time, Other_Details text; PRIMARY KEY(Employee_ID); FK(Role_Code REFERENCES Roles(Role_Code)))\nDocument_Locations(Document_ID number, Location_Code text, Date_in_Location_From time, Date_in_Locaton_To time; PRIMARY KEY(Document_ID); FK(Document_ID REFERENCES All_Documents(Document_ID)); FK(Location_Code REFERENCES Ref_Locations(Location_Code)); FK(Date_in_Location_From REFERENCES Ref_Calendar(Calendar_Date)); FK(Date_in_Locaton_To REFERENCES Ref_Calendar(Calendar_Date)))\nDocuments_to_be_Destroyed(Document_ID number, Destruction_Authorised_by_Employee_ID number, Destroyed_by_Employee_ID number, Planned_Destruction_Date time, Actual_Destruction_Date time, Other_Details text; PRIMARY KEY(Document_ID); FK(Document_ID REFERENCES All_Documents(Document_ID)); FK(Destruction_Authorised_by_Employee_ID REFERENCES Employees(Employee_ID)); FK(Destroyed_by_Employee_ID REFERENCES Employees(Employee_ID)); FK(Planned_Destruction_Date REFERENCES Ref_Calendar(Calendar_Date)); FK(Actual_Destruction_Date REFERENCES Ref_Calendar(Calendar_Date)))", "db_id": "cre_Doc_Tracking_DB", "source": "spider", "query_type": "single_table_where", "query_type_name": "Single-table WHERE", "category": "Basic Queries", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.372571"}
{"question": "What are the types of the ships that have both shiips with tonnage more than 6000 and those with tonnage less than 4000?", "SQL": "SELECT TYPE FROM ship WHERE Tonnage  >  6000 INTERSECT SELECT TYPE FROM ship WHERE Tonnage  <  4000", "db_schema": "mission(Mission_ID number, Ship_ID number, Code text, Launched_Year number, Location text, Speed_knots number, Fate text; PRIMARY KEY(Mission_ID); FK(Ship_ID REFERENCES ship(Ship_ID)))\nship(Ship_ID number, Name text, Type text, Nationality text, Tonnage number; PRIMARY KEY(Ship_ID))", "db_id": "ship_mission", "source": "spider", "query_type": "single_table_where", "query_type_name": "Single-table WHERE", "category": "Basic Queries", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.372571"}
{"question": "Among episodes aired in 2009, which episode has received the worst response based on the rating.", "SQL": "SELECT episode_id FROM Episode WHERE air_date LIKE '2009%' ORDER BY rating LIMIT 1;", "db_schema": "Award(award_id INTEGER, organization TEXT, year INTEGER, award_category TEXT, award TEXT, person TEXT, role TEXT, episode_id TEXT, season TEXT, song TEXT, result TEXT; PRIMARY KEY(award_id); FK episode_id -> Episode(episode_id); FK person -> Person(name))\nCharacter_Award(award_id INTEGER, character TEXT; FK award_id -> Award(award_id))\nCredit(episode_id TEXT, category TEXT, person TEXT, role TEXT, credited TEXT; FK person -> Person(name); FK episode_id -> Episode(episode_id))\nEpisode(episode_id TEXT, season INTEGER, episode INTEGER, number_in_series INTEGER, title TEXT, summary TEXT, air_date TEXT, episode_image TEXT, rating REAL, votes INTEGER; PRIMARY KEY(episode_id))\nKeyword(episode_id TEXT, keyword TEXT; PRIMARY KEY(episode_id, keyword); FK episode_id -> Episode(episode_id))\nPerson(name TEXT, birthdate TEXT, birth_name TEXT, birth_place TEXT, birth_region TEXT, birth_country TEXT, height_meters REAL, nickname TEXT; PRIMARY KEY(name))\nVote(episode_id TEXT, stars INTEGER, votes INTEGER, percent REAL; FK episode_id -> Episode(episode_id))", "source": "bird", "db_id": "bird_db_0388", "query_type": "single_table_where", "query_type_name": "Single-table WHERE", "category": "Basic Queries", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.372571"}
{"question": "Find the description of the claim status \"Open\".", "SQL": "SELECT claim_status_description FROM claims_processing_stages WHERE claim_status_name  =  \"Open\"", "db_schema": "Customers(Customer_ID number, Customer_Details text; PRIMARY KEY(Customer_ID))\nStaff(Staff_ID number, Staff_Details text; PRIMARY KEY(Staff_ID))\nPolicies(Policy_ID number, Customer_ID number, Policy_Type_Code text, Start_Date time, End_Date time; PRIMARY KEY(Policy_ID); FK(Customer_ID REFERENCES Customers(Customer_ID)))\nClaim_Headers(Claim_Header_ID number, Claim_Status_Code text, Claim_Type_Code text, Policy_ID number, Date_of_Claim time, Date_of_Settlement time, Amount_Claimed number, Amount_Piad number; PRIMARY KEY(Claim_Header_ID); FK(Policy_ID REFERENCES Policies(Policy_ID)))\nClaims_Documents(Claim_ID number, Document_Type_Code text, Created_by_Staff_ID number, Created_Date number; PRIMARY KEY(Claim_ID); FK(Claim_ID REFERENCES Claim_Headers(Claim_Header_ID)); FK(Created_by_Staff_ID REFERENCES Staff(Staff_ID)))\nClaims_Processing_Stages(Claim_Stage_ID number, Next_Claim_Stage_ID number, Claim_Status_Name text, Claim_Status_Description text; PRIMARY KEY(Claim_Stage_ID))\nClaims_Processing(Claim_Processing_ID number, Claim_ID number, Claim_Outcome_Code text, Claim_Stage_ID number, Staff_ID number; PRIMARY KEY(Claim_Processing_ID); FK(Claim_ID REFERENCES Claim_Headers(Claim_Header_ID)); FK(Staff_ID REFERENCES Staff(Staff_ID)))", "db_id": "insurance_and_eClaims", "source": "spider", "query_type": "single_table_where", "query_type_name": "Single-table WHERE", "category": "Basic Queries", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.372571"}
{"question": "Find the name of the campuses that is in Northridge, Los Angeles or in San Francisco, San Francisco.", "SQL": "SELECT campus FROM campuses WHERE LOCATION  =  \"Northridge\" AND county  =  \"Los Angeles\" UNION SELECT campus FROM campuses WHERE LOCATION  =  \"San Francisco\" AND county  =  \"San Francisco\"", "db_schema": "Campuses(Id number, Campus text, Location text, County text, Year number; PRIMARY KEY(Id))\ncsu_fees(Campus number, Year number, CampusFee number; PRIMARY KEY(Campus); FK(Campus REFERENCES Campuses(Id)))\ndegrees(Year number, Campus number, Degrees number; PRIMARY KEY(Year); FK(Campus REFERENCES Campuses(Id)))\ndiscipline_enrollments(Campus number, Discipline number, Year number, Undergraduate number, Graduate number; PRIMARY KEY(Campus); FK(Campus REFERENCES Campuses(Id)))\nenrollments(Campus number, Year number, TotalEnrollment_AY number, FTE_AY number; PRIMARY KEY(Campus); FK(Campus REFERENCES Campuses(Id)))\nfaculty(Campus number, Year number, Faculty number; FK(Campus REFERENCES Campuses(Id)))", "db_id": "csu_1", "source": "spider", "query_type": "single_table_where", "query_type_name": "Single-table WHERE", "category": "Basic Queries", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.372571"}
{"question": "What is the origin and destination for all flights whose price is higher than 300?", "SQL": "SELECT origin ,  destination FROM Flight WHERE price  >  300", "db_schema": "flight(flno number, origin text, destination text, distance number, departure_date time, arrival_date time, price number, aid number; PRIMARY KEY(flno); FK(aid REFERENCES aircraft(aid)))\naircraft(aid number, name text, distance number; PRIMARY KEY(aid))\nemployee(eid number, name text, salary number; PRIMARY KEY(eid))\ncertificate(eid number, aid number; PRIMARY KEY(eid); FK(eid REFERENCES employee(eid)); FK(aid REFERENCES aircraft(aid)))", "db_id": "flight_1", "source": "spider", "query_type": "single_table_where", "query_type_name": "Single-table WHERE", "category": "Basic Queries", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.372571"}
{"question": "Show the phone, room, and building for the faculty named Jerry Prince.", "SQL": "SELECT phone ,  room ,  building FROM Faculty WHERE Fname  =  \"Jerry\" AND Lname  =  \"Prince\"", "db_schema": "Activity(actid number, activity_name text; PRIMARY KEY(actid))\nParticipates_in(stuid number, actid number; FK(stuid REFERENCES Student(StuID)); FK(actid REFERENCES Activity(actid)))\nFaculty_Participates_in(FacID number, actid number; FK(FacID REFERENCES Faculty(FacID)); FK(actid REFERENCES Activity(actid)))\nStudent(StuID number, LName text, Fname text, Age number, Sex text, Major number, Advisor number, city_code text; PRIMARY KEY(StuID))\nFaculty(FacID number, Lname text, Fname text, Rank text, Sex text, Phone number, Room text, Building text; PRIMARY KEY(FacID))", "db_id": "activity_1", "source": "spider", "query_type": "single_table_where", "query_type_name": "Single-table WHERE", "category": "Basic Queries", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.372571"}
{"question": "List the name and residence for players whose occupation is not \"Researcher\".", "SQL": "SELECT Player_name ,  residence FROM player WHERE Occupation != \"Researcher\"", "db_schema": "player(Player_ID number, Sponsor_name text, Player_name text, Gender text, Residence text, Occupation text, Votes number, Rank text; PRIMARY KEY(Player_ID))\nclub(Club_ID number, Club_name text, Region text, Start_year number; PRIMARY KEY(Club_ID))\ncoach(Coach_ID number, Coach_name text, Gender text, Club_ID number, Rank number; PRIMARY KEY(Coach_ID); FK(Club_ID REFERENCES club(Club_ID)))\nplayer_coach(Player_ID number, Coach_ID number, Starting_year number; PRIMARY KEY(Player_ID); FK(Player_ID REFERENCES player(Player_ID)); FK(Coach_ID REFERENCES coach(Coach_ID)))\nmatch_result(Rank number, Club_ID number, Gold number, Big_Silver number, Small_Silver number, Bronze number, Points number; PRIMARY KEY(Rank); FK(Club_ID REFERENCES club(Club_ID)))", "db_id": "riding_club", "source": "spider", "query_type": "single_table_where", "query_type_name": "Single-table WHERE", "category": "Basic Queries", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.372571"}
{"question": "Find the last names of faculties in building Barton in alphabetic order.", "SQL": "SELECT Lname FROM FACULTY WHERE Building  =  \"Barton\" ORDER BY Lname", "db_schema": "Student(StuID number, LName text, Fname text, Age number, Sex text, Major number, Advisor number, city_code text; PRIMARY KEY(StuID))\nFaculty(FacID number, Lname text, Fname text, Rank text, Sex text, Phone number, Room text, Building text; PRIMARY KEY(FacID))\nDepartment(DNO number, Division text, DName text, Room text, Building text, DPhone number; PRIMARY KEY(DNO))\nMember_of(FacID number, DNO number, Appt_Type text; FK(FacID REFERENCES Faculty(FacID)); FK(DNO REFERENCES Department(DNO)))\nCourse(CID text, CName text, Credits number, Instructor number, Days text, Hours text, DNO number; PRIMARY KEY(CID); FK(Instructor REFERENCES Faculty(FacID)); FK(DNO REFERENCES Department(DNO)))\nMinor_in(StuID number, DNO number; FK(StuID REFERENCES Student(StuID)); FK(DNO REFERENCES Department(DNO)))\nEnrolled_in(StuID number, CID text, Grade text; FK(StuID REFERENCES Student(StuID)); FK(CID REFERENCES Course(CID)); FK(Grade REFERENCES Gradeconversion(lettergrade)))\nGradeconversion(lettergrade text, gradepoint number; PRIMARY KEY(lettergrade))", "db_id": "college_3", "source": "spider", "query_type": "single_table_where", "query_type_name": "Single-table WHERE", "category": "Basic Queries", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.372571"}
{"question": "Please list the IDs of the top 3 professors that teaches the most courses.", "SQL": "SELECT T1.p_id FROM taughtBy AS T1 INNER JOIN person AS T2 ON T1.p_id = T2.p_id WHERE T2.professor = 1 GROUP BY T1.p_id ORDER BY COUNT(*) DESC LIMIT 3", "db_schema": "advisedBy(p_id INTEGER, p_id_dummy INTEGER; PRIMARY KEY(p_id, p_id_dummy); FK p_id -> person(p_id); FK p_id_dummy -> person(p_id))\ncourse(course_id INTEGER, courseLevel TEXT; PRIMARY KEY(course_id))\nperson(p_id INTEGER, professor INTEGER, student INTEGER, hasPosition TEXT, inPhase TEXT, yearsInProgram TEXT; PRIMARY KEY(p_id))\ntaughtBy(course_id INTEGER, p_id INTEGER; PRIMARY KEY(course_id, p_id); FK course_id -> course(course_id); FK p_id -> person(p_id))", "source": "bird", "db_id": "bird_db_1034", "query_type": "join_aggregation", "query_type_name": "2-table JOIN + aggregation", "category": "Joins & Aggregation", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.379487"}
{"question": "What are the names and ids of all stations that have more than 14 bikes available on average or had bikes installed in December?", "SQL": "SELECT T1.name ,  T1.id FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(T2.bikes_available)  >  14 UNION SELECT name ,  id FROM station WHERE installation_date LIKE \"12/%\"", "db_schema": "station(id number, name text, lat number, long number, dock_count number, city text, installation_date text; PRIMARY KEY(id))\nstatus(station_id number, bikes_available number, docks_available number, time text; FK(station_id REFERENCES station(id)))\ntrip(id number, duration number, start_date text, start_station_name text, start_station_id number, end_date text, end_station_name text, end_station_id number, bike_id number, subscription_type text, zip_code number; PRIMARY KEY(id))\nweather(date text, max_temperature_f number, mean_temperature_f number, min_temperature_f number, max_dew_point_f number, mean_dew_point_f number, min_dew_point_f number, max_humidity number, mean_humidity number, min_humidity number, max_sea_level_pressure_inches number, mean_sea_level_pressure_inches number, min_sea_level_pressure_inches number, max_visibility_miles number, mean_visibility_miles number, min_visibility_miles number, max_wind_Speed_mph number, mean_wind_speed_mph number, max_gust_speed_mph number, precipitation_inches number, cloud_cover number, events text, wind_dir_degrees number, zip_code number)", "db_id": "bike_1", "source": "spider", "query_type": "join_aggregation", "query_type_name": "2-table JOIN + aggregation", "category": "Joins & Aggregation", "difficulty": "Hard", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.379487"}
{"question": "Among the establishments that paid a 500 fine, what is the percentage of restaurants?", "SQL": "SELECT CAST(COUNT(CASE WHEN T1.facility_type = 'Restaurant' THEN T1.license_no END) AS REAL) * 100 / COUNT(T1.facility_type) FROM establishment AS T1 INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no INNER JOIN violation AS T3 ON T2.inspection_id = T3.inspection_id WHERE T3.fine = 500", "db_schema": "employee(employee_id INTEGER, first_name TEXT, last_name TEXT, address TEXT, city TEXT, state TEXT, zip INTEGER, phone TEXT, title TEXT, salary INTEGER, supervisor INTEGER; PRIMARY KEY(employee_id); FK supervisor -> employee(employee_id))\nestablishment(license_no INTEGER, dba_name TEXT, aka_name TEXT, facility_type TEXT, risk_level INTEGER, address TEXT, city TEXT, state TEXT, zip INTEGER, latitude REAL, longitude REAL, ward INTEGER; PRIMARY KEY(license_no))\ninspection(inspection_id INTEGER, inspection_date DATE, inspection_type TEXT, results TEXT, employee_id INTEGER, license_no INTEGER, followup_to INTEGER; PRIMARY KEY(inspection_id); FK followup_to -> inspection(inspection_id); FK license_no -> establishment(license_no); FK employee_id -> employee(employee_id))\ninspection_point(point_id INTEGER, Description TEXT, category TEXT, code TEXT, fine INTEGER, point_level TEXT; PRIMARY KEY(point_id))\nviolation(inspection_id INTEGER, point_id INTEGER, fine INTEGER, inspector_comment TEXT; PRIMARY KEY(inspection_id, point_id); FK point_id -> inspection_point(point_id); FK inspection_id -> inspection(inspection_id))", "source": "bird", "db_id": "bird_db_1344", "query_type": "join_aggregation", "query_type_name": "2-table JOIN + aggregation", "category": "Joins & Aggregation", "difficulty": "Hard", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.379487"}
{"question": "How many distinct kinds of injuries happened after season 2010?", "SQL": "SELECT count(DISTINCT T1.injury) FROM injury_accident AS T1 JOIN game AS T2 ON T1.game_id  =  T2.id WHERE T2.season  >  2010", "db_schema": "stadium(id number, name text, Home_Games number, Average_Attendance number, Total_Attendance number, Capacity_Percentage number; PRIMARY KEY(id))\ngame(stadium_id number, id number, Season number, Date text, Home_team text, Away_team text, Score text, Competition text; PRIMARY KEY(id); FK(stadium_id REFERENCES stadium(id)))\ninjury_accident(game_id number, id number, Player text, Injury text, Number_of_matches text, Source text; PRIMARY KEY(id); FK(game_id REFERENCES game(id)))", "db_id": "game_injury", "source": "spider", "query_type": "join_aggregation", "query_type_name": "2-table JOIN + aggregation", "category": "Joins & Aggregation", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.379487"}
{"question": "Which employee has created the least order and please indicates the employee's title?", "SQL": "SELECT T1.Title FROM Employees AS T1 INNER JOIN Orders AS T2 ON T1.EmployeeID = T2.EmployeeID GROUP BY T1.Title ORDER BY COUNT(T2.OrderID) LIMIT 1", "db_schema": "Categories(CategoryID INTEGER, CategoryName TEXT, Description TEXT; PRIMARY KEY(CategoryID))\nCustomers(CustomerID INTEGER, CustomerName TEXT, ContactName TEXT, Address TEXT, City TEXT, PostalCode TEXT, Country TEXT; PRIMARY KEY(CustomerID))\nEmployees(EmployeeID INTEGER, LastName TEXT, FirstName TEXT, BirthDate DATE, Photo TEXT, Notes TEXT; PRIMARY KEY(EmployeeID))\nOrderDetails(OrderDetailID INTEGER, OrderID INTEGER, ProductID INTEGER, Quantity INTEGER; PRIMARY KEY(OrderDetailID); FK ProductID -> Products(ProductID); FK OrderID -> Orders(OrderID))\nOrders(OrderID INTEGER, CustomerID INTEGER, EmployeeID INTEGER, OrderDate DATETIME, ShipperID INTEGER; PRIMARY KEY(OrderID); FK ShipperID -> Shippers(ShipperID); FK CustomerID -> Customers(CustomerID); FK EmployeeID -> Employees(EmployeeID))\nProducts(ProductID INTEGER, ProductName TEXT, SupplierID INTEGER, CategoryID INTEGER, Unit TEXT, Price REAL; PRIMARY KEY(ProductID); FK SupplierID -> Suppliers(SupplierID); FK CategoryID -> Categories(CategoryID))\nShippers(ShipperID INTEGER, ShipperName TEXT, Phone TEXT; PRIMARY KEY(ShipperID))\nSuppliers(SupplierID INTEGER, SupplierName TEXT, ContactName TEXT, Address TEXT, City TEXT, PostalCode TEXT, Country TEXT, Phone TEXT; PRIMARY KEY(SupplierID))\nsqlite_sequence(name TEXT, seq TEXT)", "source": "bird", "db_id": "bird_db_1073", "query_type": "join_aggregation", "query_type_name": "2-table JOIN + aggregation", "category": "Joins & Aggregation", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.379487"}
{"question": "Find the total amount claimed in the most recently created document.", "SQL": "SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT 1)", "db_schema": "Customers(Customer_ID number, Customer_Details text; PRIMARY KEY(Customer_ID))\nStaff(Staff_ID number, Staff_Details text; PRIMARY KEY(Staff_ID))\nPolicies(Policy_ID number, Customer_ID number, Policy_Type_Code text, Start_Date time, End_Date time; PRIMARY KEY(Policy_ID); FK(Customer_ID REFERENCES Customers(Customer_ID)))\nClaim_Headers(Claim_Header_ID number, Claim_Status_Code text, Claim_Type_Code text, Policy_ID number, Date_of_Claim time, Date_of_Settlement time, Amount_Claimed number, Amount_Piad number; PRIMARY KEY(Claim_Header_ID); FK(Policy_ID REFERENCES Policies(Policy_ID)))\nClaims_Documents(Claim_ID number, Document_Type_Code text, Created_by_Staff_ID number, Created_Date number; PRIMARY KEY(Claim_ID); FK(Claim_ID REFERENCES Claim_Headers(Claim_Header_ID)); FK(Created_by_Staff_ID REFERENCES Staff(Staff_ID)))\nClaims_Processing_Stages(Claim_Stage_ID number, Next_Claim_Stage_ID number, Claim_Status_Name text, Claim_Status_Description text; PRIMARY KEY(Claim_Stage_ID))\nClaims_Processing(Claim_Processing_ID number, Claim_ID number, Claim_Outcome_Code text, Claim_Stage_ID number, Staff_ID number; PRIMARY KEY(Claim_Processing_ID); FK(Claim_ID REFERENCES Claim_Headers(Claim_Header_ID)); FK(Staff_ID REFERENCES Staff(Staff_ID)))", "db_id": "insurance_and_eClaims", "source": "spider", "query_type": "join_aggregation", "query_type_name": "2-table JOIN + aggregation", "category": "Joins & Aggregation", "difficulty": "Hard", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.379487"}
{"question": "Whare the names, friends, and ages of all people who are older than the average age of a person?", "SQL": "SELECT DISTINCT T2.name ,  T2.friend ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  >  (SELECT avg(age) FROM person)", "db_schema": "Person(name text, age number, city text, gender text, job text; PRIMARY KEY(name))\nPersonFriend(name text, friend text, year number; FK(name REFERENCES Person(name)); FK(friend REFERENCES Person(name)))", "db_id": "network_2", "source": "spider", "query_type": "join_aggregation", "query_type_name": "2-table JOIN + aggregation", "category": "Joins & Aggregation", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.379487"}
{"question": "Find the customer who started a policy most recently.", "SQL": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)", "db_schema": "Customers(Customer_ID number, Customer_Details text; PRIMARY KEY(Customer_ID))\nStaff(Staff_ID number, Staff_Details text; PRIMARY KEY(Staff_ID))\nPolicies(Policy_ID number, Customer_ID number, Policy_Type_Code text, Start_Date time, End_Date time; PRIMARY KEY(Policy_ID); FK(Customer_ID REFERENCES Customers(Customer_ID)))\nClaim_Headers(Claim_Header_ID number, Claim_Status_Code text, Claim_Type_Code text, Policy_ID number, Date_of_Claim time, Date_of_Settlement time, Amount_Claimed number, Amount_Piad number; PRIMARY KEY(Claim_Header_ID); FK(Policy_ID REFERENCES Policies(Policy_ID)))\nClaims_Documents(Claim_ID number, Document_Type_Code text, Created_by_Staff_ID number, Created_Date number; PRIMARY KEY(Claim_ID); FK(Claim_ID REFERENCES Claim_Headers(Claim_Header_ID)); FK(Created_by_Staff_ID REFERENCES Staff(Staff_ID)))\nClaims_Processing_Stages(Claim_Stage_ID number, Next_Claim_Stage_ID number, Claim_Status_Name text, Claim_Status_Description text; PRIMARY KEY(Claim_Stage_ID))\nClaims_Processing(Claim_Processing_ID number, Claim_ID number, Claim_Outcome_Code text, Claim_Stage_ID number, Staff_ID number; PRIMARY KEY(Claim_Processing_ID); FK(Claim_ID REFERENCES Claim_Headers(Claim_Header_ID)); FK(Staff_ID REFERENCES Staff(Staff_ID)))", "db_id": "insurance_and_eClaims", "source": "spider", "query_type": "join_aggregation", "query_type_name": "2-table JOIN + aggregation", "category": "Joins & Aggregation", "difficulty": "Hard", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.379487"}
{"question": "How many lesson does customer with first name Ray took?", "SQL": "SELECT count(*) FROM Lessons AS T1 JOIN Customers AS T2 ON T1.customer_id  = T2.customer_id WHERE T2.first_name = \"Ray\"", "db_schema": "Addresses(address_id number, line_1_number_building text, city text, zip_postcode text, state_province_county text, country text; PRIMARY KEY(address_id))\nStaff(staff_id number, staff_address_id number, nickname text, first_name text, middle_name text, last_name text, date_of_birth time, date_joined_staff time, date_left_staff time; PRIMARY KEY(staff_id); FK(staff_address_id REFERENCES Addresses(address_id)))\nVehicles(vehicle_id number, vehicle_details text; PRIMARY KEY(vehicle_id))\nCustomers(customer_id number, customer_address_id number, customer_status_code text, date_became_customer time, date_of_birth time, first_name text, last_name text, amount_outstanding number, email_address text, phone_number text, cell_mobile_phone_number text; PRIMARY KEY(customer_id); FK(customer_address_id REFERENCES Addresses(address_id)))\nCustomer_Payments(customer_id number, datetime_payment time, payment_method_code text, amount_payment number; PRIMARY KEY(customer_id); FK(customer_id REFERENCES Customers(customer_id)))\nLessons(lesson_id number, customer_id number, lesson_status_code text, staff_id number, vehicle_id number, lesson_date time, lesson_time text, price number; PRIMARY KEY(lesson_id); FK(customer_id REFERENCES Customers(customer_id)); FK(staff_id REFERENCES Staff(staff_id)); FK(vehicle_id REFERENCES Vehicles(vehicle_id)))", "db_id": "driving_school", "source": "spider", "query_type": "join_aggregation", "query_type_name": "2-table JOIN + aggregation", "category": "Joins & Aggregation", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.379487"}
{"question": "Which country has the most restaurants with Italian food?", "SQL": "SELECT T2.county FROM generalinfo AS T1 INNER JOIN geographic AS T2 ON T1.city = T2.city WHERE T1.food_type = 'Italian' GROUP BY T2.county ORDER BY COUNT(T1.id_restaurant) DESC LIMIT 1", "db_schema": "generalinfo(id_restaurant INTEGER, label TEXT, food_type TEXT, city TEXT, review REAL; PRIMARY KEY(id_restaurant); FK city -> geographic(city))\ngeographic(city TEXT, county TEXT, region TEXT; PRIMARY KEY(city))\nlocation(id_restaurant INTEGER, street_num INTEGER, street_name TEXT, city TEXT; PRIMARY KEY(id_restaurant); FK id_restaurant -> generalinfo(id_restaurant); FK city -> geographic(city))", "source": "bird", "db_id": "bird_db_1369", "query_type": "join_aggregation", "query_type_name": "2-table JOIN + aggregation", "category": "Joins & Aggregation", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.379487"}
{"question": "What were the cities in which John Aalberg competed?", "SQL": "SELECT T4.city_name FROM person AS T1 INNER JOIN games_competitor AS T2 ON T1.id = T2.person_id INNER JOIN games_city AS T3 ON T2.games_id = T3.games_id INNER JOIN city AS T4 ON T3.city_id = T4.id WHERE T1.full_name = 'John Aalberg'", "db_schema": "city(id INTEGER, city_name TEXT; PRIMARY KEY(id))\ncompetitor_event(event_id INTEGER, competitor_id INTEGER, medal_id INTEGER; FK medal_id -> medal(id); FK event_id -> event(id); FK competitor_id -> games_competitor(id))\nevent(id INTEGER, sport_id INTEGER, event_name TEXT; PRIMARY KEY(id); FK sport_id -> sport(id))\ngames(id INTEGER, games_year INTEGER, games_name TEXT, season TEXT; PRIMARY KEY(id))\ngames_city(games_id INTEGER, city_id INTEGER; FK games_id -> games(id); FK city_id -> city(id))\ngames_competitor(id INTEGER, games_id INTEGER, person_id INTEGER, age INTEGER; PRIMARY KEY(id); FK person_id -> person(id); FK games_id -> games(id))\nmedal(id INTEGER, medal_name TEXT; PRIMARY KEY(id))\nnoc_region(id INTEGER, noc TEXT, region_name TEXT; PRIMARY KEY(id))\nperson(id INTEGER, full_name TEXT, gender TEXT, height INTEGER, weight INTEGER; PRIMARY KEY(id))\nperson_region(person_id INTEGER, region_id INTEGER; FK region_id -> noc_region(id); FK person_id -> person(id))\nsport(id INTEGER, sport_name TEXT; PRIMARY KEY(id))", "source": "bird", "db_id": "bird_db_0346", "query_type": "multi_join", "query_type_name": "3+ table JOINs", "category": "Complex Joins", "difficulty": "Hard", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.381487"}
{"question": "Calculate the average number of disabled female students enrolled in UCI.", "SQL": "SELECT CAST(SUM(IIF(T1.school = 'uci' AND T4.name IS NULL, 1, 0)) AS REAL) / COUNT(T1.name) FROM enrolled AS T1 INNER JOIN disabled AS T2 ON T1.name = T2.name INNER JOIN person AS T3 ON T1.name = T3.name LEFT JOIN male AS T4 ON T3.name = T4.name", "db_schema": "bool(name TEXT; PRIMARY KEY(name))\ndisabled(name TEXT; PRIMARY KEY(name); FK name -> person(name))\nenlist(name TEXT, organ TEXT; FK name -> person(name))\nenrolled(name TEXT, school TEXT, month INTEGER; PRIMARY KEY(name, school); FK name -> person(name))\nfiled_for_bankrupcy(name TEXT; PRIMARY KEY(name); FK name -> person(name))\nlongest_absense_from_school(name TEXT, month INTEGER; PRIMARY KEY(name); FK name -> person(name))\nmale(name TEXT; PRIMARY KEY(name); FK name -> person(name))\nno_payment_due(name TEXT, bool TEXT; PRIMARY KEY(name); FK bool -> bool(name); FK name -> person(name))\nperson(name TEXT; PRIMARY KEY(name))\nunemployed(name TEXT; PRIMARY KEY(name); FK name -> person(name))", "source": "bird", "db_id": "bird_db_1726", "query_type": "multi_join", "query_type_name": "3+ table JOINs", "category": "Complex Joins", "difficulty": "Hard", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.381487"}
{"question": "List the email of customers that bought the book titled Switch on the Night.", "SQL": "SELECT T4.email FROM book AS T1 INNER JOIN order_line AS T2 ON T1.book_id = T2.book_id INNER JOIN cust_order AS T3 ON T3.order_id = T2.order_id INNER JOIN customer AS T4 ON T4.customer_id = T3.customer_id WHERE T1.title = 'Switch on the Night'", "db_schema": "address(address_id INTEGER, street_number TEXT, street_name TEXT, city TEXT, country_id INTEGER; PRIMARY KEY(address_id); FK country_id -> country(country_id))\naddress_status(status_id INTEGER, address_status TEXT; PRIMARY KEY(status_id))\nauthor(author_id INTEGER, author_name TEXT; PRIMARY KEY(author_id))\nbook(book_id INTEGER, title TEXT, isbn13 TEXT, language_id INTEGER, num_pages INTEGER, publication_date DATE, publisher_id INTEGER; PRIMARY KEY(book_id); FK publisher_id -> publisher(publisher_id); FK language_id -> book_language(language_id))\nbook_author(book_id INTEGER, author_id INTEGER; PRIMARY KEY(book_id, author_id); FK book_id -> book(book_id); FK author_id -> author(author_id))\nbook_language(language_id INTEGER, language_code TEXT, language_name TEXT; PRIMARY KEY(language_id))\ncountry(country_id INTEGER, country_name TEXT; PRIMARY KEY(country_id))\ncust_order(order_id INTEGER, order_date DATETIME, customer_id INTEGER, shipping_method_id INTEGER, dest_address_id INTEGER; PRIMARY KEY(order_id); FK dest_address_id -> address(None); FK shipping_method_id -> shipping_method(None); FK customer_id -> customer(None))\ncustomer(customer_id INTEGER, first_name TEXT, last_name TEXT, email TEXT; PRIMARY KEY(customer_id))\ncustomer_address(customer_id INTEGER, address_id INTEGER, status_id INTEGER; PRIMARY KEY(customer_id, address_id); FK customer_id -> customer(customer_id); FK address_id -> address(address_id))\norder_history(history_id INTEGER, order_id INTEGER, status_id INTEGER, status_date DATETIME; PRIMARY KEY(history_id); FK status_id -> order_status(None); FK order_id -> cust_order(None))\norder_line(line_id INTEGER, order_id INTEGER, book_id INTEGER, price REAL; PRIMARY KEY(line_id); FK book_id -> book(None); FK order_id -> cust_order(None))\norder_status(status_id INTEGER, status_value TEXT; PRIMARY KEY(status_id))\npublisher(publisher_id INTEGER, publisher_name TEXT; PRIMARY KEY(publisher_id))\nshipping_method(method_id INTEGER, method_name TEXT, cost REAL; PRIMARY KEY(method_id))\nsqlite_sequence(name TEXT, seq TEXT)", "source": "bird", "db_id": "bird_db_0504", "query_type": "multi_join", "query_type_name": "3+ table JOINs", "category": "Complex Joins", "difficulty": "Hard", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.381487"}
{"question": "Which Shakespeare story with character ID 324 has description of 'this friend of Caesar'?", "SQL": "SELECT T1.Title FROM works AS T1 INNER JOIN chapters AS T2 ON T1.id = T2.work_id INNER JOIN paragraphs AS T3 ON T2.id = T3.chapter_id INNER JOIN characters AS T4 ON T3.character_id = T4.id WHERE T2.id = '324' AND T2.Description = 'friend to Caesar'", "db_schema": "chapters(id INTEGER, Act INTEGER, Scene INTEGER, Description TEXT, work_id INTEGER; PRIMARY KEY(id); FK work_id -> works(None))\ncharacters(id INTEGER, CharName TEXT, Abbrev TEXT, Description TEXT; PRIMARY KEY(id))\nparagraphs(id INTEGER, ParagraphNum INTEGER, PlainText TEXT, character_id INTEGER, chapter_id INTEGER; PRIMARY KEY(id); FK chapter_id -> chapters(None); FK character_id -> characters(None))\nsqlite_sequence(name TEXT, seq TEXT)\nworks(id INTEGER, Title TEXT, LongTitle TEXT, Date INTEGER, GenreType TEXT; PRIMARY KEY(id))", "source": "bird", "db_id": "bird_db_0971", "query_type": "multi_join", "query_type_name": "3+ table JOINs", "category": "Complex Joins", "difficulty": "Hard", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.381487"}
{"question": "How many credits is the course that the student with the last name Smithson took, and what is its description?", "SQL": "SELECT T4.crs_description ,  T4.crs_credit FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T3.stu_num  =  T2.stu_num JOIN course AS T4 ON T4.crs_code  =  T1.crs_code WHERE T3.stu_lname  =  'Smithson'", "db_schema": "CLASS(CLASS_CODE text, CRS_CODE text, CLASS_SECTION text, CLASS_TIME text, CLASS_ROOM text, PROF_NUM number; PRIMARY KEY(CLASS_CODE); FK(CRS_CODE REFERENCES COURSE(CRS_CODE)); FK(PROF_NUM REFERENCES EMPLOYEE(EMP_NUM)))\nCOURSE(CRS_CODE text, DEPT_CODE text, CRS_DESCRIPTION text, CRS_CREDIT number; PRIMARY KEY(CRS_CODE); FK(DEPT_CODE REFERENCES DEPARTMENT(DEPT_CODE)))\nDEPARTMENT(DEPT_CODE text, DEPT_NAME text, SCHOOL_CODE text, EMP_NUM number, DEPT_ADDRESS text, DEPT_EXTENSION text; PRIMARY KEY(DEPT_CODE); FK(EMP_NUM REFERENCES EMPLOYEE(EMP_NUM)))\nEMPLOYEE(EMP_NUM number, EMP_LNAME text, EMP_FNAME text, EMP_INITIAL text, EMP_JOBCODE text, EMP_HIREDATE time, EMP_DOB time; PRIMARY KEY(EMP_NUM))\nENROLL(CLASS_CODE text, STU_NUM number, ENROLL_GRADE text; FK(CLASS_CODE REFERENCES CLASS(CLASS_CODE)); FK(STU_NUM REFERENCES STUDENT(STU_NUM)))\nPROFESSOR(EMP_NUM number, DEPT_CODE text, PROF_OFFICE text, PROF_EXTENSION text, PROF_HIGH_DEGREE text; FK(EMP_NUM REFERENCES EMPLOYEE(EMP_NUM)); FK(DEPT_CODE REFERENCES DEPARTMENT(DEPT_CODE)))\nSTUDENT(STU_NUM number, STU_LNAME text, STU_FNAME text, STU_INIT text, STU_DOB time, STU_HRS number, STU_CLASS text, STU_GPA number, STU_TRANSFER number, DEPT_CODE text, STU_PHONE text, PROF_NUM number; PRIMARY KEY(STU_NUM); FK(DEPT_CODE REFERENCES DEPARTMENT(DEPT_CODE)))", "db_id": "college_1", "source": "spider", "query_type": "multi_join", "query_type_name": "3+ table JOINs", "category": "Complex Joins", "difficulty": "Hard", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.381487"}
{"question": "Which mountain is the highest in an independent country?", "SQL": "SELECT T4.Name FROM country AS T1 INNER JOIN politics AS T2 ON T1.Code = T2.Country INNER JOIN geo_mountain AS T3 ON T3.Country = T2.Country INNER JOIN mountain AS T4 ON T4.Name = T3.Mountain WHERE T2.Independence IS NOT NULL ORDER BY T4.Height DESC LIMIT 1", "db_schema": "borders(Country1 TEXT, Country2 TEXT, Length REAL; PRIMARY KEY(Country1, Country2); FK Country2 -> country(None); FK Country1 -> country(None))\ncity(Name TEXT, Country TEXT, Province TEXT, Population INTEGER, Longitude REAL, Latitude REAL; PRIMARY KEY(Name, Province); FK Province -> province(None); FK Country -> province(None); FK Country -> country(None))\ncontinent(Name TEXT, Area REAL; PRIMARY KEY(Name))\ncountry(Name TEXT, Code TEXT, Capital TEXT, Province TEXT, Area REAL, Population INTEGER; PRIMARY KEY(Code))\ndesert(Name TEXT, Area REAL, Longitude REAL, Latitude REAL; PRIMARY KEY(Name))\neconomy(Country TEXT, GDP REAL, Agriculture REAL, Service REAL, Industry REAL, Inflation REAL; PRIMARY KEY(Country); FK Country -> country(None))\nencompasses(Country TEXT, Continent TEXT, Percentage REAL; PRIMARY KEY(Country, Continent); FK Continent -> continent(None); FK Country -> country(None))\nethnicGroup(Country TEXT, Name TEXT, Percentage REAL; PRIMARY KEY(Country, Name); FK Country -> country(None))\ngeo_desert(Desert TEXT, Country TEXT, Province TEXT; PRIMARY KEY(Desert, Country, Province); FK Province -> province(None); FK Country -> province(None); FK Country -> country(None); FK Desert -> desert(None))\ngeo_estuary(River TEXT, Country TEXT, Province TEXT; PRIMARY KEY(River, Country, Province); FK Province -> province(None); FK Country -> province(None); FK Country -> country(None); FK River -> river(None))\ngeo_island(Island TEXT, Country TEXT, Province TEXT; PRIMARY KEY(Island, Country, Province); FK Province -> province(None); FK Country -> province(None); FK Country -> country(None); FK Island -> island(None))\ngeo_lake(Lake TEXT, Country TEXT, Province TEXT; PRIMARY KEY(Lake, Country, Province); FK Province -> province(None); FK Country -> province(None); FK Country -> country(None); FK Lake -> lake(None))\ngeo_mountain(Mountain TEXT, Country TEXT, Province TEXT; PRIMARY KEY(Mountain, Country, Province); FK Province -> province(None); FK Country -> province(None); FK Country -> country(None); FK Mountain -> mountain(None))\ngeo_river(River TEXT, Country TEXT, Province TEXT; PRIMARY KEY(River, Country, Province); FK Province -> province(None); FK Country -> province(None); FK Country -> country(None); FK River -> river(None))\ngeo_sea(Sea TEXT, Country TEXT, Province TEXT; PRIMARY KEY(Sea, Country, Province); FK Province -> province(None); FK Country -> province(None); FK Country -> country(None); FK Sea -> sea(None))\ngeo_source(River TEXT, Country TEXT, Province TEXT; PRIMARY KEY(River, Country, Province); FK Province -> province(None); FK Country -> province(None); FK Country -> country(None); FK River -> river(None))\nisMember(Country TEXT, Organization TEXT, Type TEXT; PRIMARY KEY(Country, Organization); FK Organization -> organization(None); FK Country -> country(None))\nisland(Name TEXT, Islands TEXT, Area REAL, Height REAL, Type TEXT, Longitude REAL, Latitude REAL; PRIMARY KEY(Name))\nislandIn(Island TEXT, Sea TEXT, Lake TEXT, River TEXT; FK River -> river(None); FK Lake -> lake(None); FK Sea -> sea(None); FK Island -> island(None))\nlake(Name TEXT, Area REAL, Depth REAL, Altitude REAL, Type TEXT, River TEXT, Longitude REAL, Latitude REAL; PRIMARY KEY(Name))\nlanguage(Country TEXT, Name TEXT, Percentage REAL; PRIMARY KEY(Country, Name); FK Country -> country(None))\nlocated(City TEXT, Province TEXT, Country TEXT, River TEXT, Lake TEXT, Sea TEXT; FK Province -> province(None); FK Country -> province(None); FK City -> city(None); FK Province -> city(None); FK Sea -> sea(None); FK Lake -> lake(None); FK River -> river(None); FK Country -> country(None))\nlocatedOn(City TEXT, Province TEXT, Country TEXT, Island TEXT; PRIMARY KEY(City, Province, Country, Island); FK Province -> province(None); FK Country -> province(None); FK City -> city(None); FK Province -> city(None); FK Island -> island(None); FK Country -> country(None))\nmergesWith(Sea1 TEXT, Sea2 TEXT; PRIMARY KEY(Sea1, Sea2); FK Sea2 -> sea(None); FK Sea1 -> sea(None))\nmountain(Name TEXT, Mountains TEXT, Height REAL, Type TEXT, Longitude REAL, Latitude REAL; PRIMARY KEY(Name))\nmountainOnIsland(Mountain TEXT, Island TEXT; PRIMARY KEY(Mountain, Island); FK Island -> island(None); FK Mountain -> mountain(None))\norganization(Abbreviation TEXT, Name TEXT, City TEXT, Country TEXT, Province TEXT, Established DATE; PRIMARY KEY(Abbreviation); FK Province -> province(None); FK Country -> province(None); FK City -> city(None); FK Province -> city(None); FK Country -> country(None))\npolitics(Country TEXT, Independence DATE, Dependent TEXT, Government TEXT; PRIMARY KEY(Country); FK Dependent -> country(None); FK Country -> country(None))\npopulation(Country TEXT, Population_Growth REAL, Infant_Mortality REAL; PRIMARY KEY(Country); FK Country -> country(None))\nprovince(Name TEXT, Country TEXT, Population INTEGER, Area REAL, Capital TEXT, CapProv TEXT; PRIMARY KEY(Name, Country); FK Country -> country(None))\nreligion(Country TEXT, Name TEXT, Percentage REAL; PRIMARY KEY(Country, Name); FK Country -> country(None))\nriver(Name TEXT, River TEXT, Lake TEXT, Sea TEXT, Length REAL, SourceLongitude REAL, SourceLatitude REAL, Mountains TEXT, SourceAltitude REAL, EstuaryLongitude REAL, EstuaryLatitude REAL; PRIMARY KEY(Name); FK Lake -> lake(None))\nsea(Name TEXT, Depth REAL; PRIMARY KEY(Name))\ntarget(Country TEXT, Target TEXT; PRIMARY KEY(Country); FK Country -> country(None))", "source": "bird", "db_id": "bird_db_0372", "query_type": "multi_join", "query_type_name": "3+ table JOINs", "category": "Complex Joins", "difficulty": "Hard", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.381487"}
{"question": "Find the names of stadiums that some Australian swimmers have been to.", "SQL": "SELECT t4.name FROM swimmer AS t1 JOIN record AS t2 ON t1.id  =  t2.swimmer_id JOIN event AS t3 ON t2.event_id  =  t3.id JOIN stadium AS t4 ON t4.id  =  t3.stadium_id WHERE t1.nationality  =  'Australia'", "db_schema": "swimmer(ID number, name text, Nationality text, meter_100 number, meter_200 text, meter_300 text, meter_400 text, meter_500 text, meter_600 text, meter_700 text, Time text; PRIMARY KEY(ID))\nstadium(ID number, name text, Capacity number, City text, Country text, Opening_year number; PRIMARY KEY(ID))\nevent(ID number, Name text, Stadium_ID number, Year text; PRIMARY KEY(ID); FK(Stadium_ID REFERENCES stadium(ID)))\nrecord(ID number, Result text, Swimmer_ID number, Event_ID number; PRIMARY KEY(Swimmer_ID); FK(Swimmer_ID REFERENCES swimmer(ID)); FK(Event_ID REFERENCES event(ID)))", "db_id": "swimming", "source": "spider", "query_type": "multi_join", "query_type_name": "3+ table JOINs", "category": "Complex Joins", "difficulty": "Hard", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.381487"}
{"question": "How many students are enrolled in some classes that are taught by an accounting professor?", "SQL": "SELECT count(*) FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code WHERE T4.dept_name  =  'Accounting'", "db_schema": "CLASS(CLASS_CODE text, CRS_CODE text, CLASS_SECTION text, CLASS_TIME text, CLASS_ROOM text, PROF_NUM number; PRIMARY KEY(CLASS_CODE); FK(CRS_CODE REFERENCES COURSE(CRS_CODE)); FK(PROF_NUM REFERENCES EMPLOYEE(EMP_NUM)))\nCOURSE(CRS_CODE text, DEPT_CODE text, CRS_DESCRIPTION text, CRS_CREDIT number; PRIMARY KEY(CRS_CODE); FK(DEPT_CODE REFERENCES DEPARTMENT(DEPT_CODE)))\nDEPARTMENT(DEPT_CODE text, DEPT_NAME text, SCHOOL_CODE text, EMP_NUM number, DEPT_ADDRESS text, DEPT_EXTENSION text; PRIMARY KEY(DEPT_CODE); FK(EMP_NUM REFERENCES EMPLOYEE(EMP_NUM)))\nEMPLOYEE(EMP_NUM number, EMP_LNAME text, EMP_FNAME text, EMP_INITIAL text, EMP_JOBCODE text, EMP_HIREDATE time, EMP_DOB time; PRIMARY KEY(EMP_NUM))\nENROLL(CLASS_CODE text, STU_NUM number, ENROLL_GRADE text; FK(CLASS_CODE REFERENCES CLASS(CLASS_CODE)); FK(STU_NUM REFERENCES STUDENT(STU_NUM)))\nPROFESSOR(EMP_NUM number, DEPT_CODE text, PROF_OFFICE text, PROF_EXTENSION text, PROF_HIGH_DEGREE text; FK(EMP_NUM REFERENCES EMPLOYEE(EMP_NUM)); FK(DEPT_CODE REFERENCES DEPARTMENT(DEPT_CODE)))\nSTUDENT(STU_NUM number, STU_LNAME text, STU_FNAME text, STU_INIT text, STU_DOB time, STU_HRS number, STU_CLASS text, STU_GPA number, STU_TRANSFER number, DEPT_CODE text, STU_PHONE text, PROF_NUM number; PRIMARY KEY(STU_NUM); FK(DEPT_CODE REFERENCES DEPARTMENT(DEPT_CODE)))", "db_id": "college_1", "source": "spider", "query_type": "multi_join", "query_type_name": "3+ table JOINs", "category": "Complex Joins", "difficulty": "Hard", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.381487"}
{"question": "What is the object whose attribute is blurry in image no.2377993? Give the explanation about the object.", "SQL": "SELECT T4.OBJ_CLASS_ID, T4.OBJ_CLASS FROM IMG_OBJ_att AS T1 INNER JOIN ATT_CLASSES AS T2 ON T1.ATT_CLASS_ID = T2.ATT_CLASS_ID INNER JOIN IMG_OBJ AS T3 ON T1.IMG_ID = T3.IMG_ID INNER JOIN OBJ_CLASSES AS T4 ON T3.OBJ_CLASS_ID = T4.OBJ_CLASS_ID WHERE T2.ATT_CLASS = 'blurry' AND T1.IMG_ID = 22377993", "db_schema": "ATT_CLASSES(ATT_CLASS_ID INTEGER, ATT_CLASS TEXT; PRIMARY KEY(ATT_CLASS_ID))\nIMG_OBJ(IMG_ID INTEGER, OBJ_SAMPLE_ID INTEGER, OBJ_CLASS_ID INTEGER, X INTEGER, Y INTEGER, W INTEGER, H INTEGER; PRIMARY KEY(IMG_ID, OBJ_SAMPLE_ID); FK OBJ_CLASS_ID -> OBJ_CLASSES(OBJ_CLASS_ID))\nIMG_OBJ_ATT(IMG_ID INTEGER, ATT_CLASS_ID INTEGER, OBJ_SAMPLE_ID INTEGER; PRIMARY KEY(IMG_ID, ATT_CLASS_ID, OBJ_SAMPLE_ID); FK IMG_ID -> IMG_OBJ(IMG_ID); FK OBJ_SAMPLE_ID -> IMG_OBJ(OBJ_SAMPLE_ID); FK ATT_CLASS_ID -> ATT_CLASSES(ATT_CLASS_ID))\nIMG_REL(IMG_ID INTEGER, PRED_CLASS_ID INTEGER, OBJ1_SAMPLE_ID INTEGER, OBJ2_SAMPLE_ID INTEGER; PRIMARY KEY(IMG_ID, PRED_CLASS_ID, OBJ1_SAMPLE_ID, OBJ2_SAMPLE_ID); FK IMG_ID -> IMG_OBJ(IMG_ID); FK OBJ2_SAMPLE_ID -> IMG_OBJ(OBJ_SAMPLE_ID); FK IMG_ID -> IMG_OBJ(IMG_ID); FK OBJ1_SAMPLE_ID -> IMG_OBJ(OBJ_SAMPLE_ID); FK PRED_CLASS_ID -> PRED_CLASSES(PRED_CLASS_ID))\nOBJ_CLASSES(OBJ_CLASS_ID INTEGER, OBJ_CLASS TEXT; PRIMARY KEY(OBJ_CLASS_ID))\nPRED_CLASSES(PRED_CLASS_ID INTEGER, PRED_CLASS TEXT; PRIMARY KEY(PRED_CLASS_ID))", "source": "bird", "db_id": "bird_db_1383", "query_type": "multi_join", "query_type_name": "3+ table JOINs", "category": "Complex Joins", "difficulty": "Hard", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.381487"}
{"question": "What are the first names, office locations, and departments of all instructors, and also what are the descriptions of the courses they teach?", "SQL": "SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code", "db_schema": "CLASS(CLASS_CODE text, CRS_CODE text, CLASS_SECTION text, CLASS_TIME text, CLASS_ROOM text, PROF_NUM number; PRIMARY KEY(CLASS_CODE); FK(CRS_CODE REFERENCES COURSE(CRS_CODE)); FK(PROF_NUM REFERENCES EMPLOYEE(EMP_NUM)))\nCOURSE(CRS_CODE text, DEPT_CODE text, CRS_DESCRIPTION text, CRS_CREDIT number; PRIMARY KEY(CRS_CODE); FK(DEPT_CODE REFERENCES DEPARTMENT(DEPT_CODE)))\nDEPARTMENT(DEPT_CODE text, DEPT_NAME text, SCHOOL_CODE text, EMP_NUM number, DEPT_ADDRESS text, DEPT_EXTENSION text; PRIMARY KEY(DEPT_CODE); FK(EMP_NUM REFERENCES EMPLOYEE(EMP_NUM)))\nEMPLOYEE(EMP_NUM number, EMP_LNAME text, EMP_FNAME text, EMP_INITIAL text, EMP_JOBCODE text, EMP_HIREDATE time, EMP_DOB time; PRIMARY KEY(EMP_NUM))\nENROLL(CLASS_CODE text, STU_NUM number, ENROLL_GRADE text; FK(CLASS_CODE REFERENCES CLASS(CLASS_CODE)); FK(STU_NUM REFERENCES STUDENT(STU_NUM)))\nPROFESSOR(EMP_NUM number, DEPT_CODE text, PROF_OFFICE text, PROF_EXTENSION text, PROF_HIGH_DEGREE text; FK(EMP_NUM REFERENCES EMPLOYEE(EMP_NUM)); FK(DEPT_CODE REFERENCES DEPARTMENT(DEPT_CODE)))\nSTUDENT(STU_NUM number, STU_LNAME text, STU_FNAME text, STU_INIT text, STU_DOB time, STU_HRS number, STU_CLASS text, STU_GPA number, STU_TRANSFER number, DEPT_CODE text, STU_PHONE text, PROF_NUM number; PRIMARY KEY(STU_NUM); FK(DEPT_CODE REFERENCES DEPARTMENT(DEPT_CODE)))", "db_id": "college_1", "source": "spider", "query_type": "multi_join", "query_type_name": "3+ table JOINs", "category": "Complex Joins", "difficulty": "Hard", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.381487"}
{"question": "Find the name of songs that does not have a back vocal.", "SQL": "SELECT DISTINCT title FROM vocals AS t1 JOIN songs AS t2 ON t1.songid  =  t2.songid EXCEPT SELECT t2.title FROM vocals AS t1 JOIN songs AS t2 ON t1.songid  =  t2.songid WHERE TYPE  =  \"back\"", "db_schema": "Songs(SongId number, Title text; PRIMARY KEY(SongId))\nAlbums(AId number, Title text, Year number, Label text, Type text; PRIMARY KEY(AId))\nBand(Id number, Firstname text, Lastname text; PRIMARY KEY(Id))\nInstruments(SongId number, BandmateId number, Instrument text; PRIMARY KEY(SongId); FK(SongId REFERENCES Songs(SongId)); FK(BandmateId REFERENCES Band(Id)))\nPerformance(SongId number, Bandmate number, StagePosition text; PRIMARY KEY(SongId); FK(SongId REFERENCES Songs(SongId)); FK(Bandmate REFERENCES Band(Id)))\nTracklists(AlbumId number, Position number, SongId number; PRIMARY KEY(AlbumId); FK(AlbumId REFERENCES Albums(AId)); FK(SongId REFERENCES Songs(SongId)))\nVocals(SongId number, Bandmate number, Type text; PRIMARY KEY(SongId); FK(SongId REFERENCES Songs(SongId)); FK(Bandmate REFERENCES Band(Id)))", "db_id": "music_2", "source": "spider", "query_type": "anti_join", "query_type_name": "Anti-join (NOT EXISTS/NOT IN)", "category": "Advanced Filters", "difficulty": "Hard", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.385486"}
{"question": "Which address do not have any member with the black membership card?", "SQL": "SELECT address FROM member EXCEPT SELECT address FROM member WHERE Membership_card  =  'Black'", "db_schema": "shop(Shop_ID number, Address text, Num_of_staff text, Score number, Open_Year text; PRIMARY KEY(Shop_ID))\nmember(Member_ID number, Name text, Membership_card text, Age number, Time_of_purchase number, Level_of_membership number, Address text; PRIMARY KEY(Member_ID))\nhappy_hour(HH_ID number, Shop_ID number, Month text, Num_of_shaff_in_charge number; PRIMARY KEY(HH_ID); FK(Shop_ID REFERENCES shop(Shop_ID)))\nhappy_hour_member(HH_ID number, Member_ID number, Total_amount number; PRIMARY KEY(HH_ID); FK(Member_ID REFERENCES member(Member_ID)))", "db_id": "coffee_shop", "source": "spider", "query_type": "anti_join", "query_type_name": "Anti-join (NOT EXISTS/NOT IN)", "category": "Advanced Filters", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.385486"}
{"question": "How many events did not have any participants?", "SQL": "SELECT count(*) FROM EVENTS WHERE event_id NOT IN (SELECT event_id FROM Participants_in_Events)", "db_schema": "Services(Service_ID number, Service_Type_Code text; PRIMARY KEY(Service_ID))\nParticipants(Participant_ID number, Participant_Type_Code text, Participant_Details text; PRIMARY KEY(Participant_ID))\nEvents(Event_ID number, Service_ID number, Event_Details text; PRIMARY KEY(Event_ID); FK(Service_ID REFERENCES Services(Service_ID)))\nParticipants_in_Events(Event_ID number, Participant_ID number; PRIMARY KEY(Event_ID); FK(Event_ID REFERENCES Events(Event_ID)); FK(Participant_ID REFERENCES Participants(Participant_ID)))", "db_id": "local_govt_in_alabama", "source": "spider", "query_type": "anti_join", "query_type_name": "Anti-join (NOT EXISTS/NOT IN)", "category": "Advanced Filters", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.385486"}
{"question": "Show all track names that have had no races.", "SQL": "SELECT name FROM track WHERE track_id NOT IN (SELECT track_id FROM race)", "db_schema": "race(Race_ID number, Name text, Class text, Date text, Track_ID text; PRIMARY KEY(Race_ID); FK(Track_ID REFERENCES track(Track_ID)))\ntrack(Track_ID number, Name text, Location text, Seating number, Year_Opened number; PRIMARY KEY(Track_ID))", "db_id": "race_track", "source": "spider", "query_type": "anti_join", "query_type_name": "Anti-join (NOT EXISTS/NOT IN)", "category": "Advanced Filters", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.386485"}
{"question": "What are the names for tracks without a race in class 'GT'.", "SQL": "SELECT name FROM track EXCEPT SELECT T2.name FROM race AS T1 JOIN track AS T2 ON T1.track_id  =  T2.track_id WHERE T1.class  =  'GT'", "db_schema": "race(Race_ID number, Name text, Class text, Date text, Track_ID text; PRIMARY KEY(Race_ID); FK(Track_ID REFERENCES track(Track_ID)))\ntrack(Track_ID number, Name text, Location text, Seating number, Year_Opened number; PRIMARY KEY(Track_ID))", "db_id": "race_track", "source": "spider", "query_type": "anti_join", "query_type_name": "Anti-join (NOT EXISTS/NOT IN)", "category": "Advanced Filters", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.386485"}
{"question": "what are the names of people who did not participate in the candidate election.", "SQL": "SELECT name FROM people WHERE people_id NOT IN (SELECT people_id FROM candidate)", "db_schema": "candidate(Candidate_ID number, People_ID number, Poll_Source text, Date text, Support_rate number, Consider_rate number, Oppose_rate number, Unsure_rate number; PRIMARY KEY(Candidate_ID); FK(People_ID REFERENCES people(People_ID)))\npeople(People_ID number, Sex text, Name text, Date_of_Birth text, Height number, Weight number; PRIMARY KEY(People_ID))", "db_id": "candidate_poll", "source": "spider", "query_type": "anti_join", "query_type_name": "Anti-join (NOT EXISTS/NOT IN)", "category": "Advanced Filters", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.386485"}
{"question": "What are the names and cities of the branches that do not have any registered members?", "SQL": "SELECT name ,  city FROM branch WHERE branch_id NOT IN (SELECT branch_id FROM membership_register_branch)", "db_schema": "member(Member_ID number, Card_Number text, Name text, Hometown text, Level number; PRIMARY KEY(Member_ID))\nbranch(Branch_ID number, Name text, Open_year text, Address_road text, City text, membership_amount text; PRIMARY KEY(Branch_ID))\nmembership_register_branch(Member_ID number, Branch_ID text, Register_Year text; PRIMARY KEY(Member_ID); FK(Member_ID REFERENCES member(Member_ID)); FK(Branch_ID REFERENCES branch(Branch_ID)))\npurchase(Member_ID number, Branch_ID text, Year text, Total_pounds number; PRIMARY KEY(Member_ID); FK(Member_ID REFERENCES member(Member_ID)); FK(Branch_ID REFERENCES branch(Branch_ID)))", "db_id": "shop_membership", "source": "spider", "query_type": "anti_join", "query_type_name": "Anti-join (NOT EXISTS/NOT IN)", "category": "Advanced Filters", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.386485"}
{"question": "Show the number of all customers without an account.", "SQL": "SELECT count(*) FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Accounts)", "db_schema": "Accounts(account_id number, customer_id number, account_name text, other_account_details text; PRIMARY KEY(account_id))\nCustomers(customer_id number, customer_first_name text, customer_last_name text, customer_address text, customer_phone text, customer_email text, other_customer_details text; PRIMARY KEY(customer_id))\nCustomers_Cards(card_id number, customer_id number, card_type_code text, card_number text, date_valid_from time, date_valid_to time, other_card_details text; PRIMARY KEY(card_id))\nFinancial_Transactions(transaction_id number, previous_transaction_id number, account_id number, card_id number, transaction_type text, transaction_date time, transaction_amount number, transaction_comment text, other_transaction_details text; FK(account_id REFERENCES Accounts(account_id)); FK(card_id REFERENCES Customers_Cards(card_id)))", "db_id": "customers_card_transactions", "source": "spider", "query_type": "anti_join", "query_type_name": "Anti-join (NOT EXISTS/NOT IN)", "category": "Advanced Filters", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.386485"}
{"question": "Return the names of tracks that have no had any races.", "SQL": "SELECT name FROM track WHERE track_id NOT IN (SELECT track_id FROM race)", "db_schema": "race(Race_ID number, Name text, Class text, Date text, Track_ID text; PRIMARY KEY(Race_ID); FK(Track_ID REFERENCES track(Track_ID)))\ntrack(Track_ID number, Name text, Location text, Seating number, Year_Opened number; PRIMARY KEY(Track_ID))", "db_id": "race_track", "source": "spider", "query_type": "anti_join", "query_type_name": "Anti-join (NOT EXISTS/NOT IN)", "category": "Advanced Filters", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.386485"}
{"question": "Find the name of the department that has no students minored in?", "SQL": "SELECT DName FROM DEPARTMENT EXCEPT SELECT T1.DName FROM DEPARTMENT AS T1 JOIN MINOR_IN AS T2 ON T1.DNO  =  T2.DNO", "db_schema": "Student(StuID number, LName text, Fname text, Age number, Sex text, Major number, Advisor number, city_code text; PRIMARY KEY(StuID))\nFaculty(FacID number, Lname text, Fname text, Rank text, Sex text, Phone number, Room text, Building text; PRIMARY KEY(FacID))\nDepartment(DNO number, Division text, DName text, Room text, Building text, DPhone number; PRIMARY KEY(DNO))\nMember_of(FacID number, DNO number, Appt_Type text; FK(FacID REFERENCES Faculty(FacID)); FK(DNO REFERENCES Department(DNO)))\nCourse(CID text, CName text, Credits number, Instructor number, Days text, Hours text, DNO number; PRIMARY KEY(CID); FK(Instructor REFERENCES Faculty(FacID)); FK(DNO REFERENCES Department(DNO)))\nMinor_in(StuID number, DNO number; FK(StuID REFERENCES Student(StuID)); FK(DNO REFERENCES Department(DNO)))\nEnrolled_in(StuID number, CID text, Grade text; FK(StuID REFERENCES Student(StuID)); FK(CID REFERENCES Course(CID)); FK(Grade REFERENCES Gradeconversion(lettergrade)))\nGradeconversion(lettergrade text, gradepoint number; PRIMARY KEY(lettergrade))", "db_id": "college_3", "source": "spider", "query_type": "anti_join", "query_type_name": "Anti-join (NOT EXISTS/NOT IN)", "category": "Advanced Filters", "difficulty": "Hard", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.386485"}
{"question": "Show the name, location, open year for all tracks with a seating higher than the average.", "SQL": "SELECT name ,  LOCATION ,  year_opened FROM track WHERE seating  >  (SELECT avg(seating) FROM track)", "db_schema": "race(Race_ID number, Name text, Class text, Date text, Track_ID text; PRIMARY KEY(Race_ID); FK(Track_ID REFERENCES track(Track_ID)))\ntrack(Track_ID number, Name text, Location text, Seating number, Year_Opened number; PRIMARY KEY(Track_ID))", "db_id": "race_track", "source": "spider", "query_type": "date_time_aggregation", "query_type_name": "Aggregation with dates/time", "category": "Temporal Queries", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.395492"}
{"question": "What are the names and ids of all stations that have more than 14 bikes available on average or had bikes installed in December?", "SQL": "SELECT T1.name ,  T1.id FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(T2.bikes_available)  >  14 UNION SELECT name ,  id FROM station WHERE installation_date LIKE \"12/%\"", "db_schema": "station(id number, name text, lat number, long number, dock_count number, city text, installation_date text; PRIMARY KEY(id))\nstatus(station_id number, bikes_available number, docks_available number, time text; FK(station_id REFERENCES station(id)))\ntrip(id number, duration number, start_date text, start_station_name text, start_station_id number, end_date text, end_station_name text, end_station_id number, bike_id number, subscription_type text, zip_code number; PRIMARY KEY(id))\nweather(date text, max_temperature_f number, mean_temperature_f number, min_temperature_f number, max_dew_point_f number, mean_dew_point_f number, min_dew_point_f number, max_humidity number, mean_humidity number, min_humidity number, max_sea_level_pressure_inches number, mean_sea_level_pressure_inches number, min_sea_level_pressure_inches number, max_visibility_miles number, mean_visibility_miles number, min_visibility_miles number, max_wind_Speed_mph number, mean_wind_speed_mph number, max_gust_speed_mph number, precipitation_inches number, cloud_cover number, events text, wind_dir_degrees number, zip_code number)", "db_id": "bike_1", "source": "spider", "query_type": "date_time_aggregation", "query_type_name": "Aggregation with dates/time", "category": "Temporal Queries", "difficulty": "Hard", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.395492"}
{"question": "For the team which had three different goalies in the 2011 postseason games, how many games did they win in the regular season?", "SQL": "SELECT SUM(T2.W) FROM Goalies AS T1 INNER JOIN Teams AS T2 ON T1.tmID = T2.tmID WHERE T2.year = 2011 GROUP BY T1.tmID HAVING COUNT(DISTINCT T1.playerID) = 3", "db_schema": "AwardsCoaches(coachID TEXT, award TEXT, year INTEGER, lgID TEXT, note TEXT; FK coachID -> Coaches(coachID))\nAwardsMisc(name TEXT, ID TEXT, award TEXT, year INTEGER, lgID TEXT, note TEXT; PRIMARY KEY(name))\nAwardsPlayers(playerID TEXT, award TEXT, year INTEGER, lgID TEXT, note TEXT, pos TEXT; PRIMARY KEY(playerID, award, year); FK playerID -> Master(playerID))\nCoaches(coachID TEXT, year INTEGER, tmID TEXT, lgID TEXT, stint INTEGER, notes TEXT, g INTEGER, w INTEGER, l INTEGER, t INTEGER, postg TEXT, postw TEXT, postl TEXT, postt TEXT; PRIMARY KEY(coachID, year, tmID, stint); FK year -> Teams(year); FK tmID -> Teams(tmID))\nCombinedShutouts(year INTEGER, month INTEGER, date INTEGER, tmID TEXT, oppID TEXT, R/P TEXT, IDgoalie1 TEXT, IDgoalie2 TEXT; FK IDgoalie2 -> Master(playerID); FK IDgoalie1 -> Master(playerID))\nGoalies(playerID TEXT, year INTEGER, stint INTEGER, tmID TEXT, lgID TEXT, GP TEXT, Min TEXT, W TEXT, L TEXT, T/OL TEXT, ENG TEXT, SHO TEXT, GA TEXT, SA TEXT, PostGP TEXT, PostMin TEXT, PostW TEXT, PostL TEXT, PostT TEXT, PostENG TEXT, PostSHO TEXT, PostGA TEXT, PostSA TEXT; PRIMARY KEY(playerID, year, stint); FK playerID -> Master(playerID); FK year -> Teams(year); FK tmID -> Teams(tmID))\nGoaliesSC(playerID TEXT, year INTEGER, tmID TEXT, lgID TEXT, GP INTEGER, Min INTEGER, W INTEGER, L INTEGER, T INTEGER, SHO INTEGER, GA INTEGER; PRIMARY KEY(playerID, year); FK playerID -> Master(playerID); FK year -> Teams(year); FK tmID -> Teams(tmID))\nGoaliesShootout(playerID TEXT, year INTEGER, stint INTEGER, tmID TEXT, W INTEGER, L INTEGER, SA INTEGER, GA INTEGER; FK playerID -> Master(playerID); FK year -> Teams(year); FK tmID -> Teams(tmID))\nHOF(year INTEGER, hofID TEXT, name TEXT, category TEXT; PRIMARY KEY(hofID))\nMaster(playerID TEXT, coachID TEXT, hofID TEXT, firstName TEXT, lastName TEXT, nameNote TEXT, nameGiven TEXT, nameNick TEXT, height TEXT, weight TEXT, shootCatch TEXT, legendsID TEXT, ihdbID TEXT, hrefID TEXT, firstNHL TEXT, lastNHL TEXT, firstWHA TEXT, lastWHA TEXT, pos TEXT, birthYear TEXT, birthMon TEXT, birthDay TEXT, birthCountry TEXT, birthState TEXT, birthCity TEXT, deathYear TEXT, deathMon TEXT, deathDay TEXT, deathCountry TEXT, deathState TEXT, deathCity TEXT; FK coachID -> Coaches(coachID))\nScoring(playerID TEXT, year INTEGER, stint INTEGER, tmID TEXT, lgID TEXT, pos TEXT, GP INTEGER, G INTEGER, A INTEGER, Pts INTEGER, PIM INTEGER, +/- TEXT, PPG TEXT, PPA TEXT, SHG TEXT, SHA TEXT, GWG TEXT, GTG TEXT, SOG TEXT, PostGP TEXT, PostG TEXT, PostA TEXT, PostPts TEXT, PostPIM TEXT, Post+/- TEXT, PostPPG TEXT, PostPPA TEXT, PostSHG TEXT, PostSHA TEXT, PostGWG TEXT, PostSOG TEXT; FK playerID -> Master(playerID); FK year -> Teams(year); FK tmID -> Teams(tmID))\nScoringSC(playerID TEXT, year INTEGER, tmID TEXT, lgID TEXT, pos TEXT, GP INTEGER, G INTEGER, A INTEGER, Pts INTEGER, PIM INTEGER; FK playerID -> Master(playerID); FK year -> Teams(year); FK tmID -> Teams(tmID))\nScoringShootout(playerID TEXT, year INTEGER, stint INTEGER, tmID TEXT, S INTEGER, G INTEGER, GDG INTEGER; FK playerID -> Master(playerID); FK year -> Teams(year); FK tmID -> Teams(tmID))\nScoringSup(playerID TEXT, year INTEGER, PPA TEXT, SHA TEXT; FK playerID -> Master(playerID))\nSeriesPost(year INTEGER, round TEXT, series TEXT, tmIDWinner TEXT, lgIDWinner TEXT, tmIDLoser TEXT, lgIDLoser TEXT, W INTEGER, L INTEGER, T INTEGER, GoalsWinner INTEGER, GoalsLoser INTEGER, note TEXT; FK year -> Teams(year); FK tmIDLoser -> Teams(tmID); FK year -> Teams(year); FK tmIDWinner -> Teams(tmID))\nTeamSplits(year INTEGER, lgID TEXT, tmID TEXT, hW INTEGER, hL INTEGER, hT INTEGER, hOTL TEXT, rW INTEGER, rL INTEGER, rT INTEGER, rOTL TEXT, SepW TEXT, SepL TEXT, SepT TEXT, SepOL TEXT, OctW TEXT, OctL TEXT, OctT TEXT, OctOL TEXT, NovW TEXT, NovL TEXT, NovT TEXT, NovOL TEXT, DecW TEXT, DecL TEXT, DecT TEXT, DecOL TEXT, JanW INTEGER, JanL INTEGER, JanT INTEGER, JanOL TEXT, FebW INTEGER, FebL INTEGER, FebT INTEGER, FebOL TEXT, MarW TEXT, MarL TEXT, MarT TEXT, MarOL TEXT, AprW TEXT, AprL TEXT, AprT TEXT, AprOL TEXT; PRIMARY KEY(year, tmID); FK year -> Teams(year); FK tmID -> Teams(tmID))\nTeamVsTeam(year INTEGER, lgID TEXT, tmID TEXT, oppID TEXT, W INTEGER, L INTEGER, T INTEGER, OTL TEXT; PRIMARY KEY(year, tmID, oppID); FK oppID -> Teams(tmID); FK year -> Teams(year); FK year -> Teams(year); FK tmID -> Teams(tmID))\nTeams(year INTEGER, lgID TEXT, tmID TEXT, franchID TEXT, confID TEXT, divID TEXT, rank INTEGER, playoff TEXT, G INTEGER, W INTEGER, L INTEGER, T INTEGER, OTL TEXT, Pts INTEGER, SoW TEXT, SoL TEXT, GF INTEGER, GA INTEGER, name TEXT, PIM TEXT, BenchMinor TEXT, PPG TEXT, PPC TEXT, SHA TEXT, PKG TEXT, PKC TEXT, SHF TEXT; PRIMARY KEY(year, tmID))\nTeamsHalf(year INTEGER, lgID TEXT, tmID TEXT, half INTEGER, rank INTEGER, G INTEGER, W INTEGER, L INTEGER, T INTEGER, GF INTEGER, GA INTEGER; PRIMARY KEY(year, tmID, half); FK tmID -> Teams(tmID); FK year -> Teams(year))\nTeamsPost(year INTEGER, lgID TEXT, tmID TEXT, G INTEGER, W INTEGER, L INTEGER, T INTEGER, GF INTEGER, GA INTEGER, PIM TEXT, BenchMinor TEXT, PPG TEXT, PPC TEXT, SHA TEXT, PKG TEXT, PKC TEXT, SHF TEXT; PRIMARY KEY(year, tmID); FK year -> Teams(year); FK tmID -> Teams(tmID))\nTeamsSC(year INTEGER, lgID TEXT, tmID TEXT, G INTEGER, W INTEGER, L INTEGER, T INTEGER, GF INTEGER, GA INTEGER, PIM TEXT; PRIMARY KEY(year, tmID); FK year -> Teams(year); FK tmID -> Teams(tmID))\nabbrev(Type TEXT, Code TEXT, Fullname TEXT; PRIMARY KEY(Type, Code))", "source": "bird", "db_id": "bird_db_0570", "query_type": "date_time_aggregation", "query_type_name": "Aggregation with dates/time", "category": "Temporal Queries", "difficulty": "Hard", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.395492"}
{"question": "How many papers were preprinted between the years 1990 and 2000?", "SQL": "SELECT COUNT(id) FROM Paper WHERE Year BETWEEN '1990' AND '2000' AND ConferenceId = 0 AND JournalId = 0", "db_schema": "Author(Id INTEGER, Name TEXT, Affiliation TEXT; PRIMARY KEY(Id))\nConference(Id INTEGER, ShortName TEXT, FullName TEXT, HomePage TEXT; PRIMARY KEY(Id))\nJournal(Id INTEGER, ShortName TEXT, FullName TEXT, HomePage TEXT; PRIMARY KEY(Id))\nPaper(Id INTEGER, Title TEXT, Year INTEGER, ConferenceId INTEGER, JournalId INTEGER, Keyword TEXT; PRIMARY KEY(Id); FK JournalId -> Journal(Id); FK ConferenceId -> Conference(Id))\nPaperAuthor(PaperId INTEGER, AuthorId INTEGER, Name TEXT, Affiliation TEXT; FK AuthorId -> Author(Id); FK PaperId -> Paper(Id))", "source": "bird", "db_id": "bird_db_1137", "query_type": "date_time_aggregation", "query_type_name": "Aggregation with dates/time", "category": "Temporal Queries", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.395492"}
{"question": "Did the tallest player got in the Hall of Fame? If yes, please list the year when he got in the Hall of Fame.", "SQL": "SELECT CASE WHEN T1.hofID IS NULL THEN 'NO' ELSE T2.year END FROM Master AS T1 LEFT JOIN HOF AS T2 ON T1.hofID = T2.hofID WHERE T1.height = ( SELECT MAX(height) FROM Master )", "db_schema": "AwardsCoaches(coachID TEXT, award TEXT, year INTEGER, lgID TEXT, note TEXT; FK coachID -> Coaches(coachID))\nAwardsMisc(name TEXT, ID TEXT, award TEXT, year INTEGER, lgID TEXT, note TEXT; PRIMARY KEY(name))\nAwardsPlayers(playerID TEXT, award TEXT, year INTEGER, lgID TEXT, note TEXT, pos TEXT; PRIMARY KEY(playerID, award, year); FK playerID -> Master(playerID))\nCoaches(coachID TEXT, year INTEGER, tmID TEXT, lgID TEXT, stint INTEGER, notes TEXT, g INTEGER, w INTEGER, l INTEGER, t INTEGER, postg TEXT, postw TEXT, postl TEXT, postt TEXT; PRIMARY KEY(coachID, year, tmID, stint); FK year -> Teams(year); FK tmID -> Teams(tmID))\nCombinedShutouts(year INTEGER, month INTEGER, date INTEGER, tmID TEXT, oppID TEXT, R/P TEXT, IDgoalie1 TEXT, IDgoalie2 TEXT; FK IDgoalie2 -> Master(playerID); FK IDgoalie1 -> Master(playerID))\nGoalies(playerID TEXT, year INTEGER, stint INTEGER, tmID TEXT, lgID TEXT, GP TEXT, Min TEXT, W TEXT, L TEXT, T/OL TEXT, ENG TEXT, SHO TEXT, GA TEXT, SA TEXT, PostGP TEXT, PostMin TEXT, PostW TEXT, PostL TEXT, PostT TEXT, PostENG TEXT, PostSHO TEXT, PostGA TEXT, PostSA TEXT; PRIMARY KEY(playerID, year, stint); FK playerID -> Master(playerID); FK year -> Teams(year); FK tmID -> Teams(tmID))\nGoaliesSC(playerID TEXT, year INTEGER, tmID TEXT, lgID TEXT, GP INTEGER, Min INTEGER, W INTEGER, L INTEGER, T INTEGER, SHO INTEGER, GA INTEGER; PRIMARY KEY(playerID, year); FK playerID -> Master(playerID); FK year -> Teams(year); FK tmID -> Teams(tmID))\nGoaliesShootout(playerID TEXT, year INTEGER, stint INTEGER, tmID TEXT, W INTEGER, L INTEGER, SA INTEGER, GA INTEGER; FK playerID -> Master(playerID); FK year -> Teams(year); FK tmID -> Teams(tmID))\nHOF(year INTEGER, hofID TEXT, name TEXT, category TEXT; PRIMARY KEY(hofID))\nMaster(playerID TEXT, coachID TEXT, hofID TEXT, firstName TEXT, lastName TEXT, nameNote TEXT, nameGiven TEXT, nameNick TEXT, height TEXT, weight TEXT, shootCatch TEXT, legendsID TEXT, ihdbID TEXT, hrefID TEXT, firstNHL TEXT, lastNHL TEXT, firstWHA TEXT, lastWHA TEXT, pos TEXT, birthYear TEXT, birthMon TEXT, birthDay TEXT, birthCountry TEXT, birthState TEXT, birthCity TEXT, deathYear TEXT, deathMon TEXT, deathDay TEXT, deathCountry TEXT, deathState TEXT, deathCity TEXT; FK coachID -> Coaches(coachID))\nScoring(playerID TEXT, year INTEGER, stint INTEGER, tmID TEXT, lgID TEXT, pos TEXT, GP INTEGER, G INTEGER, A INTEGER, Pts INTEGER, PIM INTEGER, +/- TEXT, PPG TEXT, PPA TEXT, SHG TEXT, SHA TEXT, GWG TEXT, GTG TEXT, SOG TEXT, PostGP TEXT, PostG TEXT, PostA TEXT, PostPts TEXT, PostPIM TEXT, Post+/- TEXT, PostPPG TEXT, PostPPA TEXT, PostSHG TEXT, PostSHA TEXT, PostGWG TEXT, PostSOG TEXT; FK playerID -> Master(playerID); FK year -> Teams(year); FK tmID -> Teams(tmID))\nScoringSC(playerID TEXT, year INTEGER, tmID TEXT, lgID TEXT, pos TEXT, GP INTEGER, G INTEGER, A INTEGER, Pts INTEGER, PIM INTEGER; FK playerID -> Master(playerID); FK year -> Teams(year); FK tmID -> Teams(tmID))\nScoringShootout(playerID TEXT, year INTEGER, stint INTEGER, tmID TEXT, S INTEGER, G INTEGER, GDG INTEGER; FK playerID -> Master(playerID); FK year -> Teams(year); FK tmID -> Teams(tmID))\nScoringSup(playerID TEXT, year INTEGER, PPA TEXT, SHA TEXT; FK playerID -> Master(playerID))\nSeriesPost(year INTEGER, round TEXT, series TEXT, tmIDWinner TEXT, lgIDWinner TEXT, tmIDLoser TEXT, lgIDLoser TEXT, W INTEGER, L INTEGER, T INTEGER, GoalsWinner INTEGER, GoalsLoser INTEGER, note TEXT; FK year -> Teams(year); FK tmIDLoser -> Teams(tmID); FK year -> Teams(year); FK tmIDWinner -> Teams(tmID))\nTeamSplits(year INTEGER, lgID TEXT, tmID TEXT, hW INTEGER, hL INTEGER, hT INTEGER, hOTL TEXT, rW INTEGER, rL INTEGER, rT INTEGER, rOTL TEXT, SepW TEXT, SepL TEXT, SepT TEXT, SepOL TEXT, OctW TEXT, OctL TEXT, OctT TEXT, OctOL TEXT, NovW TEXT, NovL TEXT, NovT TEXT, NovOL TEXT, DecW TEXT, DecL TEXT, DecT TEXT, DecOL TEXT, JanW INTEGER, JanL INTEGER, JanT INTEGER, JanOL TEXT, FebW INTEGER, FebL INTEGER, FebT INTEGER, FebOL TEXT, MarW TEXT, MarL TEXT, MarT TEXT, MarOL TEXT, AprW TEXT, AprL TEXT, AprT TEXT, AprOL TEXT; PRIMARY KEY(year, tmID); FK year -> Teams(year); FK tmID -> Teams(tmID))\nTeamVsTeam(year INTEGER, lgID TEXT, tmID TEXT, oppID TEXT, W INTEGER, L INTEGER, T INTEGER, OTL TEXT; PRIMARY KEY(year, tmID, oppID); FK oppID -> Teams(tmID); FK year -> Teams(year); FK year -> Teams(year); FK tmID -> Teams(tmID))\nTeams(year INTEGER, lgID TEXT, tmID TEXT, franchID TEXT, confID TEXT, divID TEXT, rank INTEGER, playoff TEXT, G INTEGER, W INTEGER, L INTEGER, T INTEGER, OTL TEXT, Pts INTEGER, SoW TEXT, SoL TEXT, GF INTEGER, GA INTEGER, name TEXT, PIM TEXT, BenchMinor TEXT, PPG TEXT, PPC TEXT, SHA TEXT, PKG TEXT, PKC TEXT, SHF TEXT; PRIMARY KEY(year, tmID))\nTeamsHalf(year INTEGER, lgID TEXT, tmID TEXT, half INTEGER, rank INTEGER, G INTEGER, W INTEGER, L INTEGER, T INTEGER, GF INTEGER, GA INTEGER; PRIMARY KEY(year, tmID, half); FK tmID -> Teams(tmID); FK year -> Teams(year))\nTeamsPost(year INTEGER, lgID TEXT, tmID TEXT, G INTEGER, W INTEGER, L INTEGER, T INTEGER, GF INTEGER, GA INTEGER, PIM TEXT, BenchMinor TEXT, PPG TEXT, PPC TEXT, SHA TEXT, PKG TEXT, PKC TEXT, SHF TEXT; PRIMARY KEY(year, tmID); FK year -> Teams(year); FK tmID -> Teams(tmID))\nTeamsSC(year INTEGER, lgID TEXT, tmID TEXT, G INTEGER, W INTEGER, L INTEGER, T INTEGER, GF INTEGER, GA INTEGER, PIM TEXT; PRIMARY KEY(year, tmID); FK year -> Teams(year); FK tmID -> Teams(tmID))\nabbrev(Type TEXT, Code TEXT, Fullname TEXT; PRIMARY KEY(Type, Code))", "source": "bird", "db_id": "bird_db_1569", "query_type": "date_time_aggregation", "query_type_name": "Aggregation with dates/time", "category": "Temporal Queries", "difficulty": "Hard", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.395492"}
{"question": "What percentage of papers were preprinted after the year 2000?", "SQL": "SELECT CAST(SUM(CASE WHEN Year > 2000 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(Id) FROM Paper", "db_schema": "Author(Id INTEGER, Name TEXT, Affiliation TEXT; PRIMARY KEY(Id))\nConference(Id INTEGER, ShortName TEXT, FullName TEXT, HomePage TEXT; PRIMARY KEY(Id))\nJournal(Id INTEGER, ShortName TEXT, FullName TEXT, HomePage TEXT; PRIMARY KEY(Id))\nPaper(Id INTEGER, Title TEXT, Year INTEGER, ConferenceId INTEGER, JournalId INTEGER, Keyword TEXT; PRIMARY KEY(Id); FK JournalId -> Journal(Id); FK ConferenceId -> Conference(Id))\nPaperAuthor(PaperId INTEGER, AuthorId INTEGER, Name TEXT, Affiliation TEXT; FK AuthorId -> Author(Id); FK PaperId -> Paper(Id))", "source": "bird", "db_id": "bird_db_1842", "query_type": "date_time_aggregation", "query_type_name": "Aggregation with dates/time", "category": "Temporal Queries", "difficulty": "Hard", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.395492"}
{"question": "List the date the claim was made, the date it was settled and the amount settled for all the claims which had exactly one settlement.", "SQL": "SELECT T1.claim_id ,  T1.date_claim_made ,  T1.Date_Claim_Settled FROM Claims AS T1 JOIN Settlements AS T2 ON T1.Claim_id  =  T2.Claim_id GROUP BY T1.claim_id HAVING count(*)  =  1", "db_schema": "Customers(Customer_ID number, Customer_Details text; PRIMARY KEY(Customer_ID))\nCustomer_Policies(Policy_ID number, Customer_ID number, Policy_Type_Code text, Start_Date time, End_Date time; PRIMARY KEY(Policy_ID); FK(Customer_ID REFERENCES Customers(Customer_ID)))\nClaims(Claim_ID number, Policy_ID number, Date_Claim_Made time, Date_Claim_Settled time, Amount_Claimed number, Amount_Settled number; PRIMARY KEY(Claim_ID); FK(Policy_ID REFERENCES Customer_Policies(Policy_ID)))\nSettlements(Settlement_ID number, Claim_ID number, Date_Claim_Made time, Date_Claim_Settled time, Amount_Claimed number, Amount_Settled number, Customer_Policy_ID number; PRIMARY KEY(Settlement_ID); FK(Claim_ID REFERENCES Claims(Claim_ID)))\nPayments(Payment_ID number, Settlement_ID number, Payment_Method_Code text, Date_Payment_Made time, Amount_Payment number; PRIMARY KEY(Payment_ID); FK(Settlement_ID REFERENCES Settlements(Settlement_ID)))", "db_id": "insurance_policies", "source": "spider", "query_type": "date_time_aggregation", "query_type_name": "Aggregation with dates/time", "category": "Temporal Queries", "difficulty": "Hard", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.395492"}
{"question": "For each Orange county campus, report the number of degrees granted after 2000.", "SQL": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  \"Orange\" AND T2.year  >=  2000 GROUP BY T1.campus", "db_schema": "Campuses(Id number, Campus text, Location text, County text, Year number; PRIMARY KEY(Id))\ncsu_fees(Campus number, Year number, CampusFee number; PRIMARY KEY(Campus); FK(Campus REFERENCES Campuses(Id)))\ndegrees(Year number, Campus number, Degrees number; PRIMARY KEY(Year); FK(Campus REFERENCES Campuses(Id)))\ndiscipline_enrollments(Campus number, Discipline number, Year number, Undergraduate number, Graduate number; PRIMARY KEY(Campus); FK(Campus REFERENCES Campuses(Id)))\nenrollments(Campus number, Year number, TotalEnrollment_AY number, FTE_AY number; PRIMARY KEY(Campus); FK(Campus REFERENCES Campuses(Id)))\nfaculty(Campus number, Year number, Faculty number; FK(Campus REFERENCES Campuses(Id)))", "db_id": "csu_1", "source": "spider", "query_type": "date_time_aggregation", "query_type_name": "Aggregation with dates/time", "category": "Temporal Queries", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.395492"}
{"question": "In the year 1500s, how many tragedies did Shakespeare write?", "SQL": "SELECT COUNT(id) FROM works WHERE GenreType = 'Tragedy' AND Date BETWEEN 1500 AND 1599", "db_schema": "chapters(id INTEGER, Act INTEGER, Scene INTEGER, Description TEXT, work_id INTEGER; PRIMARY KEY(id); FK work_id -> works(None))\ncharacters(id INTEGER, CharName TEXT, Abbrev TEXT, Description TEXT; PRIMARY KEY(id))\nparagraphs(id INTEGER, ParagraphNum INTEGER, PlainText TEXT, character_id INTEGER, chapter_id INTEGER; PRIMARY KEY(id); FK chapter_id -> chapters(None); FK character_id -> characters(None))\nsqlite_sequence(name TEXT, seq TEXT)\nworks(id INTEGER, Title TEXT, LongTitle TEXT, Date INTEGER, GenreType TEXT; PRIMARY KEY(id))", "source": "bird", "db_id": "bird_db_0398", "query_type": "date_time_aggregation", "query_type_name": "Aggregation with dates/time", "category": "Temporal Queries", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.395492"}
{"question": "What is the name of the solution path with the highest processed time?", "SQL": "SELECT Path FROM Solution WHERE ProcessedTime = ( SELECT MAX(ProcessedTime) FROM Solution )", "db_schema": "Method(Id INTEGER, Name TEXT, FullComment TEXT, Summary TEXT, ApiCalls TEXT, CommentIsXml INTEGER, SampledAt INTEGER, SolutionId INTEGER, Lang TEXT, NameTokenized TEXT; PRIMARY KEY(Id))\nMethodParameter(Id INTEGER, MethodId TEXT, Type TEXT, Name TEXT; PRIMARY KEY(Id))\nRepo(Id INTEGER, Url TEXT, Stars INTEGER, Forks INTEGER, Watchers INTEGER, ProcessedTime INTEGER; PRIMARY KEY(Id))\nSolution(Id INTEGER, RepoId INTEGER, Path TEXT, ProcessedTime INTEGER, WasCompiled INTEGER; PRIMARY KEY(Id))\nsqlite_sequence(name TEXT, seq TEXT)", "source": "bird", "db_id": "bird_db_1307", "query_type": "date_time_aggregation", "query_type_name": "Aggregation with dates/time", "category": "Temporal Queries", "difficulty": "Hard", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.395492"}
{"question": "Give the web site address for \"Swarthmore College\".", "SQL": "SELECT T FROM ( SELECT DISTINCT CASE WHEN chronname = 'Swarthmore College' THEN site ELSE NULL END AS T FROM institution_details ) WHERE T IS NOT NULL", "db_schema": "institution_details(unitid INTEGER, chronname TEXT, city TEXT, state TEXT, level TEXT, control TEXT, basic TEXT, hbcu TEXT, flagship TEXT, long_x REAL, lat_y REAL, site TEXT, student_count INTEGER, awards_per_value REAL, awards_per_state_value REAL, awards_per_natl_value REAL, exp_award_value INTEGER, exp_award_state_value INTEGER, exp_award_natl_value INTEGER, exp_award_percentile INTEGER, ft_pct REAL, fte_value INTEGER, fte_percentile INTEGER, med_sat_value TEXT, med_sat_percentile TEXT, aid_value INTEGER, aid_percentile INTEGER, endow_value TEXT, endow_percentile TEXT, grad_100_value REAL, grad_100_percentile INTEGER, grad_150_value REAL, grad_150_percentile INTEGER, pell_value REAL, pell_percentile INTEGER, retain_value REAL, retain_percentile INTEGER, ft_fac_value REAL, ft_fac_percentile INTEGER, vsa_year TEXT, vsa_grad_after4_first TEXT, vsa_grad_elsewhere_after4_first TEXT, vsa_enroll_after4_first TEXT, vsa_enroll_elsewhere_after4_first TEXT, vsa_grad_after6_first TEXT, vsa_grad_elsewhere_after6_first TEXT, vsa_enroll_after6_first TEXT, vsa_enroll_elsewhere_after6_first TEXT, vsa_grad_after4_transfer TEXT, vsa_grad_elsewhere_after4_transfer TEXT, vsa_enroll_after4_transfer TEXT, vsa_enroll_elsewhere_after4_transfer TEXT, vsa_grad_after6_transfer TEXT, vsa_grad_elsewhere_after6_transfer TEXT, vsa_enroll_after6_transfer TEXT, vsa_enroll_elsewhere_after6_transfer TEXT, similar TEXT, state_sector_ct INTEGER, carnegie_ct INTEGER, counted_pct TEXT, nicknames TEXT, cohort_size INTEGER; PRIMARY KEY(unitid))\ninstitution_grads(unitid INTEGER, year INTEGER, gender TEXT, race TEXT, cohort TEXT, grad_cohort TEXT, grad_100 TEXT, grad_150 TEXT, grad_100_rate TEXT, grad_150_rate TEXT; FK unitid -> institution_details(unitid))\nstate_sector_details(stateid INTEGER, state TEXT, state_post TEXT, level TEXT, control TEXT, schools_count INTEGER, counted_pct TEXT, awards_per_state_value TEXT, awards_per_natl_value REAL, exp_award_state_value TEXT, exp_award_natl_value INTEGER, state_appr_value TEXT, state_appr_rank TEXT, grad_rate_rank TEXT, awards_per_rank TEXT; PRIMARY KEY(stateid, level, control); FK state -> institution_details(state))\nstate_sector_grads(stateid INTEGER, state TEXT, state_abbr TEXT, control TEXT, level TEXT, year INTEGER, gender TEXT, race TEXT, cohort TEXT, grad_cohort TEXT, grad_100 TEXT, grad_150 TEXT, grad_100_rate TEXT, grad_150_rate TEXT, grad_cohort_ct INTEGER; FK stateid -> state_sector_details(stateid); FK state -> institution_details(state))", "source": "bird", "db_id": "bird_db_1486", "query_type": "projection_case", "query_type_name": "Projection + CASE", "category": "Conditional Logic", "difficulty": "Hard", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.397491"}
{"question": "Among the technology items, what percentage of them are from Best Buy for Business? Provide the date of the project related to those items.", "SQL": "SELECT CAST(SUM(CASE WHEN T1.vendor_name = 'Best Buy for Business' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.projectid) FROM resources AS T1 INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE T1.project_resource_type = 'Technology' UNION ALL SELECT DISTINCT T1.date_posted FROM projects AS T1 INNER JOIN resources AS T2 ON T1.projectid = T2.projectid WHERE T2.vendor_name = 'Best Buy for Business' AND T2.project_resource_type = 'Technology'", "db_schema": "donations(donationid TEXT, projectid TEXT, donor_acctid TEXT, donor_city TEXT, donor_state TEXT, donor_zip TEXT, is_teacher_acct TEXT, donation_timestamp DATETIME, donation_to_project REAL, donation_optional_support REAL, donation_total REAL, dollar_amount TEXT, donation_included_optional_support TEXT, payment_method TEXT, payment_included_acct_credit TEXT, payment_included_campaign_gift_card TEXT, payment_included_web_purchased_gift_card TEXT, payment_was_promo_matched TEXT, via_giving_page TEXT, for_honoree TEXT, donation_message TEXT; PRIMARY KEY(donationid); FK projectid -> projects(projectid))\nessays(projectid TEXT, teacher_acctid TEXT, title TEXT, short_description TEXT, need_statement TEXT, essay TEXT)\nprojects(projectid TEXT, teacher_acctid TEXT, schoolid TEXT, school_ncesid TEXT, school_latitude REAL, school_longitude REAL, school_city TEXT, school_state TEXT, school_zip INTEGER, school_metro TEXT, school_district TEXT, school_county TEXT, school_charter TEXT, school_magnet TEXT, school_year_round TEXT, school_nlns TEXT, school_kipp TEXT, school_charter_ready_promise TEXT, teacher_prefix TEXT, teacher_teach_for_america TEXT, teacher_ny_teaching_fellow TEXT, primary_focus_subject TEXT, primary_focus_area TEXT, secondary_focus_subject TEXT, secondary_focus_area TEXT, resource_type TEXT, poverty_level TEXT, grade_level TEXT, fulfillment_labor_materials REAL, total_price_excluding_optional_support REAL, total_price_including_optional_support REAL, students_reached INTEGER, eligible_double_your_impact_match TEXT, eligible_almost_home_match TEXT, date_posted DATE; PRIMARY KEY(projectid))\nresources(resourceid TEXT, projectid TEXT, vendorid INTEGER, vendor_name TEXT, project_resource_type TEXT, item_name TEXT, item_number TEXT, item_unit_price REAL, item_quantity INTEGER; PRIMARY KEY(resourceid); FK projectid -> projects(projectid))\nsqlite_sequence(name TEXT, seq TEXT)", "source": "bird", "db_id": "bird_db_0209", "query_type": "projection_case", "query_type_name": "Projection + CASE", "category": "Conditional Logic", "difficulty": "Hard", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.397491"}
{"question": "What format does the method number 8's comment have?", "SQL": "SELECT CASE WHEN CommentIsXml = 0 THEN 'isNotXMLFormat' WHEN CommentIsXml = 1 THEN 'isXMLFormat' END format FROM Method WHERE Id = 8", "db_schema": "Method(Id INTEGER, Name TEXT, FullComment TEXT, Summary TEXT, ApiCalls TEXT, CommentIsXml INTEGER, SampledAt INTEGER, SolutionId INTEGER, Lang TEXT, NameTokenized TEXT; PRIMARY KEY(Id))\nMethodParameter(Id INTEGER, MethodId TEXT, Type TEXT, Name TEXT; PRIMARY KEY(Id))\nRepo(Id INTEGER, Url TEXT, Stars INTEGER, Forks INTEGER, Watchers INTEGER, ProcessedTime INTEGER; PRIMARY KEY(Id))\nSolution(Id INTEGER, RepoId INTEGER, Path TEXT, ProcessedTime INTEGER, WasCompiled INTEGER; PRIMARY KEY(Id))\nsqlite_sequence(name TEXT, seq TEXT)", "source": "bird", "db_id": "bird_db_1461", "query_type": "projection_case", "query_type_name": "Projection + CASE", "category": "Conditional Logic", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.397491"}
{"question": "For the word \"grec\", what is the percentage of the appearances in the \"Art\" Wikipedia page have among all the appearances?", "SQL": "SELECT CAST(SUM(CASE WHEN T3.title = 'Art' THEN T2.occurrences ELSE 0 END) AS REAL) * 100 / SUM(T2.occurrences) FROM words AS T1 INNER JOIN pages_words AS T2 ON T1.wid = T2.wid INNER JOIN pages AS T3 ON T2.pid = T3.pid WHERE T1.word = 'grec'", "db_schema": "biwords(lid INTEGER, w1st INTEGER, w2nd INTEGER, occurrences INTEGER; PRIMARY KEY(lid, w1st, w2nd); FK w2nd -> words(wid); FK w1st -> words(wid); FK lid -> langs(lid))\nlangs(lid INTEGER, lang TEXT, locale TEXT, pages INTEGER, words INTEGER; PRIMARY KEY(lid))\nlangs_words(lid INTEGER, wid INTEGER, occurrences INTEGER; PRIMARY KEY(lid, wid); FK wid -> words(wid); FK lid -> langs(lid))\npages(pid INTEGER, lid INTEGER, page INTEGER, revision INTEGER, title TEXT, words INTEGER; PRIMARY KEY(pid); FK lid -> langs(lid))\npages_words(pid INTEGER, wid INTEGER, occurrences INTEGER; PRIMARY KEY(pid, wid); FK wid -> words(wid); FK pid -> pages(pid))\nsqlite_sequence(name TEXT, seq TEXT)\nwords(wid INTEGER, word TEXT, occurrences INTEGER; PRIMARY KEY(wid))", "source": "bird", "db_id": "bird_db_1467", "query_type": "projection_case", "query_type_name": "Projection + CASE", "category": "Conditional Logic", "difficulty": "Hard", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.397491"}
{"question": "Among the menus in which the dish \"Clear green turtle\" had appeared, how many of them used the dollar as their currency?", "SQL": "SELECT SUM(CASE WHEN T3.currency = 'Dollars' THEN 1 ELSE 0 END) FROM MenuItem AS T1 INNER JOIN MenuPage AS T2 ON T1.menu_page_id = T2.id INNER JOIN Menu AS T3 ON T2.menu_id = T3.id INNER JOIN Dish AS T4 ON T1.dish_id = T4.id WHERE T4.name = 'Clear green turtle'", "db_schema": "Dish(id INTEGER, name TEXT, description TEXT, menus_appeared INTEGER, times_appeared INTEGER, first_appeared INTEGER, last_appeared INTEGER, lowest_price REAL, highest_price REAL; PRIMARY KEY(id))\nMenu(id INTEGER, name TEXT, sponsor TEXT, event TEXT, venue TEXT, place TEXT, physical_description TEXT, occasion TEXT, notes TEXT, call_number TEXT, keywords TEXT, language TEXT, date DATE, location TEXT, location_type TEXT, currency TEXT, currency_symbol TEXT, status TEXT, page_count INTEGER, dish_count INTEGER; PRIMARY KEY(id))\nMenuItem(id INTEGER, menu_page_id INTEGER, price REAL, high_price REAL, dish_id INTEGER, created_at TEXT, updated_at TEXT, xpos REAL, ypos REAL; PRIMARY KEY(id); FK menu_page_id -> MenuPage(id); FK dish_id -> Dish(id))\nMenuPage(id INTEGER, menu_id INTEGER, page_number INTEGER, image_id REAL, full_height INTEGER, full_width INTEGER, uuid TEXT; PRIMARY KEY(id); FK menu_id -> Menu(id))", "source": "bird", "db_id": "bird_db_1628", "query_type": "projection_case", "query_type_name": "Projection + CASE", "category": "Conditional Logic", "difficulty": "Hard", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.397491"}
{"question": "Among the crimes in the Central, calculate the percentage of larceny incidents.", "SQL": "SELECT CAST(COUNT(CASE WHEN T3.title = 'Larceny' THEN T2.report_no END) AS REAL) * 100 / COUNT(T2.report_no) FROM Community_Area AS T1 INNER JOIN Crime AS T2 ON T2.community_area_no = T1.community_area_no INNER JOIN FBI_Code AS T3 ON T3.fbi_code_no = T2.fbi_code_no WHERE T1.side = 'Central'", "db_schema": "Community_Area(community_area_no INTEGER, community_area_name TEXT, side TEXT, population TEXT; PRIMARY KEY(community_area_no))\nCrime(report_no INTEGER, case_number TEXT, date TEXT, block TEXT, iucr_no TEXT, location_description TEXT, arrest TEXT, domestic TEXT, beat INTEGER, district_no INTEGER, ward_no INTEGER, community_area_no INTEGER, fbi_code_no TEXT, latitude TEXT, longitude TEXT; PRIMARY KEY(report_no); FK fbi_code_no -> FBI_Code(fbi_code_no); FK community_area_no -> Community_Area(community_area_no); FK district_no -> District(district_no); FK iucr_no -> IUCR(iucr_no); FK ward_no -> Ward(ward_no))\nDistrict(district_no INTEGER, district_name TEXT, address TEXT, zip_code INTEGER, commander TEXT, email TEXT, phone TEXT, fax TEXT, tty TEXT, twitter TEXT; PRIMARY KEY(district_no))\nFBI_Code(fbi_code_no TEXT, title TEXT, description TEXT, crime_against TEXT; PRIMARY KEY(fbi_code_no))\nIUCR(iucr_no TEXT, primary_description TEXT, secondary_description TEXT, index_code TEXT; PRIMARY KEY(iucr_no))\nNeighborhood(neighborhood_name TEXT, community_area_no INTEGER; PRIMARY KEY(neighborhood_name); FK community_area_no -> Community_Area(community_area_no))\nWard(ward_no INTEGER, alderman_first_name TEXT, alderman_last_name TEXT, alderman_name_suffix TEXT, ward_office_address TEXT, ward_office_zip TEXT, ward_email TEXT, ward_office_phone TEXT, ward_office_fax TEXT, city_hall_office_room INTEGER, city_hall_office_phone TEXT, city_hall_office_fax TEXT, Population INTEGER; PRIMARY KEY(ward_no))", "source": "bird", "db_id": "bird_db_0960", "query_type": "projection_case", "query_type_name": "Projection + CASE", "category": "Conditional Logic", "difficulty": "Hard", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.397491"}
{"question": "What is the ratio of male and female among the age of teenager when the education is above 10?", "SQL": "SELECT CAST(SUM(CASE WHEN SEX = 'Male' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN SEX = 'Female' THEN 1 ELSE 0 END) FROM Customers WHERE age BETWEEN 13 AND 19 AND EDUCATIONNUM > 10", "db_schema": "Customers(ID INTEGER, SEX TEXT, MARITAL_STATUS TEXT, GEOID INTEGER, EDUCATIONNUM INTEGER, OCCUPATION TEXT, age INTEGER; PRIMARY KEY(ID); FK GEOID -> Demog(None))\nDemog(GEOID INTEGER, INHABITANTS_K REAL, INCOME_K REAL, A_VAR1 REAL, A_VAR2 REAL, A_VAR3 REAL, A_VAR4 REAL, A_VAR5 REAL, A_VAR6 REAL, A_VAR7 REAL, A_VAR8 REAL, A_VAR9 REAL, A_VAR10 REAL, A_VAR11 REAL, A_VAR12 REAL, A_VAR13 REAL, A_VAR14 REAL, A_VAR15 REAL, A_VAR16 REAL, A_VAR17 REAL, A_VAR18 REAL; PRIMARY KEY(GEOID))\nMailings1_2(REFID INTEGER, REF_DATE DATETIME, RESPONSE TEXT; PRIMARY KEY(REFID); FK REFID -> Customers(None))\nSales(EVENTID INTEGER, REFID INTEGER, EVENT_DATE DATETIME, AMOUNT REAL; PRIMARY KEY(EVENTID); FK REFID -> Customers(None))\nmailings3(REFID INTEGER, REF_DATE DATETIME, RESPONSE TEXT; PRIMARY KEY(REFID))", "source": "bird", "db_id": "bird_db_0258", "query_type": "projection_case", "query_type_name": "Projection + CASE", "category": "Conditional Logic", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.397491"}
{"question": "What percentage of papers were preprinted after the year 2000?", "SQL": "SELECT CAST(SUM(CASE WHEN Year > 2000 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(Id) FROM Paper", "db_schema": "Author(Id INTEGER, Name TEXT, Affiliation TEXT; PRIMARY KEY(Id))\nConference(Id INTEGER, ShortName TEXT, FullName TEXT, HomePage TEXT; PRIMARY KEY(Id))\nJournal(Id INTEGER, ShortName TEXT, FullName TEXT, HomePage TEXT; PRIMARY KEY(Id))\nPaper(Id INTEGER, Title TEXT, Year INTEGER, ConferenceId INTEGER, JournalId INTEGER, Keyword TEXT; PRIMARY KEY(Id); FK JournalId -> Journal(Id); FK ConferenceId -> Conference(Id))\nPaperAuthor(PaperId INTEGER, AuthorId INTEGER, Name TEXT, Affiliation TEXT; FK AuthorId -> Author(Id); FK PaperId -> Paper(Id))", "source": "bird", "db_id": "bird_db_1842", "query_type": "projection_case", "query_type_name": "Projection + CASE", "category": "Conditional Logic", "difficulty": "Hard", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.397491"}
{"question": "How many dishes are there on the menu \"Zentral Theater Terrace\"?", "SQL": "SELECT SUM(CASE WHEN T3.name = 'Zentral Theater Terrace' THEN 1 ELSE 0 END) FROM MenuItem AS T1 INNER JOIN MenuPage AS T2 ON T1.menu_page_id = T2.id INNER JOIN Menu AS T3 ON T2.menu_id = T3.id", "db_schema": "Dish(id INTEGER, name TEXT, description TEXT, menus_appeared INTEGER, times_appeared INTEGER, first_appeared INTEGER, last_appeared INTEGER, lowest_price REAL, highest_price REAL; PRIMARY KEY(id))\nMenu(id INTEGER, name TEXT, sponsor TEXT, event TEXT, venue TEXT, place TEXT, physical_description TEXT, occasion TEXT, notes TEXT, call_number TEXT, keywords TEXT, language TEXT, date DATE, location TEXT, location_type TEXT, currency TEXT, currency_symbol TEXT, status TEXT, page_count INTEGER, dish_count INTEGER; PRIMARY KEY(id))\nMenuItem(id INTEGER, menu_page_id INTEGER, price REAL, high_price REAL, dish_id INTEGER, created_at TEXT, updated_at TEXT, xpos REAL, ypos REAL; PRIMARY KEY(id); FK menu_page_id -> MenuPage(id); FK dish_id -> Dish(id))\nMenuPage(id INTEGER, menu_id INTEGER, page_number INTEGER, image_id REAL, full_height INTEGER, full_width INTEGER, uuid TEXT; PRIMARY KEY(id); FK menu_id -> Menu(id))", "source": "bird", "db_id": "bird_db_0028", "query_type": "projection_case", "query_type_name": "Projection + CASE", "category": "Conditional Logic", "difficulty": "Hard", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.397491"}
{"question": "Among all the incidents with no arrest made, what is the percentage of them having a generic description of \"BATTERY\" in the IUCR classification?", "SQL": "SELECT CAST(SUM(CASE WHEN T1.primary_description = 'BATTERY' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*)FROM IUCR AS T1 INNER JOIN Crime AS T2 ON T1.iucr_no = T2.iucr_no WHERE T2.arrest = 'FALSE'", "db_schema": "Community_Area(community_area_no INTEGER, community_area_name TEXT, side TEXT, population TEXT; PRIMARY KEY(community_area_no))\nCrime(report_no INTEGER, case_number TEXT, date TEXT, block TEXT, iucr_no TEXT, location_description TEXT, arrest TEXT, domestic TEXT, beat INTEGER, district_no INTEGER, ward_no INTEGER, community_area_no INTEGER, fbi_code_no TEXT, latitude TEXT, longitude TEXT; PRIMARY KEY(report_no); FK fbi_code_no -> FBI_Code(fbi_code_no); FK community_area_no -> Community_Area(community_area_no); FK district_no -> District(district_no); FK iucr_no -> IUCR(iucr_no); FK ward_no -> Ward(ward_no))\nDistrict(district_no INTEGER, district_name TEXT, address TEXT, zip_code INTEGER, commander TEXT, email TEXT, phone TEXT, fax TEXT, tty TEXT, twitter TEXT; PRIMARY KEY(district_no))\nFBI_Code(fbi_code_no TEXT, title TEXT, description TEXT, crime_against TEXT; PRIMARY KEY(fbi_code_no))\nIUCR(iucr_no TEXT, primary_description TEXT, secondary_description TEXT, index_code TEXT; PRIMARY KEY(iucr_no))\nNeighborhood(neighborhood_name TEXT, community_area_no INTEGER; PRIMARY KEY(neighborhood_name); FK community_area_no -> Community_Area(community_area_no))\nWard(ward_no INTEGER, alderman_first_name TEXT, alderman_last_name TEXT, alderman_name_suffix TEXT, ward_office_address TEXT, ward_office_zip TEXT, ward_email TEXT, ward_office_phone TEXT, ward_office_fax TEXT, city_hall_office_room INTEGER, city_hall_office_phone TEXT, city_hall_office_fax TEXT, Population INTEGER; PRIMARY KEY(ward_no))", "source": "bird", "db_id": "bird_db_1449", "query_type": "projection_case", "query_type_name": "Projection + CASE", "category": "Conditional Logic", "difficulty": "Hard", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.397491"}
{"question": "Among the orders placed by Pacific Ltd, how many orders have been applied 5% discount ?", "SQL": "SELECT SUM(CASE WHEN T1.`Discount Applied` = 0.05 AND T2.`Customer Names` = 'Pacific Ltd' THEN 1 ELSE 0 END) FROM `Sales Orders` AS T1 INNER JOIN Customers AS T2 ON T2.CustomerID = T1._CustomerID", "db_schema": "Customers(CustomerID INTEGER, Customer Names TEXT; PRIMARY KEY(CustomerID))\nProducts(ProductID INTEGER, Product Name TEXT; PRIMARY KEY(ProductID))\nRegions(StateCode TEXT, State TEXT, Region TEXT; PRIMARY KEY(StateCode))\nSales Orders(OrderNumber TEXT, Sales Channel TEXT, WarehouseCode TEXT, ProcuredDate TEXT, OrderDate TEXT, ShipDate TEXT, DeliveryDate TEXT, CurrencyCode TEXT, _SalesTeamID INTEGER, _CustomerID INTEGER, _StoreID INTEGER, _ProductID INTEGER, Order Quantity INTEGER, Discount Applied REAL, Unit Price TEXT, Unit Cost TEXT; PRIMARY KEY(OrderNumber); FK _ProductID -> Products(ProductID); FK _StoreID -> Store Locations(StoreID); FK _CustomerID -> Customers(CustomerID); FK _SalesTeamID -> Sales Team(SalesTeamID))\nSales Team(SalesTeamID INTEGER, Sales Team TEXT, Region TEXT; PRIMARY KEY(SalesTeamID))\nStore Locations(StoreID INTEGER, City Name TEXT, County TEXT, StateCode TEXT, State TEXT, Type TEXT, Latitude REAL, Longitude REAL, AreaCode INTEGER, Population INTEGER, Household Income INTEGER, Median Income INTEGER, Land Area INTEGER, Water Area INTEGER, Time Zone TEXT; PRIMARY KEY(StoreID); FK StateCode -> Regions(StateCode))", "source": "bird", "db_id": "bird_db_1913", "query_type": "projection_case", "query_type_name": "Projection + CASE", "category": "Conditional Logic", "difficulty": "Hard", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.397491"}
{"question": "Among the incidents reported in Harrison, what percentage are disorderly conduct?", "SQL": "SELECT COUNT(CASE WHEN T3.title = 'Disorderly Conduct' THEN T2.report_no END) * 100.0 / COUNT(T2.report_no) AS per FROM District AS T1 INNER JOIN Crime AS T2 ON T2.district_no = T1.district_no INNER JOIN FBI_Code AS T3 ON T3.fbi_code_no = T2.fbi_code_no WHERE T1.district_name = 'Harrison'", "db_schema": "Community_Area(community_area_no INTEGER, community_area_name TEXT, side TEXT, population TEXT; PRIMARY KEY(community_area_no))\nCrime(report_no INTEGER, case_number TEXT, date TEXT, block TEXT, iucr_no TEXT, location_description TEXT, arrest TEXT, domestic TEXT, beat INTEGER, district_no INTEGER, ward_no INTEGER, community_area_no INTEGER, fbi_code_no TEXT, latitude TEXT, longitude TEXT; PRIMARY KEY(report_no); FK fbi_code_no -> FBI_Code(fbi_code_no); FK community_area_no -> Community_Area(community_area_no); FK district_no -> District(district_no); FK iucr_no -> IUCR(iucr_no); FK ward_no -> Ward(ward_no))\nDistrict(district_no INTEGER, district_name TEXT, address TEXT, zip_code INTEGER, commander TEXT, email TEXT, phone TEXT, fax TEXT, tty TEXT, twitter TEXT; PRIMARY KEY(district_no))\nFBI_Code(fbi_code_no TEXT, title TEXT, description TEXT, crime_against TEXT; PRIMARY KEY(fbi_code_no))\nIUCR(iucr_no TEXT, primary_description TEXT, secondary_description TEXT, index_code TEXT; PRIMARY KEY(iucr_no))\nNeighborhood(neighborhood_name TEXT, community_area_no INTEGER; PRIMARY KEY(neighborhood_name); FK community_area_no -> Community_Area(community_area_no))\nWard(ward_no INTEGER, alderman_first_name TEXT, alderman_last_name TEXT, alderman_name_suffix TEXT, ward_office_address TEXT, ward_office_zip TEXT, ward_email TEXT, ward_office_phone TEXT, ward_office_fax TEXT, city_hall_office_room INTEGER, city_hall_office_phone TEXT, city_hall_office_fax TEXT, Population INTEGER; PRIMARY KEY(ward_no))", "source": "bird", "db_id": "bird_db_1713", "query_type": "projection_case", "query_type_name": "Projection + CASE", "category": "Conditional Logic", "difficulty": "Hard", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.397491"}
{"question": "What is the proportion of the papers that have the keyword \"cancer\"? Please provide a list of authors and their affiliations.", "SQL": "SELECT CAST(SUM(CASE WHEN T1.Keyword = 'cancer' THEN 1 ELSE 0 END) AS REAL) / COUNT(T1.Id), T2.Name, T2.Affiliation FROM Paper AS T1 INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId", "db_schema": "Author(Id INTEGER, Name TEXT, Affiliation TEXT; PRIMARY KEY(Id))\nConference(Id INTEGER, ShortName TEXT, FullName TEXT, HomePage TEXT; PRIMARY KEY(Id))\nJournal(Id INTEGER, ShortName TEXT, FullName TEXT, HomePage TEXT; PRIMARY KEY(Id))\nPaper(Id INTEGER, Title TEXT, Year INTEGER, ConferenceId INTEGER, JournalId INTEGER, Keyword TEXT; PRIMARY KEY(Id); FK JournalId -> Journal(Id); FK ConferenceId -> Conference(Id))\nPaperAuthor(PaperId INTEGER, AuthorId INTEGER, Name TEXT, Affiliation TEXT; FK AuthorId -> Author(Id); FK PaperId -> Paper(Id))", "source": "bird", "db_id": "bird_db_1620", "query_type": "projection_case", "query_type_name": "Projection + CASE", "category": "Conditional Logic", "difficulty": "Hard", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.397491"}
{"question": "What is the percentage of the ratings were rated by user who was a subcriber?", "SQL": "SELECT CAST(SUM(CASE WHEN user_subscriber = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM ratings", "db_schema": "lists(user_id INTEGER, list_id INTEGER, list_title TEXT, list_movie_number INTEGER, list_update_timestamp_utc TEXT, list_creation_timestamp_utc TEXT, list_followers INTEGER, list_url TEXT, list_comments INTEGER, list_description TEXT, list_cover_image_url TEXT, list_first_image_url TEXT, list_second_image_url TEXT, list_third_image_url TEXT; PRIMARY KEY(list_id); FK user_id -> lists_users(user_id))\nlists_users(user_id INTEGER, list_id INTEGER, list_update_date_utc TEXT, list_creation_date_utc TEXT, user_trialist INTEGER, user_subscriber INTEGER, user_avatar_image_url TEXT, user_cover_image_url TEXT, user_eligible_for_trial TEXT, user_has_payment_method TEXT; PRIMARY KEY(user_id, list_id); FK user_id -> lists(user_id); FK list_id -> lists(list_id))\nmovies(movie_id INTEGER, movie_title TEXT, movie_release_year INTEGER, movie_url TEXT, movie_title_language TEXT, movie_popularity INTEGER, movie_image_url TEXT, director_id TEXT, director_name TEXT, director_url TEXT; PRIMARY KEY(movie_id))\nratings(movie_id INTEGER, rating_id INTEGER, rating_url TEXT, rating_score INTEGER, rating_timestamp_utc TEXT, critic TEXT, critic_likes INTEGER, critic_comments INTEGER, user_id INTEGER, user_trialist INTEGER, user_subscriber INTEGER, user_eligible_for_trial INTEGER, user_has_payment_method INTEGER; FK user_id -> ratings_users(user_id); FK rating_id -> ratings(rating_id); FK user_id -> lists_users(user_id); FK movie_id -> movies(movie_id))\nratings_users(user_id INTEGER, rating_date_utc TEXT, user_trialist INTEGER, user_subscriber INTEGER, user_avatar_image_url TEXT, user_cover_image_url TEXT, user_eligible_for_trial INTEGER, user_has_payment_method INTEGER; FK user_id -> lists_users(user_id))", "source": "bird", "db_id": "bird_db_1489", "query_type": "projection_case", "query_type_name": "Projection + CASE", "category": "Conditional Logic", "difficulty": "Hard", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.397491"}
{"question": "Among the customers with an average income per inhabitant above 3000, what percentage are in their eighties?", "SQL": "SELECT CAST(SUM(CASE WHEN T1.age BETWEEN 80 AND 89 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.ID) FROM Customers AS T1 INNER JOIN Demog AS T2 ON T1.GEOID = T2.GEOID WHERE T2.INCOME_K > 3000", "db_schema": "Customers(ID INTEGER, SEX TEXT, MARITAL_STATUS TEXT, GEOID INTEGER, EDUCATIONNUM INTEGER, OCCUPATION TEXT, age INTEGER; PRIMARY KEY(ID); FK GEOID -> Demog(None))\nDemog(GEOID INTEGER, INHABITANTS_K REAL, INCOME_K REAL, A_VAR1 REAL, A_VAR2 REAL, A_VAR3 REAL, A_VAR4 REAL, A_VAR5 REAL, A_VAR6 REAL, A_VAR7 REAL, A_VAR8 REAL, A_VAR9 REAL, A_VAR10 REAL, A_VAR11 REAL, A_VAR12 REAL, A_VAR13 REAL, A_VAR14 REAL, A_VAR15 REAL, A_VAR16 REAL, A_VAR17 REAL, A_VAR18 REAL; PRIMARY KEY(GEOID))\nMailings1_2(REFID INTEGER, REF_DATE DATETIME, RESPONSE TEXT; PRIMARY KEY(REFID); FK REFID -> Customers(None))\nSales(EVENTID INTEGER, REFID INTEGER, EVENT_DATE DATETIME, AMOUNT REAL; PRIMARY KEY(EVENTID); FK REFID -> Customers(None))\nmailings3(REFID INTEGER, REF_DATE DATETIME, RESPONSE TEXT; PRIMARY KEY(REFID))", "source": "bird", "db_id": "bird_db_1910", "query_type": "projection_case", "query_type_name": "Projection + CASE", "category": "Conditional Logic", "difficulty": "Hard", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.397491"}
{"question": "Find the name of songs that does not have a back vocal.", "SQL": "SELECT DISTINCT title FROM vocals AS t1 JOIN songs AS t2 ON t1.songid  =  t2.songid EXCEPT SELECT t2.title FROM vocals AS t1 JOIN songs AS t2 ON t1.songid  =  t2.songid WHERE TYPE  =  \"back\"", "db_schema": "Songs(SongId number, Title text; PRIMARY KEY(SongId))\nAlbums(AId number, Title text, Year number, Label text, Type text; PRIMARY KEY(AId))\nBand(Id number, Firstname text, Lastname text; PRIMARY KEY(Id))\nInstruments(SongId number, BandmateId number, Instrument text; PRIMARY KEY(SongId); FK(SongId REFERENCES Songs(SongId)); FK(BandmateId REFERENCES Band(Id)))\nPerformance(SongId number, Bandmate number, StagePosition text; PRIMARY KEY(SongId); FK(SongId REFERENCES Songs(SongId)); FK(Bandmate REFERENCES Band(Id)))\nTracklists(AlbumId number, Position number, SongId number; PRIMARY KEY(AlbumId); FK(AlbumId REFERENCES Albums(AId)); FK(SongId REFERENCES Songs(SongId)))\nVocals(SongId number, Bandmate number, Type text; PRIMARY KEY(SongId); FK(SongId REFERENCES Songs(SongId)); FK(Bandmate REFERENCES Band(Id)))", "db_id": "music_2", "source": "spider", "query_type": "subquery", "query_type_name": "Subqueries (nested SELECT)", "category": "Nested Queries", "difficulty": "Hard", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.400497"}
{"question": "Find the names of stadiums which have never had any event.", "SQL": "SELECT name FROM stadium WHERE id NOT IN (SELECT stadium_id FROM event)", "db_schema": "swimmer(ID number, name text, Nationality text, meter_100 number, meter_200 text, meter_300 text, meter_400 text, meter_500 text, meter_600 text, meter_700 text, Time text; PRIMARY KEY(ID))\nstadium(ID number, name text, Capacity number, City text, Country text, Opening_year number; PRIMARY KEY(ID))\nevent(ID number, Name text, Stadium_ID number, Year text; PRIMARY KEY(ID); FK(Stadium_ID REFERENCES stadium(ID)))\nrecord(ID number, Result text, Swimmer_ID number, Event_ID number; PRIMARY KEY(Swimmer_ID); FK(Swimmer_ID REFERENCES swimmer(ID)); FK(Event_ID REFERENCES event(ID)))", "db_id": "swimming", "source": "spider", "query_type": "subquery", "query_type_name": "Subqueries (nested SELECT)", "category": "Nested Queries", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.400497"}
{"question": "Show ids of students who play video game and play sports.", "SQL": "SELECT StuID FROM Sportsinfo INTERSECT SELECT StuID FROM Plays_games", "db_schema": "Student(StuID number, LName text, Fname text, Age number, Sex text, Major number, Advisor number, city_code text; PRIMARY KEY(StuID))\nVideo_Games(GameID number, GName text, GType text; PRIMARY KEY(GameID))\nPlays_Games(StuID number, GameID number, Hours_Played number; FK(StuID REFERENCES Student(StuID)); FK(GameID REFERENCES Video_Games(GameID)))\nSportsInfo(StuID number, SportName text, HoursPerWeek number, GamesPlayed number, OnScholarship text; FK(StuID REFERENCES Student(StuID)))", "db_id": "game_1", "source": "spider", "query_type": "subquery", "query_type_name": "Subqueries (nested SELECT)", "category": "Nested Queries", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.400497"}
{"question": "Among all the female current legislators, how many of them have served for more than 4 terms?", "SQL": "SELECT COUNT(CID) FROM ( SELECT T1.bioguide_id AS CID FROM current AS T1 INNER JOIN `current-terms` AS T2 ON T1.bioguide_id = T2.bioguide WHERE T1.gender_bio = 'F' GROUP BY T2.bioguide HAVING COUNT(T2.bioguide) > 4 )", "db_schema": "current(ballotpedia_id TEXT, bioguide_id TEXT, birthday_bio DATE, cspan_id REAL, fec_id TEXT, first_name TEXT, gender_bio TEXT, google_entity_id_id TEXT, govtrack_id INTEGER, house_history_id REAL, icpsr_id REAL, last_name TEXT, lis_id TEXT, maplight_id REAL, middle_name TEXT, nickname_name TEXT, official_full_name TEXT, opensecrets_id TEXT, religion_bio TEXT, suffix_name TEXT, thomas_id INTEGER, votesmart_id REAL, wikidata_id TEXT, wikipedia_id TEXT; PRIMARY KEY(bioguide_id, cspan_id))\ncurrent-terms(address TEXT, bioguide TEXT, caucus TEXT, chamber TEXT, class REAL, contact_form TEXT, district REAL, end TEXT, fax TEXT, last TEXT, name TEXT, office TEXT, party TEXT, party_affiliations TEXT, phone TEXT, relation TEXT, rss_url TEXT, start TEXT, state TEXT, state_rank TEXT, title TEXT, type TEXT, url TEXT; PRIMARY KEY(bioguide, end); FK bioguide -> current(bioguide_id))\nhistorical(ballotpedia_id TEXT, bioguide_id TEXT, bioguide_previous_id TEXT, birthday_bio TEXT, cspan_id TEXT, fec_id TEXT, first_name TEXT, gender_bio TEXT, google_entity_id_id TEXT, govtrack_id INTEGER, house_history_alternate_id TEXT, house_history_id REAL, icpsr_id REAL, last_name TEXT, lis_id TEXT, maplight_id TEXT, middle_name TEXT, nickname_name TEXT, official_full_name TEXT, opensecrets_id TEXT, religion_bio TEXT, suffix_name TEXT, thomas_id TEXT, votesmart_id TEXT, wikidata_id TEXT, wikipedia_id TEXT; PRIMARY KEY(bioguide_id))\nhistorical-terms(address TEXT, bioguide TEXT, chamber TEXT, class REAL, contact_form TEXT, district REAL, end TEXT, fax TEXT, last TEXT, middle TEXT, name TEXT, office TEXT, party TEXT, party_affiliations TEXT, phone TEXT, relation TEXT, rss_url TEXT, start TEXT, state TEXT, state_rank TEXT, title TEXT, type TEXT, url TEXT; PRIMARY KEY(bioguide); FK bioguide -> historical(bioguide_id))\nsocial-media(bioguide TEXT, facebook TEXT, facebook_id REAL, govtrack REAL, instagram TEXT, instagram_id REAL, thomas INTEGER, twitter TEXT, twitter_id REAL, youtube TEXT, youtube_id TEXT; PRIMARY KEY(bioguide); FK bioguide -> current(bioguide_id))", "source": "bird", "db_id": "bird_db_0948", "query_type": "subquery", "query_type_name": "Subqueries (nested SELECT)", "category": "Nested Queries", "difficulty": "Hard", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.400497"}
{"question": "An American rapper '2Pac' released his first solo album in 1991, how many years have passed until his next album was released?", "SQL": "SELECT ( SELECT groupYear FROM torrents WHERE artist LIKE '2Pac' AND releaseType LIKE 'album' ORDER BY groupYear LIMIT 1, 1 ) - groupYear FROM torrents WHERE artist LIKE '2Pac' AND releaseType LIKE 'album' AND groupYear = 1991", "db_schema": "tags(index INTEGER, id INTEGER, tag TEXT; PRIMARY KEY(index); FK id -> torrents(None))\ntorrents(groupName TEXT, totalSnatched INTEGER, artist TEXT, groupYear INTEGER, releaseType TEXT, groupId INTEGER, id INTEGER; PRIMARY KEY(id))", "source": "bird", "db_id": "bird_db_0584", "query_type": "subquery", "query_type_name": "Subqueries (nested SELECT)", "category": "Nested Queries", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.400497"}
{"question": "Which market segment does the customer with the highest amount of debt belongs to?", "SQL": "SELECT c_mktsegment FROM customer WHERE c_acctbal = ( SELECT MIN(c_acctbal) FROM customer )", "db_schema": "customer(c_custkey INTEGER, c_mktsegment TEXT, c_nationkey INTEGER, c_name TEXT, c_address TEXT, c_phone TEXT, c_acctbal REAL, c_comment TEXT; PRIMARY KEY(c_custkey); FK c_nationkey -> nation(n_nationkey))\nlineitem(l_shipdate DATE, l_orderkey INTEGER, l_discount REAL, l_extendedprice REAL, l_suppkey INTEGER, l_quantity INTEGER, l_returnflag TEXT, l_partkey INTEGER, l_linestatus TEXT, l_tax REAL, l_commitdate DATE, l_receiptdate DATE, l_shipmode TEXT, l_linenumber INTEGER, l_shipinstruct TEXT, l_comment TEXT; PRIMARY KEY(l_orderkey, l_linenumber); FK l_partkey -> partsupp(ps_partkey); FK l_suppkey -> partsupp(ps_suppkey); FK l_orderkey -> orders(o_orderkey))\nnation(n_nationkey INTEGER, n_name TEXT, n_regionkey INTEGER, n_comment TEXT; PRIMARY KEY(n_nationkey); FK n_regionkey -> region(r_regionkey))\norders(o_orderdate DATE, o_orderkey INTEGER, o_custkey INTEGER, o_orderpriority TEXT, o_shippriority INTEGER, o_clerk TEXT, o_orderstatus TEXT, o_totalprice REAL, o_comment TEXT; PRIMARY KEY(o_orderkey); FK o_custkey -> customer(c_custkey))\npart(p_partkey INTEGER, p_type TEXT, p_size INTEGER, p_brand TEXT, p_name TEXT, p_container TEXT, p_mfgr TEXT, p_retailprice REAL, p_comment TEXT; PRIMARY KEY(p_partkey))\npartsupp(ps_partkey INTEGER, ps_suppkey INTEGER, ps_supplycost REAL, ps_availqty INTEGER, ps_comment TEXT; PRIMARY KEY(ps_partkey, ps_suppkey); FK ps_suppkey -> supplier(s_suppkey); FK ps_partkey -> part(p_partkey))\nregion(r_regionkey INTEGER, r_name TEXT, r_comment TEXT; PRIMARY KEY(r_regionkey))\nsupplier(s_suppkey INTEGER, s_nationkey INTEGER, s_comment TEXT, s_name TEXT, s_address TEXT, s_phone TEXT, s_acctbal REAL; PRIMARY KEY(s_suppkey); FK s_nationkey -> nation(n_nationkey))", "source": "bird", "db_id": "bird_db_1280", "query_type": "subquery", "query_type_name": "Subqueries (nested SELECT)", "category": "Nested Queries", "difficulty": "Hard", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.400497"}
{"question": "From which hometowns did no gymnasts come from?", "SQL": "SELECT DISTINCT Hometown FROM people EXCEPT SELECT DISTINCT T2.Hometown FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID  =  T2.People_ID", "db_schema": "gymnast(Gymnast_ID number, Floor_Exercise_Points number, Pommel_Horse_Points number, Rings_Points number, Vault_Points number, Parallel_Bars_Points number, Horizontal_Bar_Points number, Total_Points number; PRIMARY KEY(Gymnast_ID); FK(Gymnast_ID REFERENCES people(People_ID)))\npeople(People_ID number, Name text, Age number, Height number, Hometown text; PRIMARY KEY(People_ID))", "db_id": "gymnast", "source": "spider", "query_type": "subquery", "query_type_name": "Subqueries (nested SELECT)", "category": "Nested Queries", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.400497"}
{"question": "Which days had a minimum dew point smaller than any day in zip code 94107, and in which zip codes were those measurements taken?", "SQL": "SELECT date ,  zip_code FROM weather WHERE min_dew_point_f  <  (SELECT min(min_dew_point_f) FROM weather WHERE zip_code  =  94107)", "db_schema": "station(id number, name text, lat number, long number, dock_count number, city text, installation_date text; PRIMARY KEY(id))\nstatus(station_id number, bikes_available number, docks_available number, time text; FK(station_id REFERENCES station(id)))\ntrip(id number, duration number, start_date text, start_station_name text, start_station_id number, end_date text, end_station_name text, end_station_id number, bike_id number, subscription_type text, zip_code number; PRIMARY KEY(id))\nweather(date text, max_temperature_f number, mean_temperature_f number, min_temperature_f number, max_dew_point_f number, mean_dew_point_f number, min_dew_point_f number, max_humidity number, mean_humidity number, min_humidity number, max_sea_level_pressure_inches number, mean_sea_level_pressure_inches number, min_sea_level_pressure_inches number, max_visibility_miles number, mean_visibility_miles number, min_visibility_miles number, max_wind_Speed_mph number, mean_wind_speed_mph number, max_gust_speed_mph number, precipitation_inches number, cloud_cover number, events text, wind_dir_degrees number, zip_code number)", "db_id": "bike_1", "source": "spider", "query_type": "subquery", "query_type_name": "Subqueries (nested SELECT)", "category": "Nested Queries", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.400497"}
{"question": "Return the names of tracks that have no had any races.", "SQL": "SELECT name FROM track WHERE track_id NOT IN (SELECT track_id FROM race)", "db_schema": "race(Race_ID number, Name text, Class text, Date text, Track_ID text; PRIMARY KEY(Race_ID); FK(Track_ID REFERENCES track(Track_ID)))\ntrack(Track_ID number, Name text, Location text, Seating number, Year_Opened number; PRIMARY KEY(Track_ID))", "db_id": "race_track", "source": "spider", "query_type": "subquery", "query_type_name": "Subqueries (nested SELECT)", "category": "Nested Queries", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.400497"}
{"question": "Find the name of the person who has friends with age above 40 but not under age 30?", "SQL": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  40) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  30)", "db_schema": "Person(name text, age number, city text, gender text, job text; PRIMARY KEY(name))\nPersonFriend(name text, friend text, year number; FK(name REFERENCES Person(name)); FK(friend REFERENCES Person(name)))", "db_id": "network_2", "source": "spider", "query_type": "subquery", "query_type_name": "Subqueries (nested SELECT)", "category": "Nested Queries", "difficulty": "Hard", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.400497"}
{"question": "What are the official names of cities that have hosted more than one competition?", "SQL": "SELECT T1.Official_Name FROM city AS T1 JOIN farm_competition AS T2 ON T1.City_ID  =  T2.Host_city_ID GROUP BY T2.Host_city_ID HAVING COUNT(*)  >  1", "db_schema": "city(City_ID number, Official_Name text, Status text, Area_km_2 number, Population number, Census_Ranking text; PRIMARY KEY(City_ID))\nfarm(Farm_ID number, Year number, Total_Horses number, Working_Horses number, Total_Cattle number, Oxen number, Bulls number, Cows number, Pigs number, Sheep_and_Goats number; PRIMARY KEY(Farm_ID))\nfarm_competition(Competition_ID number, Year number, Theme text, Host_city_ID number, Hosts text; PRIMARY KEY(Competition_ID); FK(Host_city_ID REFERENCES city(City_ID)))\ncompetition_record(Competition_ID number, Farm_ID number, Rank number; PRIMARY KEY(Competition_ID); FK(Competition_ID REFERENCES farm_competition(Competition_ID)); FK(Farm_ID REFERENCES farm(Farm_ID)))", "db_id": "farm", "source": "spider", "query_type": "group_by_having", "query_type_name": "GROUP BY + HAVING", "category": "Aggregation Filtering", "difficulty": "Hard", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.402004"}
{"question": "Find the name of the ships that have more than one captain.", "SQL": "SELECT t1.name FROM ship AS t1 JOIN captain AS t2 ON t1.ship_id  =  t2.ship_id GROUP BY t2.ship_id HAVING count(*)  >  1", "db_schema": "captain(Captain_ID number, Name text, Ship_ID number, age text, Class text, Rank text; PRIMARY KEY(Captain_ID); FK(Ship_ID REFERENCES Ship(Ship_ID)))\nShip(Ship_ID number, Name text, Type text, Built_Year number, Class text, Flag text; PRIMARY KEY(Ship_ID))", "db_id": "ship_1", "source": "spider", "query_type": "group_by_having", "query_type_name": "GROUP BY + HAVING", "category": "Aggregation Filtering", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.402004"}
{"question": "Find the addresses and author IDs of the course authors that teach at least two courses.", "SQL": "SELECT T1.address_line_1 ,  T2.author_id FROM Course_Authors_and_Tutors AS T1 JOIN Courses AS T2 ON T1.author_id  =  T2.author_id GROUP BY T2.author_id HAVING Count(*)  >=  2", "db_schema": "Course_Authors_and_Tutors(author_id number, author_tutor_ATB text, login_name text, password text, personal_name text, middle_name text, family_name text, gender_mf text, address_line_1 text; PRIMARY KEY(author_id))\nStudents(student_id number, date_of_registration time, date_of_latest_logon time, login_name text, password text, personal_name text, middle_name text, family_name text; PRIMARY KEY(student_id))\nSubjects(subject_id number, subject_name text; PRIMARY KEY(subject_id))\nCourses(course_id number, author_id number, subject_id number, course_name text, course_description text; PRIMARY KEY(course_id); FK(author_id REFERENCES Course_Authors_and_Tutors(author_id)); FK(subject_id REFERENCES Subjects(subject_id)))\nStudent_Course_Enrolment(registration_id number, student_id number, course_id number, date_of_enrolment time, date_of_completion time; PRIMARY KEY(registration_id); FK(student_id REFERENCES Students(student_id)); FK(course_id REFERENCES Courses(course_id)))\nStudent_Tests_Taken(registration_id number, date_test_taken time, test_result text; FK(registration_id REFERENCES Student_Course_Enrolment(registration_id)))", "db_id": "e_learning", "source": "spider", "query_type": "group_by_having", "query_type_name": "GROUP BY + HAVING", "category": "Aggregation Filtering", "difficulty": "Hard", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.402004"}
{"question": "What is the name and country of origin for each artist who has released a song with a resolution higher than 900?", "SQL": "SELECT T1.artist_name ,  T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.resolution  >  900 GROUP BY T2.artist_name HAVING count(*)  >=  1", "db_schema": "genre(g_name text, rating text, most_popular_in text; PRIMARY KEY(g_name))\nartist(artist_name text, country text, gender text, preferred_genre text; PRIMARY KEY(artist_name); FK(preferred_genre REFERENCES genre(g_name)))\nfiles(f_id number, artist_name text, file_size text, duration text, formats text; PRIMARY KEY(f_id); FK(artist_name REFERENCES artist(artist_name)))\nsong(song_name text, artist_name text, country text, f_id number, genre_is text, rating number, languages text, releasedate time, resolution number; PRIMARY KEY(song_name); FK(artist_name REFERENCES artist(artist_name)); FK(f_id REFERENCES files(f_id)); FK(genre_is REFERENCES genre(g_name)))", "db_id": "music_1", "source": "spider", "query_type": "group_by_having", "query_type_name": "GROUP BY + HAVING", "category": "Aggregation Filtering", "difficulty": "Hard", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.402004"}
{"question": "Give the hometowns from which two or more gymnasts are from.", "SQL": "SELECT T2.Hometown FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID  =  T2.People_ID GROUP BY T2.Hometown HAVING COUNT(*)  >=  2", "db_schema": "gymnast(Gymnast_ID number, Floor_Exercise_Points number, Pommel_Horse_Points number, Rings_Points number, Vault_Points number, Parallel_Bars_Points number, Horizontal_Bar_Points number, Total_Points number; PRIMARY KEY(Gymnast_ID); FK(Gymnast_ID REFERENCES people(People_ID)))\npeople(People_ID number, Name text, Age number, Height number, Hometown text; PRIMARY KEY(People_ID))", "db_id": "gymnast", "source": "spider", "query_type": "group_by_having", "query_type_name": "GROUP BY + HAVING", "category": "Aggregation Filtering", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.402004"}
{"question": "Find the names of rooms that have been reserved for more than 60 times.", "SQL": "SELECT T2.roomName FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room HAVING count(*)  >  60", "db_schema": "Rooms(RoomId text, roomName text, beds number, bedType text, maxOccupancy number, basePrice number, decor text; PRIMARY KEY(RoomId))\nReservations(Code number, Room text, CheckIn text, CheckOut text, Rate number, LastName text, FirstName text, Adults number, Kids number; PRIMARY KEY(Code); FK(Room REFERENCES Rooms(RoomId)))", "db_id": "inn_1", "source": "spider", "query_type": "group_by_having", "query_type_name": "GROUP BY + HAVING", "category": "Aggregation Filtering", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.402004"}
{"question": "Please list director IDs who have the quality of at least 3 and have made at least 2 different genres of movies.", "SQL": "SELECT T1.directorid FROM directors AS T1 INNER JOIN movies2directors AS T2 ON T1.directorid = T2.directorid WHERE T1.d_quality >= 3 GROUP BY T1.directorid HAVING COUNT(T2.movieid) >= 2", "db_schema": "actors(actorid INTEGER, a_gender TEXT, a_quality INTEGER; PRIMARY KEY(actorid))\ndirectors(directorid INTEGER, d_quality INTEGER, avg_revenue INTEGER; PRIMARY KEY(directorid))\nmovies(movieid INTEGER, year INTEGER, isEnglish TEXT, country TEXT, runningtime INTEGER; PRIMARY KEY(movieid))\nmovies2actors(movieid INTEGER, actorid INTEGER, cast_num INTEGER; PRIMARY KEY(movieid, actorid); FK actorid -> actors(None); FK movieid -> movies(None))\nmovies2directors(movieid INTEGER, directorid INTEGER, genre TEXT; PRIMARY KEY(movieid, directorid); FK directorid -> directors(None); FK movieid -> movies(None))\nu2base(userid INTEGER, movieid INTEGER, rating TEXT; PRIMARY KEY(userid, movieid); FK movieid -> movies(None); FK userid -> users(None))\nusers(userid INTEGER, age TEXT, u_gender TEXT, occupation TEXT; PRIMARY KEY(userid))", "source": "bird", "db_id": "bird_db_0241", "query_type": "group_by_having", "query_type_name": "GROUP BY + HAVING", "category": "Aggregation Filtering", "difficulty": "Hard", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.402004"}
{"question": "Find the name and country of origin for all artists who have release at least one song of resolution above 900.", "SQL": "SELECT T1.artist_name ,  T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.resolution  >  900 GROUP BY T2.artist_name HAVING count(*)  >=  1", "db_schema": "genre(g_name text, rating text, most_popular_in text; PRIMARY KEY(g_name))\nartist(artist_name text, country text, gender text, preferred_genre text; PRIMARY KEY(artist_name); FK(preferred_genre REFERENCES genre(g_name)))\nfiles(f_id number, artist_name text, file_size text, duration text, formats text; PRIMARY KEY(f_id); FK(artist_name REFERENCES artist(artist_name)))\nsong(song_name text, artist_name text, country text, f_id number, genre_is text, rating number, languages text, releasedate time, resolution number; PRIMARY KEY(song_name); FK(artist_name REFERENCES artist(artist_name)); FK(f_id REFERENCES files(f_id)); FK(genre_is REFERENCES genre(g_name)))", "db_id": "music_1", "source": "spider", "query_type": "group_by_having", "query_type_name": "GROUP BY + HAVING", "category": "Aggregation Filtering", "difficulty": "Hard", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.402004"}
{"question": "Find the day in which the difference between the max temperature and min temperature was the smallest. Also report the difference.", "SQL": "SELECT date ,  max_temperature_f - min_temperature_f FROM weather ORDER BY max_temperature_f - min_temperature_f LIMIT 1", "db_schema": "station(id number, name text, lat number, long number, dock_count number, city text, installation_date text; PRIMARY KEY(id))\nstatus(station_id number, bikes_available number, docks_available number, time text; FK(station_id REFERENCES station(id)))\ntrip(id number, duration number, start_date text, start_station_name text, start_station_id number, end_date text, end_station_name text, end_station_id number, bike_id number, subscription_type text, zip_code number; PRIMARY KEY(id))\nweather(date text, max_temperature_f number, mean_temperature_f number, min_temperature_f number, max_dew_point_f number, mean_dew_point_f number, min_dew_point_f number, max_humidity number, mean_humidity number, min_humidity number, max_sea_level_pressure_inches number, mean_sea_level_pressure_inches number, min_sea_level_pressure_inches number, max_visibility_miles number, mean_visibility_miles number, min_visibility_miles number, max_wind_Speed_mph number, mean_wind_speed_mph number, max_gust_speed_mph number, precipitation_inches number, cloud_cover number, events text, wind_dir_degrees number, zip_code number)", "db_id": "bike_1", "source": "spider", "query_type": "order_limit", "query_type_name": "ORDER BY + LIMIT", "category": "Result Ordering", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.417011"}
{"question": "What are the names and years of the movies that has the top 3 highest rating star?", "SQL": "SELECT T2.title ,  T2.year FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID ORDER BY T1.stars DESC LIMIT 3", "db_schema": "Movie(mID number, title text, year number, director text; PRIMARY KEY(mID))\nReviewer(rID number, name text; PRIMARY KEY(rID))\nRating(rID number, mID number, stars number, ratingDate time; FK(rID REFERENCES Reviewer(rID)); FK(mID REFERENCES Movie(mID)))", "db_id": "movie_1", "source": "spider", "query_type": "order_limit", "query_type_name": "ORDER BY + LIMIT", "category": "Result Ordering", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.417011"}
{"question": "Find the name of the stadium that has the maximum capacity.", "SQL": "SELECT name FROM stadium ORDER BY capacity DESC LIMIT 1", "db_schema": "swimmer(ID number, name text, Nationality text, meter_100 number, meter_200 text, meter_300 text, meter_400 text, meter_500 text, meter_600 text, meter_700 text, Time text; PRIMARY KEY(ID))\nstadium(ID number, name text, Capacity number, City text, Country text, Opening_year number; PRIMARY KEY(ID))\nevent(ID number, Name text, Stadium_ID number, Year text; PRIMARY KEY(ID); FK(Stadium_ID REFERENCES stadium(ID)))\nrecord(ID number, Result text, Swimmer_ID number, Event_ID number; PRIMARY KEY(Swimmer_ID); FK(Swimmer_ID REFERENCES swimmer(ID)); FK(Event_ID REFERENCES event(ID)))", "db_id": "swimming", "source": "spider", "query_type": "order_limit", "query_type_name": "ORDER BY + LIMIT", "category": "Result Ordering", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.417011"}
{"question": "What is the highest acc percent score in the competition?", "SQL": "SELECT acc_percent FROM basketball_match ORDER BY acc_percent DESC LIMIT 1", "db_schema": "basketball_match(Team_ID number, School_ID number, Team_Name text, ACC_Regular_Season text, ACC_Percent text, ACC_Home text, ACC_Road text, All_Games text, All_Games_Percent number, All_Home text, All_Road text, All_Neutral text; PRIMARY KEY(Team_ID); FK(School_ID REFERENCES university(School_ID)))\nuniversity(School_ID number, School text, Location text, Founded number, Affiliation text, Enrollment number, Nickname text, Primary_conference text; PRIMARY KEY(School_ID))", "db_id": "university_basketball", "source": "spider", "query_type": "order_limit", "query_type_name": "ORDER BY + LIMIT", "category": "Result Ordering", "difficulty": "Easy", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.417011"}
{"question": "Find the name of project that continues for the longest time.", "SQL": "SELECT name FROM projects ORDER BY hours DESC LIMIT 1", "db_schema": "Scientists(SSN number, Name text; PRIMARY KEY(SSN))\nProjects(Code text, Name text, Hours number; PRIMARY KEY(Code))\nAssignedTo(Scientist number, Project text; PRIMARY KEY(Scientist); FK(Scientist REFERENCES Scientists(SSN)); FK(Project REFERENCES Projects(Code)))", "db_id": "scientist_1", "source": "spider", "query_type": "order_limit", "query_type_name": "ORDER BY + LIMIT", "category": "Result Ordering", "difficulty": "Easy", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.417011"}
{"question": "Give the web site address for \"Swarthmore College\".", "SQL": "SELECT T FROM ( SELECT DISTINCT CASE WHEN chronname = 'Swarthmore College' THEN site ELSE NULL END AS T FROM institution_details ) WHERE T IS NOT NULL", "db_schema": "institution_details(unitid INTEGER, chronname TEXT, city TEXT, state TEXT, level TEXT, control TEXT, basic TEXT, hbcu TEXT, flagship TEXT, long_x REAL, lat_y REAL, site TEXT, student_count INTEGER, awards_per_value REAL, awards_per_state_value REAL, awards_per_natl_value REAL, exp_award_value INTEGER, exp_award_state_value INTEGER, exp_award_natl_value INTEGER, exp_award_percentile INTEGER, ft_pct REAL, fte_value INTEGER, fte_percentile INTEGER, med_sat_value TEXT, med_sat_percentile TEXT, aid_value INTEGER, aid_percentile INTEGER, endow_value TEXT, endow_percentile TEXT, grad_100_value REAL, grad_100_percentile INTEGER, grad_150_value REAL, grad_150_percentile INTEGER, pell_value REAL, pell_percentile INTEGER, retain_value REAL, retain_percentile INTEGER, ft_fac_value REAL, ft_fac_percentile INTEGER, vsa_year TEXT, vsa_grad_after4_first TEXT, vsa_grad_elsewhere_after4_first TEXT, vsa_enroll_after4_first TEXT, vsa_enroll_elsewhere_after4_first TEXT, vsa_grad_after6_first TEXT, vsa_grad_elsewhere_after6_first TEXT, vsa_enroll_after6_first TEXT, vsa_enroll_elsewhere_after6_first TEXT, vsa_grad_after4_transfer TEXT, vsa_grad_elsewhere_after4_transfer TEXT, vsa_enroll_after4_transfer TEXT, vsa_enroll_elsewhere_after4_transfer TEXT, vsa_grad_after6_transfer TEXT, vsa_grad_elsewhere_after6_transfer TEXT, vsa_enroll_after6_transfer TEXT, vsa_enroll_elsewhere_after6_transfer TEXT, similar TEXT, state_sector_ct INTEGER, carnegie_ct INTEGER, counted_pct TEXT, nicknames TEXT, cohort_size INTEGER; PRIMARY KEY(unitid))\ninstitution_grads(unitid INTEGER, year INTEGER, gender TEXT, race TEXT, cohort TEXT, grad_cohort TEXT, grad_100 TEXT, grad_150 TEXT, grad_100_rate TEXT, grad_150_rate TEXT; FK unitid -> institution_details(unitid))\nstate_sector_details(stateid INTEGER, state TEXT, state_post TEXT, level TEXT, control TEXT, schools_count INTEGER, counted_pct TEXT, awards_per_state_value TEXT, awards_per_natl_value REAL, exp_award_state_value TEXT, exp_award_natl_value INTEGER, state_appr_value TEXT, state_appr_rank TEXT, grad_rate_rank TEXT, awards_per_rank TEXT; PRIMARY KEY(stateid, level, control); FK state -> institution_details(state))\nstate_sector_grads(stateid INTEGER, state TEXT, state_abbr TEXT, control TEXT, level TEXT, year INTEGER, gender TEXT, race TEXT, cohort TEXT, grad_cohort TEXT, grad_100 TEXT, grad_150 TEXT, grad_100_rate TEXT, grad_150_rate TEXT, grad_cohort_ct INTEGER; FK stateid -> state_sector_details(stateid); FK state -> institution_details(state))", "source": "bird", "db_id": "bird_db_1486", "query_type": "null_handling", "query_type_name": "NULL handling (IS NULL, COALESCE, IFNULL)", "category": "NULL Operations", "difficulty": "Hard", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.426011"}
{"question": "Which region is Joshua Bennet located in?", "SQL": "SELECT T FROM ( SELECT DISTINCT CASE WHEN `Sales Team` = 'Joshua Bennett' THEN Region ELSE NULL END AS T FROM `Sales Team` ) WHERE T IS NOT NULL", "db_schema": "Customers(CustomerID INTEGER, Customer Names TEXT; PRIMARY KEY(CustomerID))\nProducts(ProductID INTEGER, Product Name TEXT; PRIMARY KEY(ProductID))\nRegions(StateCode TEXT, State TEXT, Region TEXT; PRIMARY KEY(StateCode))\nSales Orders(OrderNumber TEXT, Sales Channel TEXT, WarehouseCode TEXT, ProcuredDate TEXT, OrderDate TEXT, ShipDate TEXT, DeliveryDate TEXT, CurrencyCode TEXT, _SalesTeamID INTEGER, _CustomerID INTEGER, _StoreID INTEGER, _ProductID INTEGER, Order Quantity INTEGER, Discount Applied REAL, Unit Price TEXT, Unit Cost TEXT; PRIMARY KEY(OrderNumber); FK _ProductID -> Products(ProductID); FK _StoreID -> Store Locations(StoreID); FK _CustomerID -> Customers(CustomerID); FK _SalesTeamID -> Sales Team(SalesTeamID))\nSales Team(SalesTeamID INTEGER, Sales Team TEXT, Region TEXT; PRIMARY KEY(SalesTeamID))\nStore Locations(StoreID INTEGER, City Name TEXT, County TEXT, StateCode TEXT, State TEXT, Type TEXT, Latitude REAL, Longitude REAL, AreaCode INTEGER, Population INTEGER, Household Income INTEGER, Median Income INTEGER, Land Area INTEGER, Water Area INTEGER, Time Zone TEXT; PRIMARY KEY(StoreID); FK StateCode -> Regions(StateCode))", "source": "bird", "db_id": "bird_db_0801", "query_type": "null_handling", "query_type_name": "NULL handling (IS NULL, COALESCE, IFNULL)", "category": "NULL Operations", "difficulty": "Hard", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.426011"}
{"question": "State the player ID and coach ID of person who have become coach after retirement.", "SQL": "SELECT playerID, coachID FROM Master WHERE playerID IS NOT NULL AND coachID IS NOT NULL", "db_schema": "AwardsCoaches(coachID TEXT, award TEXT, year INTEGER, lgID TEXT, note TEXT; FK coachID -> Coaches(coachID))\nAwardsMisc(name TEXT, ID TEXT, award TEXT, year INTEGER, lgID TEXT, note TEXT; PRIMARY KEY(name))\nAwardsPlayers(playerID TEXT, award TEXT, year INTEGER, lgID TEXT, note TEXT, pos TEXT; PRIMARY KEY(playerID, award, year); FK playerID -> Master(playerID))\nCoaches(coachID TEXT, year INTEGER, tmID TEXT, lgID TEXT, stint INTEGER, notes TEXT, g INTEGER, w INTEGER, l INTEGER, t INTEGER, postg TEXT, postw TEXT, postl TEXT, postt TEXT; PRIMARY KEY(coachID, year, tmID, stint); FK year -> Teams(year); FK tmID -> Teams(tmID))\nCombinedShutouts(year INTEGER, month INTEGER, date INTEGER, tmID TEXT, oppID TEXT, R/P TEXT, IDgoalie1 TEXT, IDgoalie2 TEXT; FK IDgoalie2 -> Master(playerID); FK IDgoalie1 -> Master(playerID))\nGoalies(playerID TEXT, year INTEGER, stint INTEGER, tmID TEXT, lgID TEXT, GP TEXT, Min TEXT, W TEXT, L TEXT, T/OL TEXT, ENG TEXT, SHO TEXT, GA TEXT, SA TEXT, PostGP TEXT, PostMin TEXT, PostW TEXT, PostL TEXT, PostT TEXT, PostENG TEXT, PostSHO TEXT, PostGA TEXT, PostSA TEXT; PRIMARY KEY(playerID, year, stint); FK playerID -> Master(playerID); FK year -> Teams(year); FK tmID -> Teams(tmID))\nGoaliesSC(playerID TEXT, year INTEGER, tmID TEXT, lgID TEXT, GP INTEGER, Min INTEGER, W INTEGER, L INTEGER, T INTEGER, SHO INTEGER, GA INTEGER; PRIMARY KEY(playerID, year); FK playerID -> Master(playerID); FK year -> Teams(year); FK tmID -> Teams(tmID))\nGoaliesShootout(playerID TEXT, year INTEGER, stint INTEGER, tmID TEXT, W INTEGER, L INTEGER, SA INTEGER, GA INTEGER; FK playerID -> Master(playerID); FK year -> Teams(year); FK tmID -> Teams(tmID))\nHOF(year INTEGER, hofID TEXT, name TEXT, category TEXT; PRIMARY KEY(hofID))\nMaster(playerID TEXT, coachID TEXT, hofID TEXT, firstName TEXT, lastName TEXT, nameNote TEXT, nameGiven TEXT, nameNick TEXT, height TEXT, weight TEXT, shootCatch TEXT, legendsID TEXT, ihdbID TEXT, hrefID TEXT, firstNHL TEXT, lastNHL TEXT, firstWHA TEXT, lastWHA TEXT, pos TEXT, birthYear TEXT, birthMon TEXT, birthDay TEXT, birthCountry TEXT, birthState TEXT, birthCity TEXT, deathYear TEXT, deathMon TEXT, deathDay TEXT, deathCountry TEXT, deathState TEXT, deathCity TEXT; FK coachID -> Coaches(coachID))\nScoring(playerID TEXT, year INTEGER, stint INTEGER, tmID TEXT, lgID TEXT, pos TEXT, GP INTEGER, G INTEGER, A INTEGER, Pts INTEGER, PIM INTEGER, +/- TEXT, PPG TEXT, PPA TEXT, SHG TEXT, SHA TEXT, GWG TEXT, GTG TEXT, SOG TEXT, PostGP TEXT, PostG TEXT, PostA TEXT, PostPts TEXT, PostPIM TEXT, Post+/- TEXT, PostPPG TEXT, PostPPA TEXT, PostSHG TEXT, PostSHA TEXT, PostGWG TEXT, PostSOG TEXT; FK playerID -> Master(playerID); FK year -> Teams(year); FK tmID -> Teams(tmID))\nScoringSC(playerID TEXT, year INTEGER, tmID TEXT, lgID TEXT, pos TEXT, GP INTEGER, G INTEGER, A INTEGER, Pts INTEGER, PIM INTEGER; FK playerID -> Master(playerID); FK year -> Teams(year); FK tmID -> Teams(tmID))\nScoringShootout(playerID TEXT, year INTEGER, stint INTEGER, tmID TEXT, S INTEGER, G INTEGER, GDG INTEGER; FK playerID -> Master(playerID); FK year -> Teams(year); FK tmID -> Teams(tmID))\nScoringSup(playerID TEXT, year INTEGER, PPA TEXT, SHA TEXT; FK playerID -> Master(playerID))\nSeriesPost(year INTEGER, round TEXT, series TEXT, tmIDWinner TEXT, lgIDWinner TEXT, tmIDLoser TEXT, lgIDLoser TEXT, W INTEGER, L INTEGER, T INTEGER, GoalsWinner INTEGER, GoalsLoser INTEGER, note TEXT; FK year -> Teams(year); FK tmIDLoser -> Teams(tmID); FK year -> Teams(year); FK tmIDWinner -> Teams(tmID))\nTeamSplits(year INTEGER, lgID TEXT, tmID TEXT, hW INTEGER, hL INTEGER, hT INTEGER, hOTL TEXT, rW INTEGER, rL INTEGER, rT INTEGER, rOTL TEXT, SepW TEXT, SepL TEXT, SepT TEXT, SepOL TEXT, OctW TEXT, OctL TEXT, OctT TEXT, OctOL TEXT, NovW TEXT, NovL TEXT, NovT TEXT, NovOL TEXT, DecW TEXT, DecL TEXT, DecT TEXT, DecOL TEXT, JanW INTEGER, JanL INTEGER, JanT INTEGER, JanOL TEXT, FebW INTEGER, FebL INTEGER, FebT INTEGER, FebOL TEXT, MarW TEXT, MarL TEXT, MarT TEXT, MarOL TEXT, AprW TEXT, AprL TEXT, AprT TEXT, AprOL TEXT; PRIMARY KEY(year, tmID); FK year -> Teams(year); FK tmID -> Teams(tmID))\nTeamVsTeam(year INTEGER, lgID TEXT, tmID TEXT, oppID TEXT, W INTEGER, L INTEGER, T INTEGER, OTL TEXT; PRIMARY KEY(year, tmID, oppID); FK oppID -> Teams(tmID); FK year -> Teams(year); FK year -> Teams(year); FK tmID -> Teams(tmID))\nTeams(year INTEGER, lgID TEXT, tmID TEXT, franchID TEXT, confID TEXT, divID TEXT, rank INTEGER, playoff TEXT, G INTEGER, W INTEGER, L INTEGER, T INTEGER, OTL TEXT, Pts INTEGER, SoW TEXT, SoL TEXT, GF INTEGER, GA INTEGER, name TEXT, PIM TEXT, BenchMinor TEXT, PPG TEXT, PPC TEXT, SHA TEXT, PKG TEXT, PKC TEXT, SHF TEXT; PRIMARY KEY(year, tmID))\nTeamsHalf(year INTEGER, lgID TEXT, tmID TEXT, half INTEGER, rank INTEGER, G INTEGER, W INTEGER, L INTEGER, T INTEGER, GF INTEGER, GA INTEGER; PRIMARY KEY(year, tmID, half); FK tmID -> Teams(tmID); FK year -> Teams(year))\nTeamsPost(year INTEGER, lgID TEXT, tmID TEXT, G INTEGER, W INTEGER, L INTEGER, T INTEGER, GF INTEGER, GA INTEGER, PIM TEXT, BenchMinor TEXT, PPG TEXT, PPC TEXT, SHA TEXT, PKG TEXT, PKC TEXT, SHF TEXT; PRIMARY KEY(year, tmID); FK year -> Teams(year); FK tmID -> Teams(tmID))\nTeamsSC(year INTEGER, lgID TEXT, tmID TEXT, G INTEGER, W INTEGER, L INTEGER, T INTEGER, GF INTEGER, GA INTEGER, PIM TEXT; PRIMARY KEY(year, tmID); FK year -> Teams(year); FK tmID -> Teams(tmID))\nabbrev(Type TEXT, Code TEXT, Fullname TEXT; PRIMARY KEY(Type, Code))", "source": "bird", "db_id": "bird_db_0177", "query_type": "null_handling", "query_type_name": "NULL handling (IS NULL, COALESCE, IFNULL)", "category": "NULL Operations", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.426011"}
{"question": "Calculate the average duration of absense of female students.", "SQL": "SELECT AVG(T2.month) FROM person AS T1 INNER JOIN longest_absense_from_school AS T2 ON T1.name = T2.name LEFT JOIN male AS T3 ON T1.name = T3.name WHERE T3.name IS NULL", "db_schema": "bool(name TEXT; PRIMARY KEY(name))\ndisabled(name TEXT; PRIMARY KEY(name); FK name -> person(name))\nenlist(name TEXT, organ TEXT; FK name -> person(name))\nenrolled(name TEXT, school TEXT, month INTEGER; PRIMARY KEY(name, school); FK name -> person(name))\nfiled_for_bankrupcy(name TEXT; PRIMARY KEY(name); FK name -> person(name))\nlongest_absense_from_school(name TEXT, month INTEGER; PRIMARY KEY(name); FK name -> person(name))\nmale(name TEXT; PRIMARY KEY(name); FK name -> person(name))\nno_payment_due(name TEXT, bool TEXT; PRIMARY KEY(name); FK bool -> bool(name); FK name -> person(name))\nperson(name TEXT; PRIMARY KEY(name))\nunemployed(name TEXT; PRIMARY KEY(name); FK name -> person(name))", "source": "bird", "db_id": "bird_db_1958", "query_type": "null_handling", "query_type_name": "NULL handling (IS NULL, COALESCE, IFNULL)", "category": "NULL Operations", "difficulty": "Hard", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.426011"}
{"question": "Please list the official full names of all the current legislators who do not have an account on C-SPAN's video website.", "SQL": "SELECT official_full_name FROM current WHERE cspan_id IS NULL OR cspan_id = ''", "db_schema": "current(ballotpedia_id TEXT, bioguide_id TEXT, birthday_bio DATE, cspan_id REAL, fec_id TEXT, first_name TEXT, gender_bio TEXT, google_entity_id_id TEXT, govtrack_id INTEGER, house_history_id REAL, icpsr_id REAL, last_name TEXT, lis_id TEXT, maplight_id REAL, middle_name TEXT, nickname_name TEXT, official_full_name TEXT, opensecrets_id TEXT, religion_bio TEXT, suffix_name TEXT, thomas_id INTEGER, votesmart_id REAL, wikidata_id TEXT, wikipedia_id TEXT; PRIMARY KEY(bioguide_id, cspan_id))\ncurrent-terms(address TEXT, bioguide TEXT, caucus TEXT, chamber TEXT, class REAL, contact_form TEXT, district REAL, end TEXT, fax TEXT, last TEXT, name TEXT, office TEXT, party TEXT, party_affiliations TEXT, phone TEXT, relation TEXT, rss_url TEXT, start TEXT, state TEXT, state_rank TEXT, title TEXT, type TEXT, url TEXT; PRIMARY KEY(bioguide, end); FK bioguide -> current(bioguide_id))\nhistorical(ballotpedia_id TEXT, bioguide_id TEXT, bioguide_previous_id TEXT, birthday_bio TEXT, cspan_id TEXT, fec_id TEXT, first_name TEXT, gender_bio TEXT, google_entity_id_id TEXT, govtrack_id INTEGER, house_history_alternate_id TEXT, house_history_id REAL, icpsr_id REAL, last_name TEXT, lis_id TEXT, maplight_id TEXT, middle_name TEXT, nickname_name TEXT, official_full_name TEXT, opensecrets_id TEXT, religion_bio TEXT, suffix_name TEXT, thomas_id TEXT, votesmart_id TEXT, wikidata_id TEXT, wikipedia_id TEXT; PRIMARY KEY(bioguide_id))\nhistorical-terms(address TEXT, bioguide TEXT, chamber TEXT, class REAL, contact_form TEXT, district REAL, end TEXT, fax TEXT, last TEXT, middle TEXT, name TEXT, office TEXT, party TEXT, party_affiliations TEXT, phone TEXT, relation TEXT, rss_url TEXT, start TEXT, state TEXT, state_rank TEXT, title TEXT, type TEXT, url TEXT; PRIMARY KEY(bioguide); FK bioguide -> historical(bioguide_id))\nsocial-media(bioguide TEXT, facebook TEXT, facebook_id REAL, govtrack REAL, instagram TEXT, instagram_id REAL, thomas INTEGER, twitter TEXT, twitter_id REAL, youtube TEXT, youtube_id TEXT; PRIMARY KEY(bioguide); FK bioguide -> current(bioguide_id))", "source": "bird", "db_id": "bird_db_0402", "query_type": "null_handling", "query_type_name": "NULL handling (IS NULL, COALESCE, IFNULL)", "category": "NULL Operations", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.426011"}
{"question": "List any five female students' names who enlisted for the air force.", "SQL": "SELECT T1.name FROM enlist AS T1 LEFT JOIN male AS T2 ON T2.name = T1.name WHERE T2.name IS NULL AND T1.organ = 'air_force' LIMIT 5", "db_schema": "bool(name TEXT; PRIMARY KEY(name))\ndisabled(name TEXT; PRIMARY KEY(name); FK name -> person(name))\nenlist(name TEXT, organ TEXT; FK name -> person(name))\nenrolled(name TEXT, school TEXT, month INTEGER; PRIMARY KEY(name, school); FK name -> person(name))\nfiled_for_bankrupcy(name TEXT; PRIMARY KEY(name); FK name -> person(name))\nlongest_absense_from_school(name TEXT, month INTEGER; PRIMARY KEY(name); FK name -> person(name))\nmale(name TEXT; PRIMARY KEY(name); FK name -> person(name))\nno_payment_due(name TEXT, bool TEXT; PRIMARY KEY(name); FK bool -> bool(name); FK name -> person(name))\nperson(name TEXT; PRIMARY KEY(name))\nunemployed(name TEXT; PRIMARY KEY(name); FK name -> person(name))", "source": "bird", "db_id": "bird_db_0832", "query_type": "null_handling", "query_type_name": "NULL handling (IS NULL, COALESCE, IFNULL)", "category": "NULL Operations", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.426011"}
{"question": "What are the names of enzymes that include the string 'ALA'?", "SQL": "SELECT name FROM enzyme WHERE name LIKE \"%ALA%\"", "db_schema": "medicine(id number, name text, Trade_Name text, FDA_approved text; PRIMARY KEY(id))\nenzyme(id number, name text, Location text, Product text, Chromosome text, OMIM number, Porphyria text; PRIMARY KEY(id))\nmedicine_enzyme_interaction(enzyme_id number, medicine_id number, interaction_type text; PRIMARY KEY(enzyme_id); FK(enzyme_id REFERENCES enzyme(id)); FK(medicine_id REFERENCES medicine(id)))", "db_id": "medicine_enzyme_interaction", "source": "spider", "query_type": "string_semantics", "query_type_name": "String semantics (LIKE, %, CONCAT)", "category": "String Operations", "difficulty": "Easy", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.439013"}
{"question": "List all the keywords with \"christmas\" in them.", "SQL": "SELECT keyword_name FROM keyword WHERE keyword_name LIKE '%christmas%'", "db_schema": "country(country_id INTEGER, country_iso_code TEXT, country_name TEXT; PRIMARY KEY(country_id))\ndepartment(department_id INTEGER, department_name TEXT; PRIMARY KEY(department_id))\ngender(gender_id INTEGER, gender TEXT; PRIMARY KEY(gender_id))\ngenre(genre_id INTEGER, genre_name TEXT; PRIMARY KEY(genre_id))\nkeyword(keyword_id INTEGER, keyword_name TEXT; PRIMARY KEY(keyword_id))\nlanguage(language_id INTEGER, language_code TEXT, language_name TEXT; PRIMARY KEY(language_id))\nlanguage_role(role_id INTEGER, language_role TEXT; PRIMARY KEY(role_id))\nmovie(movie_id INTEGER, title TEXT, budget INTEGER, homepage TEXT, overview TEXT, popularity REAL, release_date DATE, revenue INTEGER, runtime INTEGER, movie_status TEXT, tagline TEXT, vote_average REAL, vote_count INTEGER; PRIMARY KEY(movie_id))\nmovie_cast(movie_id INTEGER, person_id INTEGER, character_name TEXT, gender_id INTEGER, cast_order INTEGER; FK person_id -> person(person_id); FK movie_id -> movie(movie_id); FK gender_id -> gender(gender_id))\nmovie_company(movie_id INTEGER, company_id INTEGER; FK company_id -> production_company(None); FK movie_id -> movie(None))\nmovie_crew(movie_id INTEGER, person_id INTEGER, department_id INTEGER, job TEXT; FK person_id -> person(person_id); FK movie_id -> movie(movie_id); FK department_id -> department(department_id))\nmovie_genres(movie_id INTEGER, genre_id INTEGER; FK movie_id -> movie(movie_id); FK genre_id -> genre(genre_id))\nmovie_keywords(movie_id INTEGER, keyword_id INTEGER; FK keyword_id -> keyword(None); FK movie_id -> movie(None))\nmovie_languages(movie_id INTEGER, language_id INTEGER, language_role_id INTEGER; FK language_role_id -> language_role(role_id); FK movie_id -> movie(movie_id); FK language_id -> language(language_id))\nperson(person_id INTEGER, person_name TEXT; PRIMARY KEY(person_id))\nproduction_company(company_id INTEGER, company_name TEXT; PRIMARY KEY(company_id))\nproduction_country(movie_id INTEGER, country_id INTEGER; FK movie_id -> movie(movie_id); FK country_id -> country(country_id))", "source": "bird", "db_id": "bird_db_1601", "query_type": "string_semantics", "query_type_name": "String semantics (LIKE, %, CONCAT)", "category": "String Operations", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.439013"}
{"question": "How many events had participants whose details had the substring 'Dr.'", "SQL": "SELECT count(*) FROM participants AS T1 JOIN Participants_in_Events AS T2 ON T1.Participant_ID  =  T2.Participant_ID WHERE T1.participant_details LIKE '%Dr.%'", "db_schema": "Services(Service_ID number, Service_Type_Code text; PRIMARY KEY(Service_ID))\nParticipants(Participant_ID number, Participant_Type_Code text, Participant_Details text; PRIMARY KEY(Participant_ID))\nEvents(Event_ID number, Service_ID number, Event_Details text; PRIMARY KEY(Event_ID); FK(Service_ID REFERENCES Services(Service_ID)))\nParticipants_in_Events(Event_ID number, Participant_ID number; PRIMARY KEY(Event_ID); FK(Event_ID REFERENCES Events(Event_ID)); FK(Participant_ID REFERENCES Participants(Participant_ID)))", "db_id": "local_govt_in_alabama", "source": "spider", "query_type": "string_semantics", "query_type_name": "String semantics (LIKE, %, CONCAT)", "category": "String Operations", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.439013"}
{"question": "Find all the building full names containing the word \"court\".", "SQL": "SELECT building_full_name FROM Apartment_Buildings WHERE building_full_name LIKE \"%court%\"", "db_schema": "Apartment_Buildings(building_id number, building_short_name text, building_full_name text, building_description text, building_address text, building_manager text, building_phone text; PRIMARY KEY(building_id))\nApartments(apt_id number, building_id number, apt_type_code text, apt_number text, bathroom_count number, bedroom_count number, room_count text; PRIMARY KEY(apt_id); FK(building_id REFERENCES Apartment_Buildings(building_id)))\nApartment_Facilities(apt_id number, facility_code text; PRIMARY KEY(apt_id); FK(apt_id REFERENCES Apartments(apt_id)))\nGuests(guest_id number, gender_code text, guest_first_name text, guest_last_name text, date_of_birth time; PRIMARY KEY(guest_id))\nApartment_Bookings(apt_booking_id number, apt_id number, guest_id number, booking_status_code text, booking_start_date time, booking_end_date time; PRIMARY KEY(apt_booking_id); FK(apt_id REFERENCES Apartments(apt_id)); FK(guest_id REFERENCES Guests(guest_id)))\nView_Unit_Status(apt_id number, apt_booking_id number, status_date time, available_yn others; PRIMARY KEY(status_date); FK(apt_id REFERENCES Apartments(apt_id)); FK(apt_booking_id REFERENCES Apartment_Bookings(apt_booking_id)))", "db_id": "apartment_rentals", "source": "spider", "query_type": "string_semantics", "query_type_name": "String semantics (LIKE, %, CONCAT)", "category": "String Operations", "difficulty": "Medium", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.439013"}
{"question": "Which brewery brewed the most sold root beer in 2015?", "SQL": "SELECT T3.BreweryName FROM rootbeer AS T1 INNER JOIN `transaction` AS T2 ON T1.RootBeerID = T2.RootBeerID INNER JOIN rootbeerbrand AS T3 ON T1.BrandID = T3.BrandID WHERE T2.TransactionDate LIKE '2015%' GROUP BY T3.BrandID ORDER BY COUNT(T1.BrandID) DESC LIMIT 1", "db_schema": "customers(CustomerID INTEGER, First TEXT, Last TEXT, StreetAddress TEXT, City TEXT, State TEXT, ZipCode INTEGER, Email TEXT, PhoneNumber TEXT, FirstPurchaseDate DATE, SubscribedToEmailList TEXT, Gender TEXT; PRIMARY KEY(CustomerID))\ngeolocation(LocationID INTEGER, Latitude REAL, Longitude REAL; PRIMARY KEY(LocationID); FK LocationID -> location(LocationID))\nlocation(LocationID INTEGER, LocationName TEXT, StreetAddress TEXT, City TEXT, State TEXT, ZipCode INTEGER; PRIMARY KEY(LocationID); FK LocationID -> geolocation(LocationID))\nrootbeer(RootBeerID INTEGER, BrandID INTEGER, ContainerType TEXT, LocationID INTEGER, PurchaseDate DATE; PRIMARY KEY(RootBeerID); FK BrandID -> rootbeerbrand(BrandID); FK LocationID -> location(LocationID); FK LocationID -> geolocation(LocationID))\nrootbeerbrand(BrandID INTEGER, BrandName TEXT, FirstBrewedYear INTEGER, BreweryName TEXT, City TEXT, State TEXT, Country TEXT, Description TEXT, CaneSugar TEXT, CornSyrup TEXT, Honey TEXT, ArtificialSweetener TEXT, Caffeinated TEXT, Alcoholic TEXT, AvailableInCans TEXT, AvailableInBottles TEXT, AvailableInKegs TEXT, Website TEXT, FacebookPage TEXT, Twitter TEXT, WholesaleCost REAL, CurrentRetailPrice REAL; PRIMARY KEY(BrandID))\nrootbeerreview(CustomerID INTEGER, BrandID INTEGER, StarRating INTEGER, ReviewDate DATE, Review TEXT; PRIMARY KEY(CustomerID, BrandID); FK BrandID -> rootbeerbrand(BrandID); FK CustomerID -> customers(CustomerID))\ntransaction(TransactionID INTEGER, CreditCardNumber INTEGER, CustomerID INTEGER, TransactionDate DATE, CreditCardType TEXT, LocationID INTEGER, RootBeerID INTEGER, PurchasePrice REAL; PRIMARY KEY(TransactionID); FK RootBeerID -> rootbeer(RootBeerID); FK LocationID -> location(LocationID); FK CustomerID -> customers(CustomerID))", "source": "bird", "db_id": "bird_db_0447", "query_type": "string_semantics", "query_type_name": "String semantics (LIKE, %, CONCAT)", "category": "String Operations", "difficulty": "Hard", "source_dataset": "BIRD+Spider", "extracted_at": "2025-12-28T08:55:07.439013"}
